{
  "version": 3,
  "sources": ["../../../dev/core/src/XR/webXRLayerWrapper.ts", "../../../dev/core/src/Materials/Textures/MultiviewRenderTarget.ts", "../../../dev/core/src/XR/webXRRenderTargetTextureProvider.ts", "../../../dev/core/src/XR/webXRWebGLLayer.ts", "../../../dev/core/src/XR/webXRManagedOutputCanvas.ts", "../../../dev/core/src/XR/native/nativeXRRenderTarget.ts", "../../../dev/core/src/XR/webXRSessionManager.ts", "../../../dev/core/src/Cameras/targetCamera.ts", "../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../../dev/core/src/Cameras/freeCamera.ts", "../../../dev/core/src/XR/webXRTypes.ts", "../../../dev/core/src/XR/webXRCamera.ts", "../../../dev/core/src/Cameras/touchCamera.ts", "../../../dev/core/src/Gamepads/gamepad.ts", "../../../dev/core/src/Gamepads/xboxGamepad.ts", "../../../dev/core/src/Gamepads/dualShockGamepad.ts", "../../../dev/core/src/Gamepads/gamepadManager.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts", "../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraGamepadInput.ts", "../../../dev/core/src/Gamepads/gamepadSceneComponent.ts", "../../../dev/core/src/Cameras/universalCamera.ts", "../../../dev/core/src/XR/webXRExperienceHelper.ts", "../../../dev/core/src/XR/motionController/webXRControllerComponent.ts", "../../../dev/core/src/XR/motionController/webXRAbstractMotionController.ts", "../../../dev/core/src/XR/motionController/webXRGenericMotionController.ts", "../../../dev/core/src/Meshes/Builders/sphereBuilder.ts", "../../../dev/core/src/XR/motionController/webXRProfiledMotionController.ts", "../../../dev/core/src/XR/motionController/webXRMotionControllerManager.ts", "../../../dev/core/src/XR/webXRInputSource.ts", "../../../dev/core/src/XR/webXRInput.ts", "../../../dev/core/src/Meshes/Builders/cylinderBuilder.ts", "../../../dev/core/src/Meshes/Builders/torusBuilder.ts", "../../../dev/core/src/XR/features/WebXRControllerPointerSelection.ts", "../../../dev/core/src/Animations/easing.ts", "../../../dev/core/src/Meshes/subMesh.project.ts", "../../../dev/core/src/XR/features/WebXRNearInteraction.ts", "../../../dev/core/src/XR/webXREnterExitUI.ts", "../../../dev/core/src/Meshes/instancedMesh.ts", "../../../dev/core/src/Shaders/color.fragment.ts", "../../../dev/core/src/Shaders/color.vertex.ts", "../../../dev/core/src/Meshes/linesMesh.ts", "../../../dev/core/src/Meshes/Builders/linesBuilder.ts", "../../../dev/core/src/Misc/timer.ts", "../../../dev/core/src/XR/features/WebXRControllerTeleportation.ts", "../../../dev/core/src/XR/webXRDefaultExperience.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRCompositionLayer */\r\n// TODO (rgerd): Extend for all other subclasses of XRCompositionLayer.\r\nexport type WebXRCompositionLayerType = \"XRProjectionLayer\";\r\nexport type WebXRQuadLayerType = \"XRQuadLayer\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRLayer */\r\nexport type WebXRLayerType = \"XRWebGLLayer\" | WebXRCompositionLayerType | WebXRQuadLayerType;\r\n\r\n/**\r\n * Wrapper over subclasses of XRLayer.\r\n * @internal\r\n */\r\nexport class WebXRLayerWrapper {\r\n    private _rttWrapper: Nullable<WebXRLayerRenderTargetTextureProvider> = null;\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this.layerType == \"XRWebGLLayer\" && typeof (this.layer as XRWebGLLayer).fixedFoveation == \"number\";\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        if (this.isFixedFoveationSupported) {\r\n            return (this.layer as XRWebGLLayer).fixedFoveation!;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        if (this.isFixedFoveationSupported) {\r\n            const val = Math.max(0, Math.min(1, value || 0));\r\n            (this.layer as XRWebGLLayer).fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a render target provider for the wrapped layer.\r\n     * @param xrSessionManager The XR Session Manager\r\n     * @returns A new render target texture provider for the wrapped layer.\r\n     */\r\n    public createRenderTargetTextureProvider(xrSessionManager: WebXRSessionManager): WebXRLayerRenderTargetTextureProvider {\r\n        this._rttWrapper = this._createRenderTargetTextureProvider(xrSessionManager);\r\n        return this._rttWrapper;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this._rttWrapper) {\r\n            this._rttWrapper.dispose();\r\n            this._rttWrapper = null;\r\n        }\r\n    }\r\n\r\n    protected constructor(\r\n        /** The width of the layer's framebuffer. */\r\n        public getWidth: () => number,\r\n        /** The height of the layer's framebuffer. */\r\n        public getHeight: () => number,\r\n        /** The XR layer that this WebXRLayerWrapper wraps. */\r\n        public readonly layer: XRLayer,\r\n        /** The type of XR layer that is being wrapped. */\r\n        public readonly layerType: WebXRLayerType,\r\n        /** Create a render target provider for the wrapped layer. */\r\n        private _createRenderTargetTextureProvider: (xrSessionManager: WebXRSessionManager) => WebXRLayerRenderTargetTextureProvider\r\n    ) {}\r\n}\r\n", "import { RenderTargetTexture } from \"../Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * Renders to multiple views with a single draw call\r\n * @see https://www.khronos.org/registry/webgl/extensions/OVR_multiview2/\r\n */\r\nexport class MultiviewRenderTarget extends RenderTargetTexture {\r\n    public set samples(value: number) {\r\n        // We override this setter because multisampling is handled by framebufferTextureMultisampleMultiviewOVR\r\n        this._samples = value;\r\n    }\r\n\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Creates a multiview render target\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"multiview rtt\", size, scene, false, true, Constants.TEXTURETYPE_UNSIGNED_INT, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = this.getScene()!.getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n        this.samples = this._getEngine()!.getCaps().maxSamples || this.samples;\r\n        this._texture.samples = this._samples;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        this.getScene()!.getEngine().bindMultiviewFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 2;\r\n    }\r\n}\r\n", "import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @internal\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(\r\n        private readonly _scene: Scene,\r\n        public readonly layerWrapper: WebXRLayerWrapper\r\n    ) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        renderTargetWrapper._samples = renderTargetTexture.samples;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\n\r\n/**\r\n * Wraps xr webgl layers.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerWrapper extends WebXRLayerWrapper {\r\n    /**\r\n     * @param layer is the layer to be wrapped.\r\n     * @returns a new WebXRLayerWrapper wrapping the provided XRWebGLLayer.\r\n     */\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRWebGLLayer.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    // The dimensions will always be defined in this class.\r\n    protected _framebufferDimensions: { framebufferWidth: number; framebufferHeight: number };\r\n    private _rtt: Nullable<RenderTargetTexture>;\r\n    private _framebuffer: WebGLFramebuffer;\r\n    private _layer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        public readonly layerWrapper: WebXRWebGLLayerWrapper\r\n    ) {\r\n        super(scene, layerWrapper);\r\n        this._layer = layerWrapper.layer;\r\n        this._framebufferDimensions = {\r\n            framebufferWidth: this._layer.framebufferWidth,\r\n            framebufferHeight: this._layer.framebufferHeight,\r\n        };\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const xrViewport = this._layer.getViewport(view);\r\n        if (!xrViewport) {\r\n            return false;\r\n        }\r\n        const framebufferWidth = this._framebufferDimensions.framebufferWidth;\r\n        const framebufferHeight = this._framebufferDimensions.framebufferHeight;\r\n        viewport.x = xrViewport.x / framebufferWidth;\r\n        viewport.y = xrViewport.y / framebufferHeight;\r\n        viewport.width = xrViewport.width / framebufferWidth;\r\n        viewport.height = xrViewport.height / framebufferHeight;\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        const layerWidth = this._layer.framebufferWidth;\r\n        const layerHeight = this._layer.framebufferHeight;\r\n        const framebuffer = this._layer.framebuffer;\r\n\r\n        if (\r\n            !this._rtt ||\r\n            layerWidth !== this._framebufferDimensions.framebufferWidth ||\r\n            layerHeight !== this._framebufferDimensions.framebufferHeight ||\r\n            framebuffer !== this._framebuffer\r\n        ) {\r\n            this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);\r\n            this._framebufferDimensions.framebufferWidth = layerWidth;\r\n            this._framebufferDimensions.framebufferHeight = layerHeight;\r\n            this._framebuffer = framebuffer;\r\n        }\r\n\r\n        return this._rtt;\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this.getRenderTargetTextureForEye(view.eye);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\n\r\n/**\r\n * Configuration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerInit;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: Nullable<ThinEngine> = null;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    private _xrLayerWrapper: Nullable<WebXRLayerWrapper> = null;\r\n\r\n    /**\r\n     * Observers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()\r\n    ) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n    }\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\r\n            this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\r\n            return this.xrLayer;\r\n        };\r\n\r\n        // support canvases without makeXRCompatible\r\n        if (!(this.canvasContext as any).makeXRCompatible) {\r\n            return Promise.resolve(createLayer());\r\n        }\r\n\r\n        return (this.canvasContext as any)\r\n            .makeXRCompatible()\r\n            .then(\r\n                // catch any error and continue. When using the emulator is throws this error for no apparent reason.\r\n                () => {},\r\n                () => {\r\n                    // log the error, continue nonetheless!\r\n                    Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\r\n                }\r\n            )\r\n            .then(() => {\r\n                return createLayer();\r\n            });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce(() => {\r\n                this._setCanvasSize(true);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this._xrLayerWrapper) {\r\n        if (!this._canvas || !this._engine) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.getWidth() + \"px\";\r\n                    this._canvas.style.height = xrLayer.getHeight() + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRLayerWrapper } from \"../webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { WebXRRenderTarget } from \"../webXRTypes\";\r\n\r\n/**\r\n * Wraps XRWebGLLayer's created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerWrapper extends WebXRLayerWrapper {\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new NativeXRLayerRenderTargetTextureProvider(sessionManager, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures for layers created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    private _nativeRTTProvider: WebXRLayerRenderTargetTextureProvider;\r\n    private _nativeLayer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        sessionManager: WebXRSessionManager,\r\n        public readonly layerWrapper: NativeXRLayerWrapper\r\n    ) {\r\n        super(sessionManager.scene, layerWrapper);\r\n        this._nativeRTTProvider = (navigator as any).xr.getNativeRenderTargetProvider(\r\n            sessionManager.session,\r\n            this._createRenderTargetTexture.bind(this),\r\n            this._destroyRenderTargetTexture.bind(this)\r\n        );\r\n        this._nativeLayer = layerWrapper.layer;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport): boolean {\r\n        viewport.x = 0;\r\n        viewport.y = 0;\r\n        viewport.width = 1;\r\n        viewport.height = 1;\r\n        return true;\r\n    }\r\n\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        // TODO (rgerd): Update the contract on the BabylonNative side to call this \"getRenderTargetTextureForEye\"\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(eye);\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(view.eye);\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return {\r\n            framebufferWidth: this._nativeLayer.framebufferWidth,\r\n            framebufferHeight: this._nativeLayer.framebufferHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the xr layer that will be used as the xr session's base layer.\r\n * @internal\r\n */\r\nexport class NativeXRRenderTarget implements WebXRRenderTarget {\r\n    public canvasContext: WebGLRenderingContext;\r\n    public xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    private _nativeRenderTarget: WebXRRenderTarget;\r\n\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        this._nativeRenderTarget = (navigator as any).xr.getWebXRRenderTarget(_xrSessionManager.scene.getEngine());\r\n    }\r\n\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        await this._nativeRenderTarget.initializeXRLayerAsync(xrSession);\r\n        this.xrLayer = this._nativeRenderTarget.xrLayer!;\r\n        return this.xrLayer;\r\n    }\r\n\r\n    dispose(): void {\r\n        /* empty */\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n\r\n    /**\r\n     * Fires when the xr reference space has been initialized\r\n     */\r\n    public onXRReferenceSpaceInitialized: Observable<XRReferenceSpace> = new Observable<XRReferenceSpace>();\r\n\r\n    /**\r\n     * Fires when the session manager is rendering the first frame\r\n     */\r\n    public onXRReady: Observable<WebXRSessionManager> = new Observable<WebXRSessionManager>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    private _worldScalingFactor: number = 1;\r\n\r\n    /**\r\n     * Observable raised when the world scale has changed\r\n     */\r\n    public onWorldScaleFactorChangedObservable: Observable<{\r\n        previousScaleFactor: number;\r\n        newScaleFactor: number;\r\n    }> = new Observable(undefined, true);\r\n\r\n    /**\r\n     * Scale factor to apply to all XR-related elements (camera, controllers)\r\n     */\r\n    public get worldScalingFactor(): number {\r\n        return this._worldScalingFactor;\r\n    }\r\n\r\n    public set worldScalingFactor(value: number) {\r\n        const oldValue = this._worldScalingFactor;\r\n        this._worldScalingFactor = value;\r\n        this.onWorldScaleFactorChangedObservable.notifyObservers({\r\n            previousScaleFactor: oldValue,\r\n            newScaleFactor: value,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine();\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this.onWorldScaleFactorChangedObservable.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public async exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            try {\r\n                return await this.session.end();\r\n            } catch {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            }\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionMode = xrSessionMode;\r\n            this.inXRSession = true;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    this.inXRSession = false;\r\n\r\n                    // Notify frame observers\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                    if (this._engine) {\r\n                        // make sure dimensions object is restored\r\n                        this._engine.framebufferDimensionsObject = null;\r\n\r\n                        // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                        this._engine.restoreDefaultFramebuffer();\r\n\r\n                        // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                        this._engine.customAnimationFrameRequester = null;\r\n                        this._engine._renderLoop();\r\n                    }\r\n\r\n                    // Dispose render target textures.\r\n                    // Only dispose on native because we can't destroy opaque textures on browser.\r\n                    if (this.isNative) {\r\n                        this._baseLayerRTTProvider?.dispose();\r\n                    }\r\n                    this._baseLayerRTTProvider = null;\r\n                    this._baseLayerWrapper = null;\r\n                },\r\n                { once: true }\r\n            );\r\n\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: (callback: FrameRequestCallback) => this.session.requestAnimationFrame(callback),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    const framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    // equality can be tested as it should be the same object\r\n                    if (this._engine.framebufferDimensionsObject !== framebufferDimensionsObject) {\r\n                        this._engine.framebufferDimensionsObject = framebufferDimensionsObject;\r\n                    }\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n        this.onXRFrameObservable.addOnce(() => {\r\n            this.onXRReady.notifyObservers(this);\r\n        });\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            // eslint-disable-next-line no-throw-literal\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                this.onXRReferenceSpaceInitialized.notifyObservers(referenceSpace);\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated Use updateRenderState() instead.\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return Promise.resolve(this.session.updateRenderState(state));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getBaseLayerWrapper(): Nullable<WebXRLayerWrapper> {\r\n        return this._baseLayerWrapper;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    public updateTargetFrameRate(rate: number): Promise<void> {\r\n        return this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the features enabled on the current session\r\n     * This is only available in-session!\r\n     * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\r\n     */\r\n    public get enabledFeatures(): Nullable<string[]> {\r\n        return this.session?.enabledFeatures ?? null;\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the context menu event\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * States of the webXR experience\r\n */\r\nexport enum WebXRState {\r\n    /**\r\n     * Transitioning to being in XR mode\r\n     */\r\n    ENTERING_XR,\r\n    /**\r\n     * Transitioning to non XR mode\r\n     */\r\n    EXITING_XR,\r\n    /**\r\n     * In XR mode and presenting\r\n     */\r\n    IN_XR,\r\n    /**\r\n     * Not entered XR mode\r\n     */\r\n    NOT_IN_XR,\r\n}\r\n\r\n/**\r\n * The state of the XR camera's tracking\r\n */\r\nexport enum WebXRTrackingState {\r\n    /**\r\n     * No transformation received, device is not being tracked\r\n     */\r\n    NOT_TRACKING,\r\n    /**\r\n     * Tracking lost - using emulated position\r\n     */\r\n    TRACKING_LOST,\r\n    /**\r\n     * Transformation tracking works normally\r\n     */\r\n    TRACKING,\r\n}\r\n\r\n/**\r\n * Abstraction of the XR render target\r\n */\r\nexport interface WebXRRenderTarget extends IDisposable {\r\n    /**\r\n     * xrpresent context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;\r\n}\r\n", "import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private static _ScaleReadOnly = Vector3.One();\r\n\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * This will be triggered after the first XR Frame initialized the camera,\r\n     * including the right number of views and their rendering parameters\r\n     */\r\n    public onXRCameraInitializedObservable = new Observable<WebXRCamera>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     * @deprecated use onBeforeCameraTeleport of the teleportation feature instead\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     * @deprecated use onAfterCameraTeleport of the teleportation feature instead\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * The last XRViewerPose from the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRViewerPose?: XRViewerPose;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        private _xrSessionManager: WebXRSessionManager\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n        this._deferOnly = true;\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.add(() => {\r\n                // only run if in session\r\n                if (!this._xrSessionManager.currentFrame) {\r\n                    return;\r\n                }\r\n                this._updateDepthNearFar();\r\n            });\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            () => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                if (this.onXRCameraInitializedObservable.hasObservers()) {\r\n                    this.onXRCameraInitializedObservable.notifyObservers(this);\r\n                    this.onXRCameraInitializedObservable.clear();\r\n                }\r\n\r\n                if (this._deferredUpdated) {\r\n                    this.position.copyFrom(this._deferredPositionUpdate);\r\n                    this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                }\r\n\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     *\r\n     * Note - this value is multiplied by the worldScalingFactor (if set), so it will be in the same units as the scene.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y * this._xrSessionManager.worldScalingFactor;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Set the target for the camera to look at.\r\n     * Note that this only rotates around the Y axis, as opposed to the default behavior of other cameras\r\n     * @param target the target to set the camera to look at\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        // only rotate around the y axis!\r\n        const tmpVector = TmpVectors.Vector3[1];\r\n        target.subtractToRef(this.position, tmpVector);\r\n        tmpVector.y = 0;\r\n        tmpVector.normalize();\r\n        const yRotation = Math.atan2(tmpVector.x, tmpVector.z);\r\n        this.rotationQuaternion.toEulerAnglesToRef(tmpVector);\r\n        Quaternion.FromEulerAnglesToRef(tmpVector.x, yRotation, tmpVector.z, this.rotationQuaternion);\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        this._lastXRViewerPose = undefined;\r\n    }\r\n\r\n    private _updateDepthNearFar() {\r\n        const far = (this.maxZ || 10000) * this._xrSessionManager.worldScalingFactor;\r\n        const xrRenderState: XRRenderStateInit = {\r\n            // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n            depthFar: far,\r\n            depthNear: this.minZ,\r\n        };\r\n\r\n        this._xrSessionManager.updateRenderState(xrRenderState);\r\n        this._cache.minZ = this.minZ;\r\n        this._cache.maxZ = far;\r\n    }\r\n\r\n    private _rotate180 = new Quaternion(0, 1, 0, 0);\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        this._lastXRViewerPose = pose || undefined;\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        // check min/max Z and update if not the same as in cache\r\n        if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\r\n            this._updateDepthNearFar();\r\n        }\r\n\r\n        if (pose.transform) {\r\n            const orientation = pose.transform.orientation;\r\n            if (pose.transform.orientation.x === undefined) {\r\n                // Babylon native polyfill can return an undefined orientation value\r\n                // When not initialized\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // add any custom render targets to this camera, if available in the scene\r\n            const customRenderTargets = this.getScene().customRenderTargets;\r\n            // use a for loop\r\n            for (let i = 0; i < customRenderTargets.length; i++) {\r\n                const rt = customRenderTargets[i];\r\n                // make sure we don't add the same render target twice\r\n                if (currentRig.customRenderTargets.indexOf(rt) === -1) {\r\n                    currentRig.customRenderTargets.push(rt);\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.parent = this.parent;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            } else {\r\n                currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\r\n            if (this._renderingMultiview) {\r\n                // For multiview, the render target texture is the same per-view (just the slice index is different),\r\n                // so we only need to set the output render target once for the rig parent.\r\n                if (i == 0) {\r\n                    this._xrSessionManager.trySetViewportForView(this.viewport, view);\r\n                    this.outputRenderTarget = renderTargetTexture;\r\n                }\r\n            } else {\r\n                // Update viewport\r\n                this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\r\n\r\n                // Set cameras to render to the session's render target\r\n                currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            }\r\n\r\n            // Replicate parent rig camera behavior\r\n            currentRig.layerMask = this.layerMask;\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            const removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            const referencedMat = TmpVectors.Matrix[0];\r\n            const poseMat = TmpVectors.Matrix[1];\r\n            const transformMat = TmpVectors.Matrix[2];\r\n\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\r\n            referencedMat.invert().multiplyToRef(poseMat, transformMat);\r\n            transformMat.invert();\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                transformMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\r\n            const transform = new XRRigidTransform(\r\n                {\r\n                    x: this._referencedPosition.x / this._xrSessionManager.worldScalingFactor,\r\n                    y: this._referencedPosition.y / this._xrSessionManager.worldScalingFactor,\r\n                    z: this._referencedPosition.z / this._xrSessionManager.worldScalingFactor,\r\n                },\r\n                {\r\n                    x: this._referenceQuaternion.x,\r\n                    y: this._referenceQuaternion.y,\r\n                    z: this._referenceQuaternion.z,\r\n                    w: this._referenceQuaternion.w,\r\n                }\r\n            );\r\n            this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n        }\r\n    }\r\n}\r\n", "import { FreeCamera } from \"./freeCamera\";\r\nimport type { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TouchCamera\", (name, scene) => {\r\n    return () => new TouchCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera controlled by touch.\r\n * This is like a universal camera minus the Gamepad controls.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class TouchCamera extends FreeCamera {\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    public get touchAngularSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchAngularSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    public get touchMoveSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchMoveSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new touch camera.\r\n     * This represents a FPS type of camera controlled by touch.\r\n     * This is like a universal camera minus the Gamepad controls.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addTouch();\r\n\r\n        this._setupInputs();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TouchCamera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _setupInputs() {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.touchEnabled = false;\r\n        } else {\r\n            touch.allowMouse = true;\r\n        }\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * Represents a gamepad control stick position\r\n */\r\nexport class StickValues {\r\n    /**\r\n     * Initializes the gamepad x and y control stick values\r\n     * @param x The x component of the gamepad control stick value\r\n     * @param y The y component of the gamepad control stick value\r\n     */\r\n    constructor(\r\n        /**\r\n         * The x component of the control stick\r\n         */\r\n        public x: number,\r\n        /**\r\n         * The y component of the control stick\r\n         */\r\n        public y: number\r\n    ) {}\r\n}\r\n\r\n/**\r\n * An interface which manages callbacks for gamepad button changes\r\n */\r\nexport interface GamepadButtonChanges {\r\n    /**\r\n     * Called when a gamepad has been changed\r\n     */\r\n    changed: boolean;\r\n    /**\r\n     * Called when a gamepad press event has been triggered\r\n     */\r\n    pressChanged: boolean;\r\n    /**\r\n     * Called when a touch event has been triggered\r\n     */\r\n    touchChanged: boolean;\r\n    /**\r\n     * Called when a value has changed\r\n     */\r\n    valueChanged: boolean;\r\n}\r\n\r\n/**\r\n * Represents a gamepad\r\n */\r\nexport class Gamepad {\r\n    /**\r\n     * Specifies what type of gamepad this represents\r\n     */\r\n    public type: number;\r\n\r\n    private _leftStick: StickValues = { x: 0, y: 0 };\r\n    private _rightStick: StickValues = { x: 0, y: 0 };\r\n\r\n    /** @internal */\r\n    public _isConnected = true;\r\n\r\n    private _leftStickAxisX: number;\r\n    private _leftStickAxisY: number;\r\n    private _rightStickAxisX: number;\r\n    private _rightStickAxisY: number;\r\n\r\n    /**\r\n     * Triggered when the left control stick has been changed\r\n     */\r\n    private _onleftstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Triggered when the right control stick has been changed\r\n     */\r\n    private _onrightstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Represents a gamepad controller\r\n     */\r\n    public static GAMEPAD = 0;\r\n    /**\r\n     * Represents a generic controller\r\n     */\r\n    public static GENERIC = 1;\r\n    /**\r\n     * Represents an XBox controller\r\n     */\r\n    public static XBOX = 2;\r\n    /**\r\n     * Represents a pose-enabled controller\r\n     */\r\n    public static POSE_ENABLED = 3;\r\n    /**\r\n     * Represents an Dual Shock controller\r\n     */\r\n    public static DUALSHOCK = 4;\r\n\r\n    /**\r\n     * Specifies whether the left control stick should be Y-inverted\r\n     */\r\n    protected _invertLeftStickY: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the gamepad has been connected\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this._isConnected;\r\n    }\r\n\r\n    /**\r\n     * Initializes the gamepad\r\n     * @param id The id of the gamepad\r\n     * @param index The index of the gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     * @param leftStickX The x component of the left joystick\r\n     * @param leftStickY The y component of the left joystick\r\n     * @param rightStickX The x component of the right joystick\r\n     * @param rightStickY The y component of the right joystick\r\n     */\r\n    constructor(\r\n        /**\r\n         * The id of the gamepad\r\n         */\r\n        public id: string,\r\n        /**\r\n         * The index of the gamepad\r\n         */\r\n        public index: number,\r\n        /**\r\n         * The browser gamepad\r\n         */\r\n        public browserGamepad: any,\r\n        leftStickX: number = 0,\r\n        leftStickY: number = 1,\r\n        rightStickX: number = 2,\r\n        rightStickY: number = 3\r\n    ) {\r\n        this.type = Gamepad.GAMEPAD;\r\n        this._leftStickAxisX = leftStickX;\r\n        this._leftStickAxisY = leftStickY;\r\n        this._rightStickAxisX = rightStickX;\r\n        this._rightStickAxisY = rightStickY;\r\n        if (this.browserGamepad.axes.length >= 2) {\r\n            this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n        }\r\n        if (this.browserGamepad.axes.length >= 4) {\r\n            this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the left joystick has changed\r\n     * @param callback callback to trigger\r\n     */\r\n    public onleftstickchanged(callback: (values: StickValues) => void) {\r\n        this._onleftstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the right joystick has changed\r\n     * @param callback callback to trigger\r\n     */\r\n    public onrightstickchanged(callback: (values: StickValues) => void) {\r\n        this._onrightstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left joystick\r\n     */\r\n    public get leftStick(): StickValues {\r\n        return this._leftStick;\r\n    }\r\n    /**\r\n     * Sets the left joystick values\r\n     */\r\n    public set leftStick(newValues: StickValues) {\r\n        if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {\r\n            this._onleftstickchanged(newValues);\r\n        }\r\n        this._leftStick = newValues;\r\n    }\r\n    /**\r\n     * Gets the right joystick\r\n     */\r\n    public get rightStick(): StickValues {\r\n        return this._rightStick;\r\n    }\r\n    /**\r\n     * Sets the right joystick value\r\n     */\r\n    public set rightStick(newValues: StickValues) {\r\n        if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {\r\n            this._onrightstickchanged(newValues);\r\n        }\r\n        this._rightStick = newValues;\r\n    }\r\n\r\n    /**\r\n     * Updates the gamepad joystick positions\r\n     */\r\n\r\n    public update() {\r\n        if (this._leftStick) {\r\n            this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n            if (this._invertLeftStickY) {\r\n                this.leftStick.y *= -1;\r\n            }\r\n        }\r\n        if (this._rightStick) {\r\n            this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {}\r\n}\r\n\r\n/**\r\n * Represents a generic gamepad\r\n */\r\nexport class GenericPad extends Gamepad {\r\n    private _buttons: Array<number>;\r\n    private _onbuttondown: (buttonPressed: number) => void;\r\n    private _onbuttonup: (buttonReleased: number) => void;\r\n\r\n    /**\r\n     * Observable triggered when a button has been pressed\r\n     */\r\n    public onButtonDownObservable = new Observable<number>();\r\n    /**\r\n     * Observable triggered when a button has been released\r\n     */\r\n    public onButtonUpObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Callback triggered when a button has been pressed\r\n     * @param callback Called when a button has been pressed\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: number) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n    /**\r\n     * Callback triggered when a button has been released\r\n     * @param callback Called when a button has been released\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: number) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Initializes the generic gamepad\r\n     * @param id The id of the generic gamepad\r\n     * @param index The index of the generic gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     */\r\n    constructor(id: string, index: number, browserGamepad: any) {\r\n        super(id, index, browserGamepad);\r\n        this.type = Gamepad.GENERIC;\r\n        this._buttons = new Array(browserGamepad.buttons.length);\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonIndex: number): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonIndex);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonIndex);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonIndex);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonIndex);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Updates the generic gamepad\r\n     */\r\n    public update() {\r\n        super.update();\r\n        for (let index = 0; index < this._buttons.length; index++) {\r\n            this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the generic gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"../Gamepads/gamepad\";\r\n/**\r\n * Defines supported buttons for XBox360 compatible gamepads\r\n */\r\nexport enum Xbox360Button {\r\n    /** A */\r\n    A = 0,\r\n    /** B */\r\n    B = 1,\r\n    /** X */\r\n    X = 2,\r\n    /** Y */\r\n    Y = 3,\r\n    /** Left button */\r\n    LB = 4,\r\n    /** Right button */\r\n    RB = 5,\r\n    /** Back */\r\n    Back = 8,\r\n    /** Start */\r\n    Start = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for XBox360 DPad  */\r\nexport enum Xbox360Dpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a XBox360 gamepad\r\n */\r\nexport class Xbox360Pad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: Xbox360Button) => void;\r\n    private _onbuttonup: (buttonReleased: Xbox360Button) => void;\r\n    private _ondpaddown: (dPadPressed: Xbox360Dpad) => void;\r\n    private _ondpadup: (dPadReleased: Xbox360Dpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<Xbox360Dpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<Xbox360Dpad>();\r\n\r\n    private _buttonA: number = 0;\r\n    private _buttonB: number = 0;\r\n    private _buttonX: number = 0;\r\n    private _buttonY: number = 0;\r\n    private _buttonBack: number = 0;\r\n    private _buttonStart: number = 0;\r\n    private _buttonLB: number = 0;\r\n    private _buttonRB: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    private _isXboxOnePad: boolean = false;\r\n\r\n    /**\r\n     * Creates a new XBox360 gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     * @param xboxOne defines if it is a XBox One gamepad\r\n     */\r\n    constructor(id: string, index: number, gamepad: any, xboxOne: boolean = false) {\r\n        super(id, index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.XBOX;\r\n        this._isXboxOnePad = xboxOne;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: Xbox360Button) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: Xbox360Button) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: Xbox360Dpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: Xbox360Dpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: Xbox360Button): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDPadValue(newValue: number, currentValue: number, buttonType: Xbox360Dpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `A` button\r\n     */\r\n    public get buttonA(): number {\r\n        return this._buttonA;\r\n    }\r\n    /**\r\n     * Sets the value of the `A` button\r\n     */\r\n    public set buttonA(value) {\r\n        this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `B` button\r\n     */\r\n    public get buttonB(): number {\r\n        return this._buttonB;\r\n    }\r\n    /**\r\n     * Sets the value of the `B` button\r\n     */\r\n    public set buttonB(value) {\r\n        this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `X` button\r\n     */\r\n    public get buttonX(): number {\r\n        return this._buttonX;\r\n    }\r\n    /**\r\n     * Sets the value of the `X` button\r\n     */\r\n    public set buttonX(value) {\r\n        this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Y` button\r\n     */\r\n    public get buttonY(): number {\r\n        return this._buttonY;\r\n    }\r\n    /**\r\n     * Sets the value of the `Y` button\r\n     */\r\n    public set buttonY(value) {\r\n        this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Start` button\r\n     */\r\n    public get buttonStart(): number {\r\n        return this._buttonStart;\r\n    }\r\n    /**\r\n     * Sets the value of the `Start` button\r\n     */\r\n    public set buttonStart(value) {\r\n        this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Back` button\r\n     */\r\n    public get buttonBack(): number {\r\n        return this._buttonBack;\r\n    }\r\n    /**\r\n     * Sets the value of the `Back` button\r\n     */\r\n    public set buttonBack(value) {\r\n        this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Left` button\r\n     */\r\n    public get buttonLB(): number {\r\n        return this._buttonLB;\r\n    }\r\n    /**\r\n     * Sets the value of the `Left` button\r\n     */\r\n    public set buttonLB(value) {\r\n        this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Right` button\r\n     */\r\n    public get buttonRB(): number {\r\n        return this._buttonRB;\r\n    }\r\n    /**\r\n     * Sets the value of the `Right` button\r\n     */\r\n    public set buttonRB(value) {\r\n        this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this._isXboxOnePad) {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        } else {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"./gamepad\";\r\n\r\n/**\r\n * Defines supported buttons for DualShock compatible gamepads\r\n */\r\nexport enum DualShockButton {\r\n    /** Cross */\r\n    Cross = 0,\r\n    /** Circle */\r\n    Circle = 1,\r\n    /** Square */\r\n    Square = 2,\r\n    /** Triangle */\r\n    Triangle = 3,\r\n    /** L1 */\r\n    L1 = 4,\r\n    /** R1 */\r\n    R1 = 5,\r\n    /** Share */\r\n    Share = 8,\r\n    /** Options */\r\n    Options = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for DualShock DPad  */\r\nexport enum DualShockDpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a DualShock gamepad\r\n */\r\nexport class DualShockPad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: DualShockButton) => void;\r\n    private _onbuttonup: (buttonReleased: DualShockButton) => void;\r\n    private _ondpaddown: (dPadPressed: DualShockDpad) => void;\r\n    private _ondpadup: (dPadReleased: DualShockDpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<DualShockDpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<DualShockDpad>();\r\n\r\n    private _buttonCross: number = 0;\r\n    private _buttonCircle: number = 0;\r\n    private _buttonSquare: number = 0;\r\n    private _buttonTriangle: number = 0;\r\n    private _buttonShare: number = 0;\r\n    private _buttonOptions: number = 0;\r\n    private _buttonL1: number = 0;\r\n    private _buttonR1: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    /**\r\n     * Creates a new DualShock gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     */\r\n    constructor(id: string, index: number, gamepad: any) {\r\n        super(id.replace(\"STANDARD GAMEPAD\", \"SONY PLAYSTATION DUALSHOCK\"), index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.DUALSHOCK;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: DualShockButton) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: DualShockButton) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: DualShockDpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: DualShockDpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: DualShockButton): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDPadValue(newValue: number, currentValue: number, buttonType: DualShockDpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Cross` button\r\n     */\r\n    public get buttonCross(): number {\r\n        return this._buttonCross;\r\n    }\r\n    /**\r\n     * Sets the value of the `Cross` button\r\n     */\r\n    public set buttonCross(value) {\r\n        this._buttonCross = this._setButtonValue(value, this._buttonCross, DualShockButton.Cross);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Circle` button\r\n     */\r\n    public get buttonCircle(): number {\r\n        return this._buttonCircle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Circle` button\r\n     */\r\n    public set buttonCircle(value) {\r\n        this._buttonCircle = this._setButtonValue(value, this._buttonCircle, DualShockButton.Circle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Square` button\r\n     */\r\n    public get buttonSquare(): number {\r\n        return this._buttonSquare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Square` button\r\n     */\r\n    public set buttonSquare(value) {\r\n        this._buttonSquare = this._setButtonValue(value, this._buttonSquare, DualShockButton.Square);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Triangle` button\r\n     */\r\n    public get buttonTriangle(): number {\r\n        return this._buttonTriangle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Triangle` button\r\n     */\r\n    public set buttonTriangle(value) {\r\n        this._buttonTriangle = this._setButtonValue(value, this._buttonTriangle, DualShockButton.Triangle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Options` button\r\n     */\r\n    public get buttonOptions(): number {\r\n        return this._buttonOptions;\r\n    }\r\n    /**\r\n     * Sets the value of the `Options` button\r\n     */\r\n    public set buttonOptions(value) {\r\n        this._buttonOptions = this._setButtonValue(value, this._buttonOptions, DualShockButton.Options);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Share` button\r\n     */\r\n    public get buttonShare(): number {\r\n        return this._buttonShare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Share` button\r\n     */\r\n    public set buttonShare(value) {\r\n        this._buttonShare = this._setButtonValue(value, this._buttonShare, DualShockButton.Share);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `L1` button\r\n     */\r\n    public get buttonL1(): number {\r\n        return this._buttonL1;\r\n    }\r\n    /**\r\n     * Sets the value of the `L1` button\r\n     */\r\n    public set buttonL1(value) {\r\n        this._buttonL1 = this._setButtonValue(value, this._buttonL1, DualShockButton.L1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `R1` button\r\n     */\r\n    public get buttonR1(): number {\r\n        return this._buttonR1;\r\n    }\r\n    /**\r\n     * Sets the value of the `R1` button\r\n     */\r\n    public set buttonR1(value) {\r\n        this._buttonR1 = this._setButtonValue(value, this._buttonR1, DualShockButton.R1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, DualShockButton.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, DualShockButton.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDPadValue(value, this._dPadUp, DualShockDpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDPadValue(value, this._dPadDown, DualShockDpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDPadValue(value, this._dPadLeft, DualShockDpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDPadValue(value, this._dPadRight, DualShockDpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public update() {\r\n        super.update();\r\n        this.buttonCross = this.browserGamepad.buttons[0].value;\r\n        this.buttonCircle = this.browserGamepad.buttons[1].value;\r\n        this.buttonSquare = this.browserGamepad.buttons[2].value;\r\n        this.buttonTriangle = this.browserGamepad.buttons[3].value;\r\n        this.buttonL1 = this.browserGamepad.buttons[4].value;\r\n        this.buttonR1 = this.browserGamepad.buttons[5].value;\r\n        this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n        this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n        this.buttonShare = this.browserGamepad.buttons[8].value;\r\n        this.buttonOptions = this.browserGamepad.buttons[9].value;\r\n        this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n        this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n        this.dPadUp = this.browserGamepad.buttons[12].value;\r\n        this.dPadDown = this.browserGamepad.buttons[13].value;\r\n        this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n        this.dPadRight = this.browserGamepad.buttons[15].value;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @internal */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && navigator.getGamepads;\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            this._checkGamepadsStatus();\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @internal */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring) {\r\n            Engine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Manage the gamepad inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Define the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Define the Gamepad controlling the input\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadAngularSensibility = 200;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    /**\r\n     * Defines the minimum value at which any analog stick input is ignored.\r\n     * Note: This value should only be a value between 0 and 1.\r\n     */\r\n    public deadzoneDelta = 0.1;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    // private members\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _cameraTransform: Matrix = Matrix.Identity();\r\n    private _deltaTransform: Vector3 = Vector3.Zero();\r\n    private _vector3: Vector3 = Vector3.Zero();\r\n    private _vector2: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        // check if there are already other controllers connected\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad && this.gamepad.leftStick) {\r\n            const camera = this.camera;\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (this.gamepadMoveSensibility !== 0) {\r\n                lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;\r\n                lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;\r\n            }\r\n\r\n            let rsValues = this.gamepad.rightStick;\r\n            if (rsValues && this.gamepadAngularSensibility !== 0) {\r\n                rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;\r\n                rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;\r\n            } else {\r\n                rsValues = { x: 0, y: 0 };\r\n            }\r\n\r\n            if (!camera.rotationQuaternion) {\r\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\r\n            } else {\r\n                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\r\n            }\r\n\r\n            const speed = camera._computeLocalCameraSpeed() * 50.0;\r\n            this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);\r\n\r\n            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\r\n            camera.cameraDirection.addInPlace(this._deltaTransform);\r\n            this._vector2.copyFromFloats(rsValues.y, rsValues.x);\r\n            camera.cameraRotation.addInPlace(this._vector2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && this._pointA?.pointerId !== evt.pointerId && this._pointB?.pointerId !== evt.pointerId) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type type of event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point The current position of the pointer\r\n     * @param offsetX The offsetX of the pointer when the event occurred\r\n     * @param offsetY The offsetY of the pointer when the event occurred\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the event to be handled\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n/**\r\n * Manage the gamepad inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the gamepad the input is gathering event from.\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadRotationSensibility = 80;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad) {\r\n            const camera = this.camera;\r\n            const rsValues = this.gamepad.rightStick;\r\n\r\n            if (rsValues) {\r\n                if (rsValues.x != 0) {\r\n                    const normalizedRX = rsValues.x / this.gamepadRotationSensibility;\r\n                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\r\n                        camera.inertialAlphaOffset += normalizedRX;\r\n                    }\r\n                }\r\n\r\n                if (rsValues.y != 0) {\r\n                    const normalizedRY = (rsValues.y / this.gamepadRotationSensibility) * this._yAxisScale;\r\n                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\r\n                        camera.inertialBetaOffset += normalizedRY;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (lsValues && lsValues.y != 0) {\r\n                const normalizedLY = lsValues.y / this.gamepadMoveSensibility;\r\n                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\r\n                    this.camera.inertialRadiusOffset -= normalizedLY;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\r\n", "import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { GamepadManager } from \"./gamepadManager\";\r\n\r\nimport { FreeCameraInputsManager } from \"../Cameras/freeCameraInputsManager\";\r\nimport { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { ArcRotateCameraGamepadInput } from \"../Cameras/Inputs/arcRotateCameraGamepadInput\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _gamepadManager: Nullable<GamepadManager>;\r\n\r\n        /**\r\n         * Gets the gamepad manager associated with the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/input/gamepads\r\n         */\r\n        gamepadManager: GamepadManager;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"gamepadManager\", {\r\n    get: function (this: Scene) {\r\n        if (!this._gamepadManager) {\r\n            this._gamepadManager = new GamepadManager(this);\r\n            let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD) as GamepadSystemSceneComponent;\r\n            if (!component) {\r\n                component = new GamepadSystemSceneComponent(this);\r\n                this._addComponent(component);\r\n            }\r\n        }\r\n\r\n        return this._gamepadManager;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../Cameras/freeCameraInputsManager\" {\r\n    /**\r\n     * Interface representing a free camera inputs manager\r\n     */\r\n    export interface FreeCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the FreeCameraInputsManager.\r\n         * @returns the FreeCameraInputsManager\r\n         */\r\n        addGamepad(): FreeCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the free camera inputs manager\r\n * @returns the FreeCameraInputsManager\r\n */\r\nFreeCameraInputsManager.prototype.addGamepad = function (): FreeCameraInputsManager {\r\n    this.add(new FreeCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\ndeclare module \"../Cameras/arcRotateCameraInputsManager\" {\r\n    /**\r\n     * Interface representing an arc rotate camera inputs manager\r\n     */\r\n    export interface ArcRotateCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the ArcRotateCamera InputManager.\r\n         * @returns the camera inputs manager\r\n         */\r\n        addGamepad(): ArcRotateCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the arc rotate camera inputs manager\r\n * @returns the camera inputs manager\r\n */\r\nArcRotateCameraInputsManager.prototype.addGamepad = function (): ArcRotateCameraInputsManager {\r\n    this.add(new ArcRotateCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the gamepad scene component responsible to manage gamepads in a given scene\r\n */\r\nexport class GamepadSystemSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_GAMEPAD;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for gamepads\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n        if (gamepadManager) {\r\n            gamepadManager.dispose();\r\n            this.scene._gamepadManager = null;\r\n        }\r\n    }\r\n\r\n    private _beforeCameraUpdate(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n\r\n        if (gamepadManager && gamepadManager._isMonitoring) {\r\n            gamepadManager._checkGamepadsStatus();\r\n        }\r\n    }\r\n}\r\n", "import { TouchCamera } from \"./touchCamera\";\r\nimport { Node } from \"../node\";\r\nimport type { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"./camera\";\r\n\r\nimport \"../Gamepads/gamepadSceneComponent\";\r\n\r\nNode.AddNodeConstructor(\"FreeCamera\", (name, scene) => {\r\n    // Forcing to use the Universal camera\r\n    return () => new UniversalCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n * which still works and will still be found in many Playgrounds.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class UniversalCamera extends TouchCamera {\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadAngularSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadAngularSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadMoveSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadMoveSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n     * which still works and will still be found in many Playgrounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addGamepad();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"UniversalCamera\";\r\n    }\r\n}\r\n\r\nCamera._CreateDefaultParsedCamera = (name: string, scene: Scene) => {\r\n    return new UniversalCamera(name, Vector3.Zero(), scene);\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { UniversalCamera } from \"../Cameras/universalCamera\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Options for setting up XR spectator camera.\r\n */\r\nexport interface WebXRSpectatorModeOption {\r\n    /**\r\n     * Expected refresh rate (frames per sec) for a spectator camera.\r\n     */\r\n    fps?: number;\r\n    /**\r\n     * The index of rigCameras array in a WebXR camera.\r\n     */\r\n    preferredCameraIndex?: number;\r\n}\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _attachedToElement: boolean = false;\r\n    private _spectatorCamera: Nullable<UniversalCamera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n    private _spectatorMode = false;\r\n    private _lastTimestamp = 0;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param _scene The scene the helper should be created in\r\n     */\r\n    private constructor(private _scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(_scene);\r\n        this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        _scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        const helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.exitXRAsync();\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        this._spectatorCamera?.dispose();\r\n        if (this._nonVRCamera) {\r\n            this._scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public async enterXRAsync(\r\n        sessionMode: XRSessionMode,\r\n        referenceSpaceType: XRReferenceSpaceType,\r\n        renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(),\r\n        sessionCreationOptions: XRSessionInit = {}\r\n    ): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        try {\r\n            await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\r\n            await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.camera.maxZ || 10000,\r\n                depthNear: this.camera.minZ,\r\n            };\r\n\r\n            // The layers feature will have already initialized the xr session's layers on session init.\r\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\r\n                const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n                xrRenderState.baseLayer = baseLayer;\r\n            }\r\n\r\n            this.sessionManager.updateRenderState(xrRenderState);\r\n            // run the render loop\r\n            this.sessionManager.runXRRenderLoop();\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this._scene.autoClear;\r\n            this._nonVRCamera = this._scene.activeCamera;\r\n            this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;\r\n            this._nonVRCamera?.detachControl();\r\n\r\n            this._scene.activeCamera = this.camera;\r\n            // do not compensate when AR session is used\r\n            if (sessionMode !== \"immersive-ar\") {\r\n                this._nonXRToXRCamera();\r\n            } else {\r\n                // Kept here, TODO - check if needed\r\n                this._scene.autoClear = false;\r\n                this.camera.compensateOnFirstFrame = false;\r\n                // reset the camera's position to the origin\r\n                this.camera.position.set(0, 0, 0);\r\n                this.camera.rotationQuaternion.set(0, 0, 0, 1);\r\n                this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n            }\r\n\r\n            this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\r\n                if (this.state !== WebXRState.EXITING_XR) {\r\n                    this._setState(WebXRState.EXITING_XR);\r\n                }\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                this.camera.rigCameras.forEach((c) => {\r\n                    c.outputRenderTarget = null;\r\n                });\r\n\r\n                // Restore scene settings\r\n                this._scene.autoClear = this._originalSceneAutoClear;\r\n                this._scene.activeCamera = this._nonVRCamera;\r\n                if (this._attachedToElement && this._nonVRCamera) {\r\n                    this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\r\n                }\r\n                if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                    if ((<any>this._nonVRCamera).setPosition) {\r\n                        (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                    } else {\r\n                        this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                    }\r\n                }\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n\r\n            // Wait until the first frame arrives before setting state to in xr\r\n            this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                this._setState(WebXRState.IN_XR);\r\n            });\r\n            return this.sessionManager;\r\n        } catch (e) {\r\n            Logger.Log(e);\r\n            Logger.Log(e.message);\r\n            this._setState(WebXRState.NOT_IN_XR);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enable spectator mode for desktop VR experiences.\r\n     * When spectator mode is enabled a camera will be attached to the desktop canvas and will\r\n     * display the first rig camera's view on the desktop canvas.\r\n     * Please note that this will degrade performance, as it requires another camera render.\r\n     * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\r\n     * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\r\n     */\r\n    public enableSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        if (!this._spectatorMode) {\r\n            this._spectatorMode = true;\r\n            this._switchSpectatorMode(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable spectator mode for desktop VR experiences.\r\n     */\r\n    public disableSpecatatorMode(): void {\r\n        if (this._spectatorMode) {\r\n            this._spectatorMode = false;\r\n            this._switchSpectatorMode();\r\n        }\r\n    }\r\n\r\n    private _switchSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        const fps = options?.fps ? options.fps : 1000.0;\r\n        const refreshRate = (1.0 / fps) * 1000.0;\r\n        const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;\r\n\r\n        const updateSpectatorCamera = () => {\r\n            if (this._spectatorCamera) {\r\n                const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\r\n                if (delta >= refreshRate) {\r\n                    this._lastTimestamp = this.sessionManager.currentTimestamp;\r\n                    this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\r\n                    this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\r\n                }\r\n            }\r\n        };\r\n        if (this._spectatorMode) {\r\n            if (cameraIndex >= this.camera.rigCameras.length) {\r\n                throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\r\n            }\r\n            const onStateChanged = () => {\r\n                if (this.state === WebXRState.IN_XR) {\r\n                    this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\r\n                    this._spectatorCamera.rotationQuaternion = new Quaternion();\r\n                    this._scene.activeCameras = [this.camera, this._spectatorCamera];\r\n                    this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\r\n                    this._scene.onAfterRenderCameraObservable.add((camera) => {\r\n                        if (camera === this.camera) {\r\n                            // reset the dimensions object for correct resizing\r\n                            this._scene.getEngine().framebufferDimensionsObject = null;\r\n                        }\r\n                    });\r\n                } else if (this.state === WebXRState.EXITING_XR) {\r\n                    this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n                    this._scene.activeCameras = null;\r\n                }\r\n            };\r\n            this.onStateChangedObservable.add(onStateChanged);\r\n            onStateChanged();\r\n        } else {\r\n            this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n            this._scene.activeCameras = [this.camera];\r\n        }\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n", "import type { IMinimalMotionControllerObject, MotionControllerComponentType } from \"./webXRAbstractMotionController\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { IDisposable } from \"../../scene\";\r\n\r\n/**\r\n * X-Y values for axes in WebXR\r\n */\r\nexport interface IWebXRMotionControllerAxesValue {\r\n    /**\r\n     * The value of the x axis\r\n     */\r\n    x: number;\r\n    /**\r\n     * The value of the y-axis\r\n     */\r\n    y: number;\r\n}\r\n\r\n/**\r\n * changed / previous values for the values of this component\r\n */\r\nexport interface IWebXRMotionControllerComponentChangesValues<T> {\r\n    /**\r\n     * current (this frame) value\r\n     */\r\n    current: T;\r\n    /**\r\n     * previous (last change) value\r\n     */\r\n    previous: T;\r\n}\r\n\r\n/**\r\n * Represents changes in the component between current frame and last values recorded\r\n */\r\nexport interface IWebXRMotionControllerComponentChanges {\r\n    /**\r\n     * will be populated with previous and current values if axes changed\r\n     */\r\n    axes?: IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue>;\r\n    /**\r\n     * will be populated with previous and current values if pressed changed\r\n     */\r\n    pressed?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if touched changed\r\n     */\r\n    touched?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if value changed\r\n     */\r\n    value?: IWebXRMotionControllerComponentChangesValues<number>;\r\n}\r\n/**\r\n * This class represents a single component (for example button or thumbstick) of a motion controller\r\n */\r\nexport class WebXRControllerComponent implements IDisposable {\r\n    private _axes: IWebXRMotionControllerAxesValue = {\r\n        x: 0,\r\n        y: 0,\r\n    };\r\n    private _changes: IWebXRMotionControllerComponentChanges = {};\r\n    private _currentValue: number = 0;\r\n    private _hasChanges: boolean = false;\r\n    private _pressed: boolean = false;\r\n    private _touched: boolean = false;\r\n\r\n    /**\r\n     * button component type\r\n     */\r\n    public static BUTTON_TYPE: MotionControllerComponentType = \"button\";\r\n    /**\r\n     * squeeze component type\r\n     */\r\n    public static SQUEEZE_TYPE: MotionControllerComponentType = \"squeeze\";\r\n    /**\r\n     * Thumbstick component type\r\n     */\r\n    public static THUMBSTICK_TYPE: MotionControllerComponentType = \"thumbstick\";\r\n    /**\r\n     * Touchpad component type\r\n     */\r\n    public static TOUCHPAD_TYPE: MotionControllerComponentType = \"touchpad\";\r\n    /**\r\n     * trigger component type\r\n     */\r\n    public static TRIGGER_TYPE: MotionControllerComponentType = \"trigger\";\r\n\r\n    /**\r\n     * If axes are available for this component (like a touchpad or thumbstick) the observers will be notified when\r\n     * the axes data changes\r\n     */\r\n    public onAxisValueChangedObservable: Observable<{ x: number; y: number }> = new Observable();\r\n    /**\r\n     * Observers registered here will be triggered when the state of a button changes\r\n     * State change is either pressed / touched / value\r\n     */\r\n    public onButtonStateChangedObservable: Observable<WebXRControllerComponent> = new Observable();\r\n\r\n    /**\r\n     * Creates a new component for a motion controller.\r\n     * It is created by the motion controller itself\r\n     *\r\n     * @param id the id of this component\r\n     * @param type the type of the component\r\n     * @param _buttonIndex index in the buttons array of the gamepad\r\n     * @param _axesIndices indices of the values in the axes array of the gamepad\r\n     */\r\n    constructor(\r\n        /**\r\n         * the id of this component\r\n         */\r\n        public id: string,\r\n        /**\r\n         * the type of the component\r\n         */\r\n        public type: MotionControllerComponentType,\r\n        private _buttonIndex: number = -1,\r\n        private _axesIndices: number[] = []\r\n    ) {}\r\n\r\n    /**\r\n     * The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }\r\n     */\r\n    public get axes(): IWebXRMotionControllerAxesValue {\r\n        return this._axes;\r\n    }\r\n\r\n    /**\r\n     * Get the changes. Elements will be populated only if they changed with their previous and current value\r\n     */\r\n    public get changes(): IWebXRMotionControllerComponentChanges {\r\n        return this._changes;\r\n    }\r\n\r\n    /**\r\n     * Return whether or not the component changed the last frame\r\n     */\r\n    public get hasChanges(): boolean {\r\n        return this._hasChanges;\r\n    }\r\n\r\n    /**\r\n     * is the button currently pressed\r\n     */\r\n    public get pressed(): boolean {\r\n        return this._pressed;\r\n    }\r\n\r\n    /**\r\n     * is the button currently touched\r\n     */\r\n    public get touched(): boolean {\r\n        return this._touched;\r\n    }\r\n\r\n    /**\r\n     * Get the current value of this component\r\n     */\r\n    public get value(): number {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Dispose this component\r\n     */\r\n    public dispose(): void {\r\n        this.onAxisValueChangedObservable.clear();\r\n        this.onButtonStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Are there axes correlating to this component\r\n     * @returns true is axes data is available\r\n     */\r\n    public isAxes(): boolean {\r\n        return this._axesIndices.length !== 0;\r\n    }\r\n\r\n    /**\r\n     * Is this component a button (hence - pressable)\r\n     * @returns true if can be pressed\r\n     */\r\n    public isButton(): boolean {\r\n        return this._buttonIndex !== -1;\r\n    }\r\n\r\n    /**\r\n     * update this component using the gamepad object it is in. Called on every frame\r\n     * @param nativeController the native gamepad controller object\r\n     */\r\n    public update(nativeController: IMinimalMotionControllerObject) {\r\n        let buttonUpdated = false;\r\n        let axesUpdate = false;\r\n        this._hasChanges = false;\r\n        this._changes = {};\r\n\r\n        if (this.isButton()) {\r\n            const button = nativeController.buttons[this._buttonIndex];\r\n            // defensive, in case a profile was forced\r\n            if (!button) {\r\n                return;\r\n            }\r\n            if (this._currentValue !== button.value) {\r\n                this.changes.value = {\r\n                    current: button.value,\r\n                    previous: this._currentValue,\r\n                };\r\n                buttonUpdated = true;\r\n                this._currentValue = button.value;\r\n            }\r\n            if (this._touched !== button.touched) {\r\n                this.changes.touched = {\r\n                    current: button.touched,\r\n                    previous: this._touched,\r\n                };\r\n                buttonUpdated = true;\r\n                this._touched = button.touched;\r\n            }\r\n            if (this._pressed !== button.pressed) {\r\n                this.changes.pressed = {\r\n                    current: button.pressed,\r\n                    previous: this._pressed,\r\n                };\r\n                buttonUpdated = true;\r\n                this._pressed = button.pressed;\r\n            }\r\n        }\r\n\r\n        if (this.isAxes()) {\r\n            if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {\r\n                this.changes.axes = {\r\n                    current: {\r\n                        x: nativeController.axes[this._axesIndices[0]],\r\n                        y: this._axes.y,\r\n                    },\r\n                    previous: {\r\n                        x: this._axes.x,\r\n                        y: this._axes.y,\r\n                    },\r\n                };\r\n                this._axes.x = nativeController.axes[this._axesIndices[0]];\r\n                axesUpdate = true;\r\n            }\r\n\r\n            if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {\r\n                if (this.changes.axes) {\r\n                    this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];\r\n                } else {\r\n                    this.changes.axes = {\r\n                        current: {\r\n                            x: this._axes.x,\r\n                            y: nativeController.axes[this._axesIndices[1]],\r\n                        },\r\n                        previous: {\r\n                            x: this._axes.x,\r\n                            y: this._axes.y,\r\n                        },\r\n                    };\r\n                }\r\n                this._axes.y = nativeController.axes[this._axesIndices[1]];\r\n                axesUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (buttonUpdated) {\r\n            this._hasChanges = true;\r\n            this.onButtonStateChangedObservable.notifyObservers(this);\r\n        }\r\n        if (axesUpdate) {\r\n            this._hasChanges = true;\r\n            this.onAxisValueChangedObservable.notifyObservers(this._axes);\r\n        }\r\n    }\r\n}\r\n", "import type { IDisposable, Scene } from \"../../scene\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\n\r\n/**\r\n * Handedness type in xrInput profiles. These can be used to define layouts in the Layout Map.\r\n */\r\nexport type MotionControllerHandedness = \"none\" | \"left\" | \"right\";\r\n/**\r\n * The type of components available in motion controllers.\r\n * This is not the name of the component.\r\n */\r\nexport type MotionControllerComponentType = \"trigger\" | \"squeeze\" | \"touchpad\" | \"thumbstick\" | \"button\";\r\n\r\n/**\r\n * The state of a controller component\r\n */\r\nexport type MotionControllerComponentStateType = \"default\" | \"touched\" | \"pressed\";\r\n\r\n/**\r\n * The schema of motion controller layout.\r\n * No object will be initialized using this interface\r\n * This is used just to define the profile.\r\n */\r\nexport interface IMotionControllerLayout {\r\n    /**\r\n     * Path to load the assets. Usually relative to the base path\r\n     */\r\n    assetPath: string;\r\n    /**\r\n     * Available components (unsorted)\r\n     */\r\n    components: {\r\n        /**\r\n         * A map of component Ids\r\n         */\r\n        [componentId: string]: {\r\n            /**\r\n             * The type of input the component outputs\r\n             */\r\n            type: MotionControllerComponentType;\r\n            /**\r\n             * The indices of this component in the gamepad object\r\n             */\r\n            gamepadIndices: {\r\n                /**\r\n                 * Index of button\r\n                 */\r\n                button?: number;\r\n                /**\r\n                 * If available, index of x-axis\r\n                 */\r\n                xAxis?: number;\r\n                /**\r\n                 * If available, index of y-axis\r\n                 */\r\n                yAxis?: number;\r\n            };\r\n            /**\r\n             * The mesh's root node name\r\n             */\r\n            rootNodeName: string;\r\n            /**\r\n             * Animation definitions for this model\r\n             */\r\n            visualResponses: {\r\n                [stateKey: string]: {\r\n                    /**\r\n                     * What property will be animated\r\n                     */\r\n                    componentProperty: \"xAxis\" | \"yAxis\" | \"button\" | \"state\";\r\n                    /**\r\n                     * What states influence this visual response\r\n                     */\r\n                    states: MotionControllerComponentStateType[];\r\n                    /**\r\n                     * Type of animation - movement or visibility\r\n                     */\r\n                    valueNodeProperty: \"transform\" | \"visibility\";\r\n                    /**\r\n                     * Base node name to move. Its position will be calculated according to the min and max nodes\r\n                     */\r\n                    valueNodeName?: string;\r\n                    /**\r\n                     * Minimum movement node\r\n                     */\r\n                    minNodeName?: string;\r\n                    /**\r\n                     * Max movement node\r\n                     */\r\n                    maxNodeName?: string;\r\n                };\r\n            };\r\n            /**\r\n             * If touch enabled, what is the name of node to display user feedback\r\n             */\r\n            touchPointNodeName?: string;\r\n        };\r\n    };\r\n    /**\r\n     * Is it xr standard mapping or not\r\n     */\r\n    gamepadMapping: \"\" | \"xr-standard\";\r\n    /**\r\n     * Base root node of this entire model\r\n     */\r\n    rootNodeName: string;\r\n    /**\r\n     * Defines the main button component id\r\n     */\r\n    selectComponentId: string;\r\n}\r\n\r\n/**\r\n * A definition for the layout map in the input profile\r\n */\r\nexport interface IMotionControllerLayoutMap {\r\n    /**\r\n     * Layouts with handedness type as a key\r\n     */\r\n    [handedness: string /* handedness */]: IMotionControllerLayout;\r\n}\r\n\r\n/**\r\n * The XR Input profile schema\r\n * Profiles can be found here:\r\n * https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/registry/profiles\r\n */\r\nexport interface IMotionControllerProfile {\r\n    /**\r\n     * fallback profiles for this profileId\r\n     */\r\n    fallbackProfileIds: string[];\r\n    /**\r\n     * The layout map, with handedness as key\r\n     */\r\n    layouts: IMotionControllerLayoutMap;\r\n    /**\r\n     * The id of this profile\r\n     * correlates to the profile(s) in the xrInput.profiles array\r\n     */\r\n    profileId: string;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller button animation\r\n * The meshes are provided to the _lerpButtonTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerButtonMeshMap {\r\n    /**\r\n     * the mesh that defines the pressed value mesh position.\r\n     * This is used to find the max-position of this button\r\n     */\r\n    pressedMesh: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the unpressed value mesh position.\r\n     * This is used to find the min (or initial) position of this button\r\n     */\r\n    unpressedMesh: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when value changes\r\n     */\r\n    valueMesh: AbstractMesh;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller axis animation.\r\n * This will be expanded when touchpad animations are fully supported\r\n * The meshes are provided to the _lerpAxisTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerMeshMap {\r\n    /**\r\n     * the mesh that defines the maximum value mesh position.\r\n     */\r\n    maxMesh?: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the minimum value mesh position.\r\n     */\r\n    minMesh?: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when axis value changes\r\n     */\r\n    valueMesh?: AbstractMesh;\r\n}\r\n\r\n/**\r\n * The elements needed for change-detection of the gamepad objects in motion controllers\r\n */\r\nexport interface IMinimalMotionControllerObject {\r\n    /**\r\n     * Available axes of this controller\r\n     */\r\n    axes: number[];\r\n    /**\r\n     * An array of available buttons\r\n     */\r\n    buttons: Array<{\r\n        /**\r\n         * Value of the button/trigger\r\n         */\r\n        value: number;\r\n        /**\r\n         * If the button/trigger is currently touched\r\n         */\r\n        touched: boolean;\r\n        /**\r\n         * If the button/trigger is currently pressed\r\n         */\r\n        pressed: boolean;\r\n    }>;\r\n\r\n    /**\r\n     * EXPERIMENTAL haptic support.\r\n     */\r\n    hapticActuators?: Array<{\r\n        pulse: (value: number, duration: number) => Promise<boolean>;\r\n    }>;\r\n}\r\n\r\n/**\r\n * An Abstract Motion controller\r\n * This class receives an xrInput and a profile layout and uses those to initialize the components\r\n * Each component has an observable to check for changes in value and state\r\n */\r\nexport abstract class WebXRAbstractMotionController implements IDisposable {\r\n    private _initComponent = (id: string) => {\r\n        if (!id) {\r\n            return;\r\n        }\r\n        const componentDef = this.layout.components[id];\r\n        const type = componentDef.type;\r\n        const buttonIndex = componentDef.gamepadIndices.button;\r\n        // search for axes\r\n        const axes: number[] = [];\r\n        if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {\r\n            axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);\r\n        }\r\n\r\n        this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);\r\n    };\r\n\r\n    private _modelReady: boolean = false;\r\n\r\n    /**\r\n     * A map of components (WebXRControllerComponent) in this motion controller\r\n     * Components have a ComponentType and can also have both button and axis definitions\r\n     */\r\n    public readonly components: {\r\n        [id: string]: WebXRControllerComponent;\r\n    } = {};\r\n\r\n    /**\r\n     * Disable the model's animation. Can be set at any time.\r\n     */\r\n    public disableAnimation: boolean = false;\r\n    /**\r\n     * Observers registered here will be triggered when the model of this controller is done loading\r\n     */\r\n    public onModelLoadedObservable: Observable<WebXRAbstractMotionController> = new Observable();\r\n    /**\r\n     * The profile id of this motion controller\r\n     */\r\n    public abstract profileId: string;\r\n    /**\r\n     * The root mesh of the model. It is null if the model was not yet initialized\r\n     */\r\n    public rootMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * constructs a new abstract motion controller\r\n     * @param scene the scene to which the model of the controller will be added\r\n     * @param layout The profile layout to load\r\n     * @param gamepadObject The gamepad object correlating to this controller\r\n     * @param handedness handedness (left/right/none) of this controller\r\n     * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading\r\n     * @param _controllerCache a cache holding controller models already loaded in this session\r\n     */\r\n    constructor(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected layout: IMotionControllerLayout,\r\n        /**\r\n         * The gamepad object correlating to this controller\r\n         */\r\n        public gamepadObject: IMinimalMotionControllerObject,\r\n        /**\r\n         * handedness (left/right/none) of this controller\r\n         */\r\n        public handedness: MotionControllerHandedness,\r\n        /**\r\n         * @internal\r\n         */\r\n        public _doNotLoadControllerMesh: boolean = false,\r\n        private _controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        // initialize the components\r\n        if (layout.components) {\r\n            Object.keys(layout.components).forEach(this._initComponent);\r\n        }\r\n        // Model is loaded in WebXRInput\r\n    }\r\n\r\n    /**\r\n     * Dispose this controller, the model mesh and all its components\r\n     */\r\n    public dispose(): void {\r\n        this.getComponentIds().forEach((id) => this.getComponent(id).dispose());\r\n        if (this.rootMesh) {\r\n            this.rootMesh.getChildren(undefined, true).forEach((node) => {\r\n                node.setEnabled(false);\r\n            });\r\n            this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns all components of specific type\r\n     * @param type the type to search for\r\n     * @returns an array of components with this type\r\n     */\r\n    public getAllComponentsOfType(type: MotionControllerComponentType): WebXRControllerComponent[] {\r\n        return this.getComponentIds()\r\n            .map((id) => this.components[id])\r\n            .filter((component) => component.type === type);\r\n    }\r\n\r\n    /**\r\n     * get a component based an its component id as defined in layout.components\r\n     * @param id the id of the component\r\n     * @returns the component correlates to the id or undefined if not found\r\n     */\r\n    public getComponent(id: string): WebXRControllerComponent {\r\n        return this.components[id];\r\n    }\r\n\r\n    /**\r\n     * Get the list of components available in this motion controller\r\n     * @returns an array of strings correlating to available components\r\n     */\r\n    public getComponentIds(): string[] {\r\n        return Object.keys(this.components);\r\n    }\r\n\r\n    /**\r\n     * Get the first component of specific type\r\n     * @param type type of component to find\r\n     * @returns a controller component or null if not found\r\n     */\r\n    public getComponentOfType(type: MotionControllerComponentType): Nullable<WebXRControllerComponent> {\r\n        return this.getAllComponentsOfType(type)[0] || null;\r\n    }\r\n\r\n    /**\r\n     * Get the main (Select) component of this controller as defined in the layout\r\n     * @returns the main component of this controller\r\n     */\r\n    public getMainComponent(): WebXRControllerComponent {\r\n        return this.getComponent(this.layout.selectComponentId);\r\n    }\r\n\r\n    /**\r\n     * Loads the model correlating to this controller\r\n     * When the mesh is loaded, the onModelLoadedObservable will be triggered\r\n     * @returns A promise fulfilled with the result of the model loading\r\n     */\r\n    public async loadModel(): Promise<boolean> {\r\n        const useGeneric = !this._getModelLoadingConstraints();\r\n        let loadingParams = this._getGenericFilenameAndPath();\r\n        // Checking if GLB loader is present\r\n        if (useGeneric) {\r\n            Logger.Warn(\"Falling back to generic models\");\r\n        } else {\r\n            loadingParams = this._getFilenameAndPath();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const meshesLoaded = (meshes: AbstractMesh[]) => {\r\n                if (useGeneric) {\r\n                    this._getGenericParentMesh(meshes);\r\n                } else {\r\n                    this._setRootMesh(meshes);\r\n                }\r\n                this._processLoadedModel(meshes);\r\n                this._modelReady = true;\r\n                this.onModelLoadedObservable.notifyObservers(this);\r\n                resolve(true);\r\n            };\r\n            if (this._controllerCache) {\r\n                // look for it in the cache\r\n                const found = this._controllerCache.filter((c) => {\r\n                    return c.filename === loadingParams.filename && c.path === loadingParams.path;\r\n                });\r\n                if (found[0]) {\r\n                    found[0].meshes.forEach((mesh) => mesh.setEnabled(true));\r\n                    meshesLoaded(found[0].meshes);\r\n                    return;\r\n                    // found, don't continue to load\r\n                }\r\n            }\r\n            SceneLoader.ImportMesh(\r\n                \"\",\r\n                loadingParams.path,\r\n                loadingParams.filename,\r\n                this.scene,\r\n                (meshes) => {\r\n                    if (this._controllerCache) {\r\n                        this._controllerCache.push({\r\n                            ...loadingParams,\r\n                            meshes,\r\n                        });\r\n                    }\r\n                    meshesLoaded(meshes);\r\n                },\r\n                null,\r\n                (_scene: Scene, message: string) => {\r\n                    Logger.Log(message);\r\n                    Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);\r\n                    reject(message);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update this model using the current XRFrame\r\n     * @param xrFrame the current xr frame to use and update the model\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame): void {\r\n        this.getComponentIds().forEach((id) => this.getComponent(id).update(this.gamepadObject));\r\n        this.updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Backwards compatibility due to a deeply-integrated typo\r\n     */\r\n    public get handness() {\r\n        return this.handedness;\r\n    }\r\n\r\n    /**\r\n     * Pulse (vibrate) this controller\r\n     * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called\r\n     * Consecutive calls to this function will cancel the last pulse call\r\n     *\r\n     * @param value the strength of the pulse in 0.0...1.0 range\r\n     * @param duration Duration of the pulse in milliseconds\r\n     * @param hapticActuatorIndex optional index of actuator (will usually be 0)\r\n     * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued\r\n     */\r\n    public pulse(value: number, duration: number, hapticActuatorIndex: number = 0): Promise<boolean> {\r\n        if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {\r\n            return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);\r\n        } else {\r\n            return Promise.resolve(false);\r\n        }\r\n    }\r\n\r\n    // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n    protected _getChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name === name, false)[0];\r\n    }\r\n\r\n    // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n    protected _getImmediateChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name == name, true)[0];\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axisMap\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @internal\r\n     */\r\n    protected _lerpTransform(axisMap: IMotionControllerMeshMap, axisValue: number, fixValueCoordinates?: boolean): void {\r\n        if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {\r\n            return;\r\n        }\r\n\r\n        if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;\r\n        Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);\r\n        Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);\r\n    }\r\n\r\n    /**\r\n     * Update the model itself with the current frame data\r\n     * @param xrFrame the frame to use for updating the model mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected updateModel(xrFrame: XRFrame): void {\r\n        if (!this._modelReady) {\r\n            return;\r\n        }\r\n        this._updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Get the filename and path for this controller's model\r\n     * @returns a map of filename and path\r\n     */\r\n    protected abstract _getFilenameAndPath(): { filename: string; path: string };\r\n    /**\r\n     * This function is called before the mesh is loaded. It checks for loading constraints.\r\n     * For example, this function can check if the GLB loader is available\r\n     * If this function returns false, the generic controller will be loaded instead\r\n     * @returns Is the client ready to load the mesh\r\n     */\r\n    protected abstract _getModelLoadingConstraints(): boolean;\r\n    /**\r\n     * This function will be called after the model was successfully loaded and can be used\r\n     * for mesh transformations before it is available for the user\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _processLoadedModel(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * Set the root mesh for this controller. Important for the WebXR controller class\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _setRootMesh(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * A function executed each frame that updates the mesh (if needed)\r\n     * @param xrFrame the current xrFrame\r\n     */\r\n    protected abstract _updateModel(xrFrame: XRFrame): void;\r\n\r\n    private _getGenericFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    private _getGenericParentMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            if (!mesh.parent) {\r\n                mesh.isPickable = false;\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        });\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n}\r\n", "import type { IMinimalMotionControllerObject, MotionControllerHandedness, IMotionControllerLayoutMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\n\r\n/**\r\n * A generic trigger-only motion controller for WebXR\r\n */\r\nexport class WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {\r\n    /**\r\n     * Static version of the profile id of this controller\r\n     */\r\n    public static ProfileId = \"generic-trigger\";\r\n\r\n    public profileId = WebXRGenericTriggerMotionController.ProfileId;\r\n\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        super(scene, GenericTriggerLayout[handedness], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _processLoadedModel(meshes: AbstractMesh[]): void {\r\n        // nothing to do\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            mesh.isPickable = false;\r\n            if (!mesh.parent) {\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        });\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op\r\n    }\r\n}\r\n\r\n// https://github.com/immersive-web/webxr-input-profiles/blob/master/packages/registry/profiles/generic/generic-trigger-touchpad-thumbstick.json\r\nconst GenericTriggerLayout: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n    none: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n", "import type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { IMotionControllerProfile, IMotionControllerMeshMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Axis, Space } from \"../../Maths/math.axis\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\n/**\r\n * A profiled motion controller has its profile loaded from an online repository.\r\n * The class is responsible of loading the model, mapping the keys and enabling model-animations\r\n */\r\nexport class WebXRProfiledMotionController extends WebXRAbstractMotionController {\r\n    private _buttonMeshMapping: {\r\n        [buttonName: string]: {\r\n            mainMesh?: AbstractMesh;\r\n            states: {\r\n                [state: string]: IMotionControllerMeshMap;\r\n            };\r\n        };\r\n    } = {};\r\n    private _touchDots: { [visKey: string]: AbstractMesh } = {};\r\n\r\n    /**\r\n     * The profile ID of this controller. Will be populated when the controller initializes.\r\n     */\r\n    public profileId: string;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        xrInput: XRInputSource,\r\n        _profile: IMotionControllerProfile,\r\n        private _repositoryUrl: string,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        private controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        super(scene, _profile.layouts[xrInput.handedness || \"none\"], xrInput.gamepad as any, xrInput.handedness, undefined, controllerCache);\r\n        this.profileId = _profile.profileId;\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        if (!this.controllerCache) {\r\n            Object.keys(this._touchDots).forEach((visResKey) => {\r\n                this._touchDots[visResKey].dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: this.layout.assetPath,\r\n            path: `${this._repositoryUrl}/profiles/${this.profileId}/`,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(\".glb\");\r\n        if (!glbLoaded) {\r\n            Logger.Warn(\"glTF / glb loader was not registered, using generic controller instead\");\r\n        }\r\n        return glbLoaded;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        this.getComponentIds().forEach((type) => {\r\n            const componentInLayout = this.layout.components[type];\r\n            this._buttonMeshMapping[type] = {\r\n                mainMesh: this._getChildByName(this.rootMesh!, componentInLayout.rootNodeName),\r\n                states: {},\r\n            };\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, visResponse.valueNodeName!),\r\n                        minMesh: this._getChildByName(this.rootMesh!, visResponse.minNodeName!),\r\n                        maxMesh: this._getChildByName(this.rootMesh!, visResponse.maxNodeName!),\r\n                    };\r\n                } else {\r\n                    // visibility, usually for touchpads\r\n                    const nameOfMesh =\r\n                        componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName\r\n                            ? componentInLayout.touchPointNodeName\r\n                            : visResponse.valueNodeName!;\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, nameOfMesh),\r\n                    };\r\n                    if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {\r\n                        const dot = CreateSphere(\r\n                            visualResponseKey + \"dot\",\r\n                            {\r\n                                diameter: 0.0015,\r\n                                segments: 8,\r\n                            },\r\n                            this.scene\r\n                        );\r\n                        dot.material = new StandardMaterial(visualResponseKey + \"mat\", this.scene);\r\n                        (<StandardMaterial>dot.material).diffuseColor = Color3.Red();\r\n                        dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;\r\n                        dot.isVisible = false;\r\n                        this._touchDots[visualResponseKey] = dot;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \"-\" + this.handedness, this.scene);\r\n        this.rootMesh.isPickable = false;\r\n        let rootMesh;\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            mesh.isPickable = false;\r\n\r\n            if (!mesh.parent) {\r\n                // Handle root node, attach to the new parentMesh\r\n                rootMesh = mesh;\r\n            }\r\n        }\r\n\r\n        if (rootMesh) {\r\n            rootMesh.setParent(this.rootMesh);\r\n        }\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);\r\n        }\r\n    }\r\n\r\n    protected _updateModel(_xrFrame: XRFrame): void {\r\n        if (this.disableAnimation) {\r\n            return;\r\n        }\r\n        this.getComponentIds().forEach((id) => {\r\n            const component = this.getComponent(id);\r\n            if (!component.hasChanges) {\r\n                return;\r\n            }\r\n            const meshes = this._buttonMeshMapping[id];\r\n            const componentInLayout = this.layout.components[id];\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                let value = component.value;\r\n                if (visResponse.componentProperty === \"xAxis\") {\r\n                    value = component.axes.x;\r\n                } else if (visResponse.componentProperty === \"yAxis\") {\r\n                    value = component.axes.y;\r\n                }\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== \"button\");\r\n                } else {\r\n                    // visibility\r\n                    const valueMesh = meshes.states[visualResponseKey].valueMesh;\r\n                    if (valueMesh) {\r\n                        valueMesh.isVisible = component.touched || component.pressed;\r\n                    }\r\n                    if (this._touchDots[visualResponseKey]) {\r\n                        this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n", "import type { WebXRAbstractMotionController, IMotionControllerProfile } from \"./webXRAbstractMotionController\";\r\nimport { WebXRGenericTriggerMotionController } from \"./webXRGenericMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { WebXRProfiledMotionController } from \"./webXRProfiledMotionController\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\n\r\n/**\r\n * A construction function type to create a new controller based on an xrInput object\r\n */\r\nexport type MotionControllerConstructor = (xrInput: XRInputSource, scene: Scene) => WebXRAbstractMotionController;\r\n\r\n/**\r\n * The MotionController Manager manages all registered motion controllers and loads the right one when needed.\r\n *\r\n * When this repository is complete: https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets\r\n * it should be replaced with auto-loaded controllers.\r\n *\r\n * When using a model try to stay as generic as possible. Eventually there will be no need in any of the controller classes\r\n */\r\n\r\nconst controllerCache: Array<{\r\n    filename: string;\r\n    path: string;\r\n    meshes: AbstractMesh[];\r\n}> = [];\r\n\r\n/**\r\n * Motion controller manager is managing the different webxr profiles and makes sure the right\r\n * controller is being loaded.\r\n */\r\nexport class WebXRMotionControllerManager {\r\n    private static _AvailableControllers: { [type: string]: MotionControllerConstructor } = {};\r\n    private static _Fallbacks: { [profileId: string]: string[] } = {};\r\n    // cache for loading\r\n    private static _ProfileLoadingPromises: { [profileName: string]: Promise<IMotionControllerProfile> } = {};\r\n    private static _ProfilesList: Nullable<Promise<{ [profile: string]: string }>>;\r\n\r\n    /**\r\n     * The base URL of the online controller repository. Can be changed at any time.\r\n     */\r\n    public static BaseRepositoryUrl = \"https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist\";\r\n    /**\r\n     * Which repository gets priority - local or online\r\n     */\r\n    public static PrioritizeOnlineRepository: boolean = true;\r\n    /**\r\n     * Use the online repository, or use only locally-defined controllers\r\n     */\r\n    public static UseOnlineRepository: boolean = true;\r\n\r\n    /**\r\n     * Disable the controller cache and load the models each time a new WebXRProfileMotionController is loaded.\r\n     * Defaults to true.\r\n     */\r\n    public static DisableControllerCache: boolean = true;\r\n\r\n    /**\r\n     * Clear the cache used for profile loading and reload when requested again\r\n     */\r\n    public static ClearProfilesCache() {\r\n        this._ProfilesList = null;\r\n        this._ProfileLoadingPromises = {};\r\n    }\r\n\r\n    /**\r\n     * Register the default fallbacks.\r\n     * This function is called automatically when this file is imported.\r\n     */\r\n    public static DefaultFallbacks() {\r\n        this.RegisterFallbacksForProfileId(\"google-daydream\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive-focus\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"magicleap-one\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"windows-mixed-reality\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"microsoft-mixed-reality\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-go\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch-v2\", [\"oculus-touch\", \"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch\", [\"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-gearvr\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-odyssey\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"valve-index\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"generic-hand-select\", [\"generic-trigger\"]);\r\n    }\r\n\r\n    /**\r\n     * Find a fallback profile if the profile was not found. There are a few predefined generic profiles.\r\n     * @param profileId the profile to which a fallback needs to be found\r\n     * @returns an array with corresponding fallback profiles\r\n     */\r\n    public static FindFallbackWithProfileId(profileId: string): string[] {\r\n        const returnArray = this._Fallbacks[profileId] || [];\r\n\r\n        returnArray.unshift(profileId);\r\n        return returnArray;\r\n    }\r\n\r\n    /**\r\n     * When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.\r\n     * The order of search:\r\n     *\r\n     * 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller\r\n     * 2) (If not found) search in the gamepad id and try using it (legacy versions only)\r\n     * 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)\r\n     * 4) return the generic trigger controller if none were found\r\n     *\r\n     * @param xrInput the xrInput to which a new controller is initialized\r\n     * @param scene the scene to which the model will be added\r\n     * @param forceProfile force a certain profile for this controller\r\n     * @returns A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found\r\n     */\r\n    public static GetMotionControllerWithXRInput(xrInput: XRInputSource, scene: Scene, forceProfile?: string): Promise<WebXRAbstractMotionController> {\r\n        const profileArray: string[] = [];\r\n        if (forceProfile) {\r\n            profileArray.push(forceProfile);\r\n        }\r\n        profileArray.push(...(xrInput.profiles || []));\r\n\r\n        // emulator support\r\n        if (profileArray.length && !profileArray[0]) {\r\n            // remove the first \"undefined\" that the emulator is adding\r\n            profileArray.pop();\r\n        }\r\n\r\n        // legacy support - try using the gamepad id\r\n        if (xrInput.gamepad && xrInput.gamepad.id) {\r\n            switch (xrInput.gamepad.id) {\r\n                case xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : undefined:\r\n                    // oculus in gamepad id\r\n                    profileArray.push(\"oculus-touch-v2\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // make sure microsoft/windows mixed reality works correctly\r\n        const windowsMRIdx = profileArray.indexOf(\"windows-mixed-reality\");\r\n        if (windowsMRIdx !== -1) {\r\n            profileArray.splice(windowsMRIdx, 0, \"microsoft-mixed-reality\");\r\n        }\r\n\r\n        if (!profileArray.length) {\r\n            profileArray.push(\"generic-trigger\");\r\n        }\r\n\r\n        if (this.UseOnlineRepository) {\r\n            const firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepository : this._LoadProfilesFromAvailableControllers;\r\n            const secondFunction = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllers : this._LoadProfileFromRepository;\r\n\r\n            return firstFunction.call(this, profileArray, xrInput, scene).catch(() => {\r\n                return secondFunction.call(this, profileArray, xrInput, scene);\r\n            });\r\n        } else {\r\n            // use only available functions\r\n            return this._LoadProfilesFromAvailableControllers(profileArray, xrInput, scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a new controller based on its profile. This function will be called by the controller classes themselves.\r\n     *\r\n     * If you are missing a profile, make sure it is imported in your source, otherwise it will not register.\r\n     *\r\n     * @param type the profile type to register\r\n     * @param constructFunction the function to be called when loading this profile\r\n     */\r\n    public static RegisterController(type: string, constructFunction: MotionControllerConstructor) {\r\n        this._AvailableControllers[type] = constructFunction;\r\n    }\r\n\r\n    /**\r\n     * Register a fallback to a specific profile.\r\n     * @param profileId the profileId that will receive the fallbacks\r\n     * @param fallbacks A list of fallback profiles\r\n     */\r\n    public static RegisterFallbacksForProfileId(profileId: string, fallbacks: string[]): void {\r\n        if (this._Fallbacks[profileId]) {\r\n            this._Fallbacks[profileId].push(...fallbacks);\r\n        } else {\r\n            this._Fallbacks[profileId] = fallbacks;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will update the list of profiles available in the repository\r\n     * @returns a promise that resolves to a map of profiles available online\r\n     */\r\n    public static UpdateProfilesList() {\r\n        this._ProfilesList = Tools.LoadFileAsync(this.BaseRepositoryUrl + \"/profiles/profilesList.json\", false).then((data) => {\r\n            return JSON.parse(data);\r\n        });\r\n        return this._ProfilesList;\r\n    }\r\n\r\n    /**\r\n     * Clear the controller's cache (usually happens at the end of a session)\r\n     */\r\n    public static ClearControllerCache() {\r\n        controllerCache.forEach((cacheItem) => {\r\n            cacheItem.meshes.forEach((mesh) => {\r\n                mesh.dispose(false, true);\r\n            });\r\n        });\r\n        controllerCache.length = 0;\r\n    }\r\n\r\n    private static _LoadProfileFromRepository(profileArray: string[], xrInput: XRInputSource, scene: Scene): Promise<WebXRAbstractMotionController> {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n                if (!this._ProfilesList) {\r\n                    return this.UpdateProfilesList();\r\n                } else {\r\n                    return this._ProfilesList;\r\n                }\r\n            })\r\n            .then((profilesList: { [profile: string]: string }) => {\r\n                // load the right profile\r\n                for (let i = 0; i < profileArray.length; ++i) {\r\n                    // defensive\r\n                    if (!profileArray[i]) {\r\n                        continue;\r\n                    }\r\n                    if (profilesList[profileArray[i]]) {\r\n                        return profileArray[i];\r\n                    }\r\n                }\r\n\r\n                throw new Error(`neither controller ${profileArray[0]} nor all fallbacks were found in the repository,`);\r\n            })\r\n            .then((profileToLoad: string) => {\r\n                // load the profile\r\n                if (!this._ProfileLoadingPromises[profileToLoad]) {\r\n                    this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${profileToLoad}/profile.json`, false).then(\r\n                        (data) => <IMotionControllerProfile>JSON.parse(data)\r\n                    );\r\n                }\r\n                return this._ProfileLoadingPromises[profileToLoad];\r\n            })\r\n            .then((profile: IMotionControllerProfile) => {\r\n                return new WebXRProfiledMotionController(scene, xrInput, profile, this.BaseRepositoryUrl, this.DisableControllerCache ? undefined : controllerCache);\r\n            });\r\n    }\r\n\r\n    private static _LoadProfilesFromAvailableControllers(profileArray: string[], xrInput: XRInputSource, scene: Scene) {\r\n        // check fallbacks\r\n        for (let i = 0; i < profileArray.length; ++i) {\r\n            // defensive\r\n            if (!profileArray[i]) {\r\n                continue;\r\n            }\r\n            const fallbacks = this.FindFallbackWithProfileId(profileArray[i]);\r\n            for (let j = 0; j < fallbacks.length; ++j) {\r\n                const constructionFunction = this._AvailableControllers[fallbacks[j]];\r\n                if (constructionFunction) {\r\n                    return Promise.resolve(constructionFunction(xrInput, scene));\r\n                }\r\n            }\r\n        }\r\n\r\n        throw new Error(`no controller requested was found in the available controllers list`);\r\n    }\r\n}\r\n\r\n// register the generic profile(s) here so we will at least have them\r\nWebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRGenericTriggerMotionController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// register fallbacks\r\nWebXRMotionControllerManager.DefaultFallbacks();\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { WebXRAbstractMotionController } from \"./motionController/webXRAbstractMotionController\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\nlet idCount = 0;\r\n\r\n/**\r\n * Configuration options for the WebXR controller creation\r\n */\r\nexport interface IWebXRControllerOptions {\r\n    /**\r\n     * Should the controller mesh be animated when a user interacts with it\r\n     * The pressed buttons / thumbstick and touchpad animations will be disabled\r\n     */\r\n    disableMotionControllerAnimation?: boolean;\r\n    /**\r\n     * Do not load the controller mesh, in case a different mesh needs to be loaded.\r\n     */\r\n    doNotLoadControllerMesh?: boolean;\r\n    /**\r\n     * Force a specific controller type for this controller.\r\n     * This can be used when creating your own profile or when testing different controllers\r\n     */\r\n    forceControllerProfile?: string;\r\n    /**\r\n     * Defines a rendering group ID for meshes that will be loaded.\r\n     * This is for the default controllers only.\r\n     */\r\n    renderingGroupId?: number;\r\n}\r\n\r\n/**\r\n * Represents an XR controller\r\n */\r\nexport class WebXRInputSource {\r\n    private _tmpVector = new Vector3();\r\n    private _uniqueId: string;\r\n    private _disposed = false;\r\n\r\n    /**\r\n     * Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if that's the case only the pointer from the head will be available\r\n     */\r\n    public grip?: AbstractMesh;\r\n    /**\r\n     * If available, this is the gamepad object related to this controller.\r\n     * Using this object it is possible to get click events and trackpad changes of the\r\n     * webxr controller that is currently being used.\r\n     */\r\n    public motionController?: WebXRAbstractMotionController;\r\n    /**\r\n     * Event that fires when the controller is removed/disposed.\r\n     * The object provided as event data is this controller, after associated assets were disposed.\r\n     * uniqueId is still available.\r\n     */\r\n    public onDisposeObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Will be triggered when the mesh associated with the motion controller is done loading.\r\n     * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh\r\n     * A shortened version of controller -> motion controller -> on mesh loaded.\r\n     */\r\n    public onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n    /**\r\n     * Observers registered here will trigger when a motion controller profile was assigned to this xr controller\r\n     */\r\n    public onMotionControllerInitObservable = new Observable<WebXRAbstractMotionController>();\r\n    /**\r\n     * Pointer which can be used to select objects or attach a visible laser to\r\n     */\r\n    public pointer: AbstractMesh;\r\n\r\n    /**\r\n     * The last XRPose the was calculated on the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRPose?: XRPose;\r\n\r\n    /**\r\n     * Creates the input source object\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRInputControllerSupport\r\n     * @param _scene the scene which the controller should be associated to\r\n     * @param inputSource the underlying input source for the controller\r\n     * @param _options options for this controller creation\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        /** The underlying input source for the controller  */\r\n        public inputSource: XRInputSource,\r\n        private _options: IWebXRControllerOptions = {}\r\n    ) {\r\n        this._uniqueId = `controller-${idCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;\r\n\r\n        this.pointer = new AbstractMesh(`${this._uniqueId}-pointer`, _scene);\r\n        this.pointer.rotationQuaternion = new Quaternion();\r\n\r\n        if (this.inputSource.gripSpace) {\r\n            this.grip = new AbstractMesh(`${this._uniqueId}-grip`, this._scene);\r\n            this.grip.rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n\r\n        // for now only load motion controllers if gamepad object available\r\n        if (this.inputSource.gamepad && this.inputSource.targetRayMode === \"tracked-pointer\") {\r\n            WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(\r\n                (motionController) => {\r\n                    this.motionController = motionController;\r\n                    this.onMotionControllerInitObservable.notifyObservers(motionController);\r\n                    // should the model be loaded?\r\n                    if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {\r\n                        this.motionController.loadModel().then((success) => {\r\n                            if (success && this.motionController && this.motionController.rootMesh) {\r\n                                if (this._options.renderingGroupId) {\r\n                                    // anything other than 0?\r\n                                    this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;\r\n                                    this.motionController.rootMesh.getChildMeshes(false).forEach((mesh) => (mesh.renderingGroupId = this._options.renderingGroupId!));\r\n                                }\r\n                                this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);\r\n                                this.motionController.rootMesh.parent = this.grip || this.pointer;\r\n                                this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;\r\n                            }\r\n                            // make sure to dispose is the controller is already disposed\r\n                            if (this._disposed) {\r\n                                this.motionController?.dispose();\r\n                            }\r\n                        });\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Warn(`Could not find a matching motion controller for the registered input source`);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get this controllers unique id\r\n     */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        if (this.grip) {\r\n            this.grip.dispose(true);\r\n        }\r\n        if (this.motionController) {\r\n            this.motionController.dispose();\r\n        }\r\n        this.pointer.dispose(true);\r\n        this.onMotionControllerInitObservable.clear();\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this._disposed = true;\r\n    }\r\n\r\n    /**\r\n     * Gets a world space ray coming from the pointer or grip\r\n     * @param result the resulting ray\r\n     * @param gripIfAvailable use the grip mesh instead of the pointer, if available\r\n     */\r\n    public getWorldPointerRayToRef(result: Ray, gripIfAvailable: boolean = false) {\r\n        const object = gripIfAvailable && this.grip ? this.grip : this.pointer;\r\n        Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);\r\n        result.direction.normalize();\r\n        result.origin.copyFrom(object.absolutePosition);\r\n        result.length = 1000;\r\n    }\r\n\r\n    /**\r\n     * Updates the controller pose based on the given XRFrame\r\n     * @param xrFrame xr frame to update the pose with\r\n     * @param referenceSpace reference space to use\r\n     * @param xrCamera the xr camera, used for parenting\r\n     * @param xrSessionManager the session manager used to get the world reference system\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, xrCamera: WebXRCamera, xrSessionManager: WebXRSessionManager) {\r\n        const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);\r\n        this._lastXRPose = pose;\r\n\r\n        // Update the pointer mesh\r\n        if (pose) {\r\n            const pos = pose.transform.position;\r\n            this.pointer.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\r\n            const orientation = pose.transform.orientation;\r\n            this.pointer.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this.pointer.position.z *= -1;\r\n                this.pointer.rotationQuaternion!.z *= -1;\r\n                this.pointer.rotationQuaternion!.w *= -1;\r\n            }\r\n            this.pointer.parent = xrCamera.parent;\r\n            this.pointer.scaling.setAll(xrSessionManager.worldScalingFactor);\r\n        }\r\n\r\n        // Update the grip mesh if it exists\r\n        if (this.inputSource.gripSpace && this.grip) {\r\n            const pose = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);\r\n            if (pose) {\r\n                const pos = pose.transform.position;\r\n                const orientation = pose.transform.orientation;\r\n                this.grip.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\r\n                this.grip.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n                if (!this._scene.useRightHandedSystem) {\r\n                    this.grip.position.z *= -1;\r\n                    this.grip.rotationQuaternion!.z *= -1;\r\n                    this.grip.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n            this.grip.parent = xrCamera.parent;\r\n            this.grip.scaling.setAll(xrSessionManager.worldScalingFactor);\r\n        }\r\n        if (this.motionController) {\r\n            // either update buttons only or also position, if in gamepad mode\r\n            this.motionController.updateFromXRFrame(xrFrame);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IWebXRControllerOptions } from \"./webXRInputSource\";\r\nimport { WebXRInputSource } from \"./webXRInputSource\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\n\r\n/**\r\n * The schema for initialization options of the XR Input class\r\n */\r\nexport interface IWebXRInputOptions {\r\n    /**\r\n     * If set to true no model will be automatically loaded\r\n     */\r\n    doNotLoadControllerMeshes?: boolean;\r\n\r\n    /**\r\n     * If set, this profile will be used for all controllers loaded (for example \"microsoft-mixed-reality\")\r\n     * If not found, the xr input profile data will be used.\r\n     * Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/\r\n     */\r\n    forceInputProfile?: string;\r\n\r\n    /**\r\n     * Do not send a request to the controller repository to load the profile.\r\n     *\r\n     * Instead, use the controllers available in babylon itself.\r\n     */\r\n    disableOnlineControllerRepository?: boolean;\r\n\r\n    /**\r\n     * A custom URL for the controllers repository\r\n     */\r\n    customControllersRepositoryURL?: string;\r\n\r\n    /**\r\n     * Should the controller model's components not move according to the user input\r\n     */\r\n    disableControllerAnimation?: boolean;\r\n\r\n    /**\r\n     * Optional options to pass to the controller. Will be overridden by the Input options where applicable\r\n     */\r\n    controllerOptions?: IWebXRControllerOptions;\r\n}\r\n/**\r\n * XR input used to track XR inputs such as controllers/rays\r\n */\r\nexport class WebXRInput implements IDisposable {\r\n    /**\r\n     * XR controllers being tracked\r\n     */\r\n    public controllers: Array<WebXRInputSource> = [];\r\n    private _frameObserver: Nullable<Observer<any>>;\r\n    private _sessionEndedObserver: Nullable<Observer<any>>;\r\n    private _sessionInitObserver: Nullable<Observer<any>>;\r\n    /**\r\n     * Event when a controller has been connected/added\r\n     */\r\n    public onControllerAddedObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Event when a controller has been removed/disconnected\r\n     */\r\n    public onControllerRemovedObservable = new Observable<WebXRInputSource>();\r\n\r\n    /**\r\n     * Initializes the WebXRInput\r\n     * @param xrSessionManager the xr session manager for this session\r\n     * @param xrCamera the WebXR camera for this session. Mainly used for teleportation\r\n     * @param _options = initialization options for this xr input\r\n     */\r\n    public constructor(\r\n        /**\r\n         * the xr session manager for this session\r\n         */\r\n        public xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * the WebXR camera for this session. Mainly used for teleportation\r\n         */\r\n        public xrCamera: WebXRCamera,\r\n        private readonly _options: IWebXRInputOptions = {}\r\n    ) {\r\n        // Remove controllers when exiting XR\r\n        this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._addAndRemoveControllers(\r\n                [],\r\n                this.controllers.map((c) => {\r\n                    return c.inputSource;\r\n                })\r\n            );\r\n        });\r\n\r\n        this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {\r\n            session.addEventListener(\"inputsourceschange\", this._onInputSourcesChange);\r\n        });\r\n\r\n        this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {\r\n            // Update controller pose info\r\n            this.controllers.forEach((controller) => {\r\n                controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace, this.xrCamera, this.xrSessionManager);\r\n            });\r\n        });\r\n\r\n        if (this._options.customControllersRepositoryURL) {\r\n            WebXRMotionControllerManager.BaseRepositoryUrl = this._options.customControllersRepositoryURL;\r\n        }\r\n\r\n        WebXRMotionControllerManager.UseOnlineRepository = !this._options.disableOnlineControllerRepository;\r\n        if (WebXRMotionControllerManager.UseOnlineRepository) {\r\n            // pre-load the profiles list to load the controllers quicker afterwards\r\n            try {\r\n                WebXRMotionControllerManager.UpdateProfilesList().catch(() => {\r\n                    WebXRMotionControllerManager.UseOnlineRepository = false;\r\n                });\r\n            } catch (e) {\r\n                WebXRMotionControllerManager.UseOnlineRepository = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onInputSourcesChange = (event: XRInputSourceChangeEvent) => {\r\n        this._addAndRemoveControllers(event.added, event.removed);\r\n    };\r\n\r\n    private _addAndRemoveControllers(addInputs: readonly XRInputSource[], removeInputs: readonly XRInputSource[]) {\r\n        // Add controllers if they don't already exist\r\n        const sources = this.controllers.map((c) => {\r\n            return c.inputSource;\r\n        });\r\n        for (const input of addInputs) {\r\n            if (sources.indexOf(input) === -1) {\r\n                const controller = new WebXRInputSource(this.xrSessionManager.scene, input, {\r\n                    ...(this._options.controllerOptions || {}),\r\n                    forceControllerProfile: this._options.forceInputProfile,\r\n                    doNotLoadControllerMesh: this._options.doNotLoadControllerMeshes,\r\n                    disableMotionControllerAnimation: this._options.disableControllerAnimation,\r\n                });\r\n                this.controllers.push(controller);\r\n                this.onControllerAddedObservable.notifyObservers(controller);\r\n            }\r\n        }\r\n\r\n        // Remove and dispose of controllers to be disposed\r\n        const keepControllers: Array<WebXRInputSource> = [];\r\n        const removedControllers: Array<WebXRInputSource> = [];\r\n        this.controllers.forEach((c) => {\r\n            if (removeInputs.indexOf(c.inputSource) === -1) {\r\n                keepControllers.push(c);\r\n            } else {\r\n                removedControllers.push(c);\r\n            }\r\n        });\r\n        this.controllers = keepControllers;\r\n        removedControllers.forEach((c) => {\r\n            this.onControllerRemovedObservable.notifyObservers(c);\r\n            c.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this.controllers.forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);\r\n        this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);\r\n        this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);\r\n        this.onControllerAddedObservable.clear();\r\n        this.onControllerRemovedObservable.clear();\r\n\r\n        // clear the controller cache\r\n        WebXRMotionControllerManager.ClearControllerCache();\r\n    }\r\n}\r\n", "import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = (options.tessellation || 24) | 0;\r\n    const subdivisions: number = (options.subdivisions || 1) | 0;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\nMesh.CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a torus\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * diameter the diameter of the torus, optional default 1\r\n * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the torus\r\n */\r\nexport function CreateTorusVertexData(options: { diameter?: number; thickness?: number; tessellation?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }) {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const diameter = options.diameter || 1;\r\n    const thickness = options.thickness || 0.5;\r\n    const tessellation = (options.tessellation || 16) | 0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const stride = tessellation + 1;\r\n\r\n    for (let i = 0; i <= tessellation; i++) {\r\n        const u = i / tessellation;\r\n\r\n        const outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\r\n\r\n        const transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\r\n\r\n        for (let j = 0; j <= tessellation; j++) {\r\n            const v = 1 - j / tessellation;\r\n\r\n            const innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\r\n            const dx = Math.cos(innerAngle);\r\n            const dy = Math.sin(innerAngle);\r\n\r\n            // Create a vertex.\r\n            let normal = new Vector3(dx, dy, 0);\r\n            let position = normal.scale(thickness / 2);\r\n            const textureCoordinate = new Vector2(u, v);\r\n\r\n            position = Vector3.TransformCoordinates(position, transform);\r\n            normal = Vector3.TransformNormal(normal, transform);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\r\n\r\n            // And create indices for two triangles.\r\n            const nextI = (i + 1) % stride;\r\n            const nextJ = (j + 1) % stride;\r\n\r\n            indices.push(i * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus\r\n */\r\nexport function CreateTorus(\r\n    name: string,\r\n    options: { diameter?: number; thickness?: number; tessellation?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torus = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torus._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusVertexData(options);\r\n\r\n    vertexData.applyToMesh(torus, options.updatable);\r\n\r\n    return torus;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorus instead\r\n */\r\nexport const TorusBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorus,\r\n};\r\n\r\nVertexData.CreateTorus = CreateTorusVertexData;\r\n\r\nMesh.CreateTorus = (name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        diameter,\r\n        thickness,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorus(name, options, scene);\r\n};\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n\r\n    /**\r\n     * Use the grip space instead of the pointer space for selection, if available.\r\n     */\r\n    forceGripIfAvailable?: boolean;\r\n\r\n    /**\r\n     * If set to true, the hand rays will be disabled and the user will be able to look and pick objects.\r\n     * This requires system support (like in the vision OS) and will not work in all systems.\r\n     * @experimental - this is an experimental feature and might change int he future\r\n     */\r\n    lookAndPickMode?: boolean;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(this._options.forceGripIfAvailable && xrController.grip ? xrController.grip : xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n            case \"transient-pointer\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRControllerPointerSelectionOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n\r\n        // force look and pick mode if using WebXR on safari, assuming it is vision OS\r\n        // Only if not explicitly set. If set to false, it will not be forced\r\n        if (this._options.lookAndPickMode === undefined && (this._scene.getEngine()._badDesktopOS || this._scene.getEngine()._badOS)) {\r\n            this._options.lookAndPickMode = true;\r\n        }\r\n\r\n        // look and pick mode extra state changes\r\n        if (this._options.lookAndPickMode) {\r\n            this._options.enablePointerSelectionOnAllControllers = true;\r\n            this.displayLaserPointer = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController, true);\r\n        this._addNewAttachObserver(\r\n            this._options.xrInput.onControllerRemovedObservable,\r\n            (controller) => {\r\n                // REMOVE the controller\r\n                this._detachController(controller.uniqueId);\r\n            },\r\n            true\r\n        );\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // look and pick mode\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if (this._options.lookAndPickMode && controllerData.xrController?.inputSource.targetRayMode !== \"transient-pointer\") {\r\n                return;\r\n            }\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition =\r\n                    this._options.forceGripIfAvailable && controllerData.xrController.grip\r\n                        ? controllerData.xrController.grip.position\r\n                        : controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay, this._options.forceGripIfAvailable);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth() / camera.rigCameras.length, scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, camera.getTransformationMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y) &&\r\n                        this._screenCoordinatesRef.x !== Infinity &&\r\n                        this._screenCoordinatesRef.y !== Infinity\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n                controllerData.pick.originMesh = controllerData.xrController.pointer;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._xrSessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                    if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        controllerData.pointerDownTriggered = true;\r\n                        (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                        (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                    }\r\n                });\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._xrSessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                    if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                        this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                        (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                    }\r\n                });\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    // For future reference - this is an issue in the WebXR typings.\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\r\n                controllerData.finalPointerUpTriggered = true;\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n", "import { BezierCurve } from \"../Maths/math.path\";\r\n\r\n/**\r\n * This represents the main contract an easing function should follow.\r\n * Easing functions are used throughout the animation system.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport interface IEasingFunction {\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * The link below provides some of the most common examples of easing functions.\r\n     * @see https://easings.net/\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    ease(gradient: number): number;\r\n}\r\n\r\n/**\r\n * Base class used for every default easing function.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Interpolation follows the mathematical formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEIN = 0;\r\n\r\n    /**\r\n     * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEOUT = 1;\r\n\r\n    /**\r\n     * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.\r\n     */\r\n    public static readonly EASINGMODE_EASEINOUT = 2;\r\n\r\n    private _easingMode = EasingFunction.EASINGMODE_EASEIN;\r\n\r\n    /**\r\n     * Sets the easing mode of the current function.\r\n     * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)\r\n     */\r\n    public setEasingMode(easingMode: number) {\r\n        const n = Math.min(Math.max(easingMode, 0), 2);\r\n        this._easingMode = n;\r\n    }\r\n    /**\r\n     * Gets the current easing mode.\r\n     * @returns the easing mode\r\n     */\r\n    public getEasingMode(): number {\r\n        return this._easingMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public easeInCore(gradient: number): number {\r\n        throw new Error(\"You must implement this method\");\r\n    }\r\n\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    public ease(gradient: number): number {\r\n        switch (this._easingMode) {\r\n            case EasingFunction.EASINGMODE_EASEIN:\r\n                return this.easeInCore(gradient);\r\n            case EasingFunction.EASINGMODE_EASEOUT:\r\n                return 1 - this.easeInCore(1 - gradient);\r\n        }\r\n\r\n        if (gradient >= 0.5) {\r\n            return (1 - this.easeInCore((1 - gradient) * 2)) * 0.5 + 0.5;\r\n        }\r\n\r\n        return this.easeInCore(gradient * 2) * 0.5;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a circle shape (see link below).\r\n * @see https://easings.net/#easeInCirc\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class CircleEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        gradient = Math.max(0, Math.min(1, gradient));\r\n        return 1.0 - Math.sqrt(1.0 - gradient * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a ease back shape (see link below).\r\n * @see https://easings.net/#easeInBack\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BackEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a back ease easing\r\n     * @see https://easings.net/#easeInBack\r\n     * @param amplitude Defines the amplitude of the function\r\n     */\r\n    constructor(\r\n        /** Defines the amplitude of the function */\r\n        public amplitude: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const num = Math.max(0, this.amplitude);\r\n        return Math.pow(gradient, 3.0) - gradient * num * Math.sin(3.1415926535897931 * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bouncing shape (see link below).\r\n * @see https://easings.net/#easeInBounce\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BounceEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bounce easing\r\n     * @see https://easings.net/#easeInBounce\r\n     * @param bounces Defines the number of bounces\r\n     * @param bounciness Defines the amplitude of the bounce\r\n     */\r\n    constructor(\r\n        /** Defines the number of bounces */\r\n        public bounces: number = 3,\r\n        /** Defines the amplitude of the bounce */\r\n        public bounciness: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.bounces);\r\n        let bounciness = this.bounciness;\r\n        if (bounciness <= 1.0) {\r\n            bounciness = 1.001;\r\n        }\r\n        const num9 = Math.pow(bounciness, y);\r\n        const num5 = 1.0 - bounciness;\r\n        const num4 = (1.0 - num9) / num5 + num9 * 0.5;\r\n        const num15 = gradient * num4;\r\n        const num65 = Math.log(-num15 * (1.0 - bounciness) + 1.0) / Math.log(bounciness);\r\n        const num3 = Math.floor(num65);\r\n        const num13 = num3 + 1.0;\r\n        const num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);\r\n        const num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);\r\n        const num7 = (num8 + num12) * 0.5;\r\n        const num6 = gradient - num7;\r\n        const num2 = num7 - num8;\r\n        return (-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2) * (num6 + num2);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 3 shape (see link below).\r\n * @see https://easings.net/#easeInCubic\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class CubicEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an elastic shape (see link below).\r\n * @see https://easings.net/#easeInElastic\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class ElasticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an elastic easing function\r\n     * @see https://easings.net/#easeInElastic\r\n     * @param oscillations Defines the number of oscillations\r\n     * @param springiness Defines the amplitude of the oscillations\r\n     */\r\n    constructor(\r\n        /** Defines the number of oscillations*/\r\n        public oscillations: number = 3,\r\n        /** Defines the amplitude of the oscillations*/\r\n        public springiness: number = 3\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        let num2;\r\n        const num3 = Math.max(0.0, this.oscillations);\r\n        const num = Math.max(0.0, this.springiness);\r\n\r\n        if (num == 0) {\r\n            num2 = gradient;\r\n        } else {\r\n            num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);\r\n        }\r\n        return num2 * Math.sin((6.2831853071795862 * num3 + 1.5707963267948966) * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an exponential shape (see link below).\r\n * @see https://easings.net/#easeInExpo\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class ExponentialEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an exponential easing function\r\n     * @see https://easings.net/#easeInExpo\r\n     * @param exponent Defines the exponent of the function\r\n     */\r\n    constructor(\r\n        /** Defines the exponent of the function */\r\n        public exponent: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        if (this.exponent <= 0) {\r\n            return gradient;\r\n        }\r\n\r\n        return (Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class PowerEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an power base easing function\r\n     * @see https://easings.net/#easeInQuad\r\n     * @param power Defines the power of the function\r\n     */\r\n    constructor(\r\n        /** Defines the power of the function */\r\n        public power: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.power);\r\n        return Math.pow(gradient, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 2 shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuadraticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 4 shape (see link below).\r\n * @see https://easings.net/#easeInQuart\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuarticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 5 shape (see link below).\r\n * @see https://easings.net/#easeInQuint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuinticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a sin shape (see link below).\r\n * @see https://easings.net/#easeInSine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class SineEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return 1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient));\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bezier shape (see link below).\r\n * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BezierCurveEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bezier function\r\n     * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n     * @param x1 Defines the x component of the start tangent in the bezier curve\r\n     * @param y1 Defines the y component of the start tangent in the bezier curve\r\n     * @param x2 Defines the x component of the end tangent in the bezier curve\r\n     * @param y2 Defines the y component of the end tangent in the bezier curve\r\n     */\r\n    constructor(\r\n        /** Defines the x component of the start tangent in the bezier curve */\r\n        public x1: number = 0,\r\n        /** Defines the y component of the start tangent in the bezier curve */\r\n        public y1: number = 0,\r\n        /** Defines the x component of the end tangent in the bezier curve */\r\n        public x2: number = 1,\r\n        /** Defines the y component of the end tangent in the bezier curve */\r\n        public y2: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IndicesArray } from \"../types\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\ndeclare module \"./subMesh\" {\r\n    export interface SubMesh {\r\n        /** @internal */\r\n        _projectOnTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number;\r\n        /** @internal */\r\n        _projectOnUnIndexedTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n        /**\r\n         * Projects a point on this submesh and stores the result in \"ref\"\r\n         *\r\n         * @param vector point to project\r\n         * @param positions defines mesh's positions array\r\n         * @param indices defines mesh's indices array\r\n         * @param ref vector that will store the result\r\n         * @returns distance from the point and the submesh, or -1 if the mesh rendering mode doesn't support projections\r\n         */\r\n        projectToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n        const indexA = indices[index];\r\n        const indexB = indices[index + 1];\r\n        const indexC = indices[index + 2];\r\n\r\n        if (checkStopper && indexC === 0xffffffff) {\r\n            index += 2;\r\n            continue;\r\n        }\r\n\r\n        const p0 = positions[indexA];\r\n        const p1 = positions[indexB];\r\n        const p2 = positions[indexC];\r\n\r\n        // stay defensive and don't check against undefined positions.\r\n        if (!p0 || !p1 || !p2) {\r\n            continue;\r\n        }\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n        const p0 = positions[index];\r\n        const p1 = positions[index + 1];\r\n        const p2 = positions[index + 2];\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\nSubMesh.prototype.projectToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    const material = this.getMaterial();\r\n    if (!material) {\r\n        return -1;\r\n    }\r\n    let step = 3;\r\n    let checkStopper = false;\r\n\r\n    switch (material.fillMode) {\r\n        case Constants.MATERIAL_PointListDrawMode:\r\n        case Constants.MATERIAL_LineLoopDrawMode:\r\n        case Constants.MATERIAL_LineStripDrawMode:\r\n        case Constants.MATERIAL_TriangleFanDrawMode:\r\n            return -1;\r\n        case Constants.MATERIAL_TriangleStripDrawMode:\r\n            step = 1;\r\n            checkStopper = true;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // LineMesh first as it's also a Mesh...\r\n    if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n        return -1;\r\n    } else {\r\n        // Check if mesh is unindexed\r\n        if (!indices.length && (this as any)._mesh._unIndexed) {\r\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\r\n        }\r\n\r\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\r\n    }\r\n};\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRControllerPointerSelection } from \"./WebXRControllerPointerSelection\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { IndicesArray, Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport { BoundingSphere } from \"../../Culling/boundingSphere\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing\";\r\n// side effects\r\nimport \"../../Meshes/subMesh.project\";\r\n\r\ntype ControllerData = {\r\n    xrController?: WebXRInputSource;\r\n    squeezeComponent?: WebXRControllerComponent;\r\n    selectionComponent?: WebXRControllerComponent;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onSqueezeButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n    meshUnderPointer: Nullable<AbstractMesh>;\r\n    nearInteractionTargetMesh: Nullable<AbstractMesh>;\r\n    pick: Nullable<PickingInfo>;\r\n    stalePick: Nullable<PickingInfo>;\r\n    id: number;\r\n    touchCollisionMesh: AbstractMesh;\r\n    touchCollisionMeshFunction: (isTouch: boolean) => void;\r\n    hydrateCollisionMeshFunction: (isHydration: boolean) => void;\r\n    currentAnimationState: ControllerOrbAnimationState;\r\n    grabRay: Ray;\r\n    nearInteraction: boolean;\r\n    hoverInteraction: boolean;\r\n    grabInteraction: boolean;\r\n    downTriggered: boolean;\r\n    // event support\r\n    eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n    pickedPointVisualCue: AbstractMesh;\r\n    _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>>;\r\n};\r\n\r\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\r\nenum ControllerOrbAnimationState {\r\n    /**\r\n     * Orb is invisible\r\n     */\r\n    DEHYDRATED,\r\n    /**\r\n     * Orb is visible and inside the hover range\r\n     */\r\n    HOVER,\r\n    /**\r\n     * Orb is visible and touching a near interaction target\r\n     */\r\n    TOUCH,\r\n}\r\n\r\n/**\r\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\r\n */\r\nexport enum WebXRNearControllerMode {\r\n    /**\r\n     * Motion controllers will not support near interaction\r\n     */\r\n    DISABLED = 0,\r\n    /**\r\n     * The interaction point for motion controllers will be inside of them\r\n     */\r\n    CENTERED_ON_CONTROLLER = 1,\r\n    /**\r\n     * The interaction point for motion controllers will be in front of the controller\r\n     */\r\n    CENTERED_IN_FRONT = 2,\r\n}\r\n\r\n/**\r\n * Options interface for the near interaction module\r\n */\r\nexport interface IWebXRNearInteractionOptions {\r\n    /**\r\n     * If provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * The xr input to use with this near interaction\r\n     */\r\n    xrInput: WebXRInput;\r\n    /**\r\n     * Enable near interaction on all controllers instead of switching between them\r\n     */\r\n    enableNearInteractionOnAllControllers?: boolean;\r\n    /**\r\n     * The preferred hand to give the near interaction to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n    /**\r\n     * Disable switching the near interaction from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * Far interaction feature to toggle when near interaction takes precedence\r\n     */\r\n    farInteractionFeature?: WebXRControllerPointerSelection;\r\n\r\n    /**\r\n     * Near interaction mode for motion controllers\r\n     */\r\n    nearInteractionControllerMode?: WebXRNearControllerMode;\r\n\r\n    /**\r\n     * Optional material for the motion controller orb, if enabled\r\n     */\r\n    motionControllerOrbMaterial?: Material;\r\n}\r\n\r\n/**\r\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\r\n */\r\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _tmpRay: Ray = new Ray(new Vector3(), new Vector3());\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        // get two new meshes\r\n        const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n        const selectionMesh = this._generateVisualCue();\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            meshUnderPointer: null,\r\n            nearInteractionTargetMesh: null,\r\n            pick: null,\r\n            stalePick: null,\r\n            touchCollisionMesh,\r\n            touchCollisionMeshFunction: touchCollisionMeshFunction,\r\n            hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\r\n            currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\r\n            grabRay: new Ray(new Vector3(), new Vector3()),\r\n            hoverInteraction: false,\r\n            nearInteraction: false,\r\n            grabInteraction: false,\r\n            downTriggered: false,\r\n            id: WebXRNearInteraction._IdCounter++,\r\n            pickedPointVisualCue: selectionMesh,\r\n        };\r\n\r\n        this._controllers[xrController.uniqueId]._worldScaleObserver =\r\n            this._controllers[xrController.uniqueId]._worldScaleObserver ||\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {\r\n                if (values.newScaleFactor !== values.previousScaleFactor) {\r\n                    this._controllers[xrController.uniqueId].touchCollisionMesh.dispose();\r\n                    this._controllers[xrController.uniqueId].pickedPointVisualCue.dispose();\r\n\r\n                    const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n                    this._controllers[xrController.uniqueId].touchCollisionMesh = touchCollisionMesh;\r\n                    this._controllers[xrController.uniqueId].touchCollisionMeshFunction = touchCollisionMeshFunction;\r\n                    this._controllers[xrController.uniqueId].hydrateCollisionMeshFunction = hydrateCollisionMeshFunction;\r\n                    this._controllers[xrController.uniqueId].pickedPointVisualCue = this._generateVisualCue();\r\n                }\r\n            });\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enableNearInteractionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enableNearInteractionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachNearInteractionMode(xrController);\r\n            case \"gaze\":\r\n                return null;\r\n            case \"screen\":\r\n                return null;\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: ControllerData;\r\n    } = {};\r\n    private _scene: Scene;\r\n\r\n    private _attachedController: string;\r\n\r\n    private _farInteractionFeature: Nullable<WebXRControllerPointerSelection> = null;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.NEAR_INTERACTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRNearInteractionOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n        if (this._options.nearInteractionControllerMode === undefined) {\r\n            this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\r\n        }\r\n\r\n        if (this._options.farInteractionFeature) {\r\n            this._farInteractionFeature = this._options.farInteractionFeature;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function sets webXRControllerPointerSelection feature that will be disabled when\r\n     * the hover range is reached for a mesh and will be reattached when not in hover range.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\r\n     */\r\n    public setFarInteractionFeature(farInteractionFeature: Nullable<WebXRControllerPointerSelection>) {\r\n        this._farInteractionFeature = farInteractionFeature;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction pick and hover\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearPickPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction grab\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearGrabPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for any near interaction\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearInteractionPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\r\n    }\r\n\r\n    private _controllerAvailablePredicate(mesh: AbstractMesh, controllerId: string): boolean {\r\n        let parent: TransformNode = mesh;\r\n\r\n        while (parent) {\r\n            if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\r\n                return false;\r\n            }\r\n            parent = parent.parent as TransformNode;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _handleTransitionAnimation(controllerData: ControllerData, newState: ControllerOrbAnimationState) {\r\n        if (\r\n            controllerData.currentAnimationState === newState ||\r\n            this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT ||\r\n            !!controllerData.xrController?.inputSource.hand\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\r\n        if (newState > controllerData.currentAnimationState) {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.DEHYDRATED: {\r\n                    controllerData.hydrateCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.touchCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.TOUCH) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.TOUCH: {\r\n                    controllerData.touchCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.hydrateCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.DEHYDRATED) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        controllerData.currentAnimationState = newState;\r\n    }\r\n\r\n    private readonly _hoverRadius = 0.1;\r\n    private readonly _pickRadius = 0.02;\r\n    private readonly _controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\r\n    private readonly _nearGrabLengthScale = 5;\r\n\r\n    private _processTouchPoint(id: string, position: Vector3, orientation: Quaternion) {\r\n        const controllerData = this._controllers[id];\r\n\r\n        // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\r\n        controllerData.grabRay.origin.copyFrom(position);\r\n        orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\r\n        controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\r\n\r\n        if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !controllerData.xrController?.inputSource.hand) {\r\n            // offset the touch point in the direction the transform is facing\r\n            controllerData.xrController!.getWorldPointerRayToRef(this._tmpRay);\r\n            controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\r\n        }\r\n\r\n        controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius * this._xrSessionManager.worldScalingFactor;\r\n        controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            const handData = controllerData.xrController?.inputSource.hand;\r\n            // If near interaction is not enabled/available for this controller, return early\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n            controllerData.hoverInteraction = false;\r\n            controllerData.nearInteraction = false;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                if (handData) {\r\n                    const xrIndexTip = handData.get(\"index-finger-tip\");\r\n                    if (xrIndexTip) {\r\n                        const indexTipPose = _xrFrame.getJointPose!(xrIndexTip, this._xrSessionManager.referenceSpace);\r\n                        if (indexTipPose && indexTipPose.transform) {\r\n                            const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\r\n                            TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\r\n                            TmpVectors.Quaternion[0].set(\r\n                                indexTipPose.transform.orientation.x,\r\n                                indexTipPose.transform.orientation.y,\r\n                                indexTipPose.transform.orientation.z * axisRHSMultiplier,\r\n                                indexTipPose.transform.orientation.w * axisRHSMultiplier\r\n                            );\r\n\r\n                            this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\r\n                        }\r\n                    }\r\n                } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\r\n                    let controllerPose = controllerData.xrController.pointer;\r\n                    if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\r\n                        controllerPose = controllerData.xrController.grip;\r\n                    }\r\n\r\n                    this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion!);\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const accuratePickInfo = (originalScenePick: Nullable<PickingInfo>, utilityScenePick: Nullable<PickingInfo>): Nullable<PickingInfo> => {\r\n                let pick = null;\r\n                if (!utilityScenePick || !utilityScenePick.hit) {\r\n                    // No hit in utility scene\r\n                    pick = originalScenePick;\r\n                } else if (!originalScenePick || !originalScenePick.hit) {\r\n                    // No hit in original scene\r\n                    pick = utilityScenePick;\r\n                } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                    // Hit is closer in utility scene\r\n                    pick = utilityScenePick;\r\n                } else {\r\n                    // Hit is closer in original scene\r\n                    pick = originalScenePick;\r\n                }\r\n                return pick;\r\n            };\r\n            const populateNearInteractionInfo = (nearInteractionInfo: Nullable<PickingInfo>): PickingInfo => {\r\n                let result = new PickingInfo();\r\n\r\n                let nearInteractionAtOrigin = false;\r\n                const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\r\n                if (nearInteractionInfo?.pickedPoint) {\r\n                    nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\r\n                }\r\n                if (nearInteraction && !nearInteractionAtOrigin) {\r\n                    result = nearInteractionInfo!;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\r\n            // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\r\n            // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\r\n            if (!controllerData.grabInteraction) {\r\n                let pick = null;\r\n\r\n                // near interaction hover\r\n                let utilitySceneHoverPick = null;\r\n                if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                    utilitySceneHoverPick = this._pickWithSphere(\r\n                        controllerData,\r\n                        this._hoverRadius * this._xrSessionManager.worldScalingFactor,\r\n                        this._utilityLayerScene,\r\n                        (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh)\r\n                    );\r\n                }\r\n                const originalSceneHoverPick = this._pickWithSphere(\r\n                    controllerData,\r\n                    this._hoverRadius * this._xrSessionManager.worldScalingFactor,\r\n                    this._scene,\r\n                    (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh)\r\n                );\r\n\r\n                const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\r\n                if (hoverPickInfo && hoverPickInfo.hit) {\r\n                    pick = populateNearInteractionInfo(hoverPickInfo);\r\n                    if (pick.hit) {\r\n                        controllerData.hoverInteraction = true;\r\n                    }\r\n                }\r\n\r\n                // near interaction pick\r\n                if (controllerData.hoverInteraction) {\r\n                    let utilitySceneNearPick = null;\r\n                    const radius = (handData ? this._pickRadius : this._controllerPickRadius) * this._xrSessionManager.worldScalingFactor;\r\n                    if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                        utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    }\r\n                    const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\r\n                    const nearPick = populateNearInteractionInfo(pickInfo);\r\n                    if (nearPick.hit) {\r\n                        // Near pick takes precedence over hover interaction\r\n                        pick = nearPick;\r\n                        controllerData.nearInteraction = true;\r\n                    }\r\n                }\r\n\r\n                controllerData.stalePick = controllerData.pick;\r\n                controllerData.pick = pick;\r\n\r\n                // Update mesh under pointer\r\n                if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\r\n                    controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\r\n                    controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\r\n                    }\r\n                } else {\r\n                    controllerData.meshUnderPointer = null;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update the interaction animation. Only updates if the visible touch mesh is active\r\n            let state = ControllerOrbAnimationState.DEHYDRATED;\r\n            if (controllerData.grabInteraction || controllerData.nearInteraction) {\r\n                state = ControllerOrbAnimationState.TOUCH;\r\n            } else if (controllerData.hoverInteraction) {\r\n                state = ControllerOrbAnimationState.HOVER;\r\n            }\r\n            this._handleTransitionAnimation(controllerData, state);\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _generateVisualCue() {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const selectionMesh = CreateSphere(\r\n            \"nearInteraction\",\r\n            {\r\n                diameter: 0.0035 * 3 * this._xrSessionManager.worldScalingFactor,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        selectionMesh.rotationQuaternion = Quaternion.Identity();\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        return selectionMesh;\r\n    }\r\n\r\n    private _isControllerReadyForNearInteraction(id: number) {\r\n        if (this._farInteractionFeature) {\r\n            return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _attachNearInteractionMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr-near\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                return;\r\n            }\r\n            if (controllerData.pick) {\r\n                controllerData.pick.ray = controllerData.grabRay;\r\n            }\r\n\r\n            if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n\r\n            // Near pick pointer event\r\n            if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\r\n                if (!controllerData.nearInteractionTargetMesh) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\r\n                    controllerData.downTriggered = true;\r\n                }\r\n            } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\r\n                this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\r\n                controllerData.downTriggered = false;\r\n                controllerData.nearInteractionTargetMesh = null;\r\n            }\r\n        });\r\n\r\n        const grabCheck = (pressed: boolean) => {\r\n            if (\r\n                this._options.enableNearInteractionOnAllControllers ||\r\n                (xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id))\r\n            ) {\r\n                if (controllerData.pick) {\r\n                    controllerData.pick.ray = controllerData.grabRay;\r\n                }\r\n                if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = true;\r\n                } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = false;\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                }\r\n            } else {\r\n                if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                    this._attachedController = xrController.uniqueId;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\r\n                if (controllerData.squeezeComponent) {\r\n                    controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                } else {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                    controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id) &&\r\n                    controllerData.meshUnderPointer &&\r\n                    this._nearGrabPredicate(controllerData.meshUnderPointer)\r\n                ) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = true;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id)\r\n                ) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                    controllerData.downTriggered = false;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.squeezeComponent) {\r\n            if (controllerData.onSqueezeButtonChangedObserver) {\r\n                controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n        controllerData.touchCollisionMesh.dispose();\r\n        controllerData.pickedPointVisualCue.dispose();\r\n\r\n        this._xrSessionManager.runInXRFrame(() => {\r\n            if (!controllerData.downTriggered) {\r\n                return;\r\n            }\r\n            // Fire a pointerup in case controller was detached before a pointerup event was fired\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr-near\",\r\n            };\r\n            this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\r\n        });\r\n\r\n        // remove world scale observer\r\n        if (controllerData._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(controllerData._worldScaleObserver);\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n        if (this._attachedController === xrControllerUniqueId) {\r\n            // check for other controllers\r\n            const keys = Object.keys(this._controllers);\r\n            if (keys.length) {\r\n                this._attachedController = keys[0];\r\n            } else {\r\n                this._attachedController = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateNewTouchPointMesh() {\r\n        const worldScale = this._xrSessionManager.worldScalingFactor;\r\n        // populate information for near hover, pick and pinch\r\n        const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n\r\n        const touchCollisionMesh = CreateSphere(\"PickSphere\", { diameter: 1 * worldScale }, meshCreationScene);\r\n        touchCollisionMesh.isVisible = false;\r\n\r\n        // Generate the material for the touch mesh visuals\r\n        if (this._options.motionControllerOrbMaterial) {\r\n            touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\r\n        } else {\r\n            NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then((nodeMaterial) => {\r\n                touchCollisionMesh.material = nodeMaterial;\r\n            });\r\n        }\r\n\r\n        const easingFunction = new QuadraticEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n\r\n        // Adjust the visual size based off of the size of the touch collision orb.\r\n        // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\r\n        // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\r\n        const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius).scaleInPlace(worldScale);\r\n        const touchSize = this._controllerPickRadius * (4 / 3);\r\n        const touchSizeVec = new Vector3(touchSize, touchSize, touchSize).scaleInPlace(worldScale);\r\n        const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\r\n        const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize).scaleInPlace(worldScale);\r\n        const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\r\n        const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize).scaleInPlace(worldScale);\r\n        const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\r\n        const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize).scaleInPlace(worldScale);\r\n\r\n        const touchKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: hoverTouchTransitionSizeVec },\r\n            { frame: 18, value: touchSizeVec },\r\n        ];\r\n        const releaseKeys = [\r\n            { frame: 0, value: touchSizeVec },\r\n            { frame: 10, value: touchHoverTransitionSizeVec },\r\n            { frame: 18, value: hoverSizeVec },\r\n        ];\r\n        const hydrateKeys = [\r\n            { frame: 0, value: Vector3.ZeroReadOnly },\r\n            { frame: 12, value: hydrateTransitionSizeVec },\r\n            { frame: 15, value: hoverSizeVec },\r\n        ];\r\n        const dehydrateKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: Vector3.ZeroReadOnly },\r\n            { frame: 15, value: Vector3.ZeroReadOnly },\r\n        ];\r\n\r\n        const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        touchAction.setEasingFunction(easingFunction);\r\n        releaseAction.setEasingFunction(easingFunction);\r\n        hydrateAction.setEasingFunction(easingFunction);\r\n        dehydrateAction.setEasingFunction(easingFunction);\r\n\r\n        touchAction.setKeys(touchKeys);\r\n        releaseAction.setKeys(releaseKeys);\r\n        hydrateAction.setKeys(hydrateKeys);\r\n        dehydrateAction.setKeys(dehydrateKeys);\r\n\r\n        const touchCollisionMeshFunction = (isTouch: boolean) => {\r\n            const action = isTouch ? touchAction : releaseAction;\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\r\n        };\r\n\r\n        const hydrateCollisionMeshFunction = (isHydration: boolean) => {\r\n            const action = isHydration ? hydrateAction : dehydrateAction;\r\n            if (isHydration) {\r\n                touchCollisionMesh.isVisible = true;\r\n            }\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\r\n                if (!isHydration) {\r\n                    touchCollisionMesh.isVisible = false;\r\n                }\r\n            });\r\n        };\r\n\r\n        return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };\r\n    }\r\n\r\n    private _pickWithSphere(controllerData: ControllerData, radius: number, sceneToUse: Scene, predicate: (mesh: AbstractMesh) => boolean): Nullable<PickingInfo> {\r\n        const pickingInfo = new PickingInfo();\r\n        pickingInfo.distance = +Infinity;\r\n\r\n        if (controllerData.touchCollisionMesh && controllerData.xrController) {\r\n            const position = controllerData.touchCollisionMesh.position;\r\n            const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\r\n\r\n            for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\r\n                const mesh = sceneToUse.meshes[meshIndex];\r\n                if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\r\n                    continue;\r\n                }\r\n                const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\r\n\r\n                if (result && result.hit && result.distance < pickingInfo.distance) {\r\n                    pickingInfo.hit = result.hit;\r\n                    pickingInfo.pickedMesh = mesh;\r\n                    pickingInfo.pickedPoint = result.pickedPoint;\r\n                    pickingInfo.aimTransform = controllerData.xrController.pointer;\r\n                    pickingInfo.gripTransform = controllerData.xrController.grip || null;\r\n                    pickingInfo.originMesh = controllerData.touchCollisionMesh;\r\n                    pickingInfo.distance = result.distance;\r\n                    pickingInfo.bu = result.bu;\r\n                    pickingInfo.bv = result.bv;\r\n                    pickingInfo.faceId = result.faceId;\r\n                    pickingInfo.subMeshId = result.subMeshId;\r\n                }\r\n            }\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Picks a mesh with a sphere\r\n     * @param mesh the mesh to pick\r\n     * @param sphere picking sphere in world coordinates\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public static PickMeshWithSphere(mesh: AbstractMesh, sphere: BoundingSphere, skipBoundingInfo = false): PickingInfo {\r\n        const subMeshes = mesh.subMeshes;\r\n        const pi = new PickingInfo();\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (!mesh._generatePointsArray()) {\r\n            return pi;\r\n        }\r\n\r\n        if (!mesh.subMeshes || !boundingInfo) {\r\n            return pi;\r\n        }\r\n\r\n        if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\r\n            return pi;\r\n        }\r\n\r\n        const result = TmpVectors.Vector3[0];\r\n        const tmpVec = TmpVectors.Vector3[1];\r\n        const tmpRay = new Ray(Vector3.Zero(), Vector3.Zero(), 1);\r\n\r\n        let distance = +Infinity;\r\n        let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter, intersectionInfo;\r\n        const center = TmpVectors.Vector3[2];\r\n        const worldToMesh = TmpVectors.Matrix[0];\r\n        worldToMesh.copyFrom(mesh.getWorldMatrix());\r\n        worldToMesh.invert();\r\n        Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\r\n\r\n        for (let index = 0; index < subMeshes.length; index++) {\r\n            const subMesh = subMeshes[index];\r\n\r\n            subMesh.projectToRef(center, <Vector3[]>mesh._positions, <IndicesArray>mesh.getIndices(), tmpVec);\r\n\r\n            Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\r\n            tmp = Vector3.Distance(tmpVec, sphere.center);\r\n\r\n            // Check for finger inside of mesh\r\n            tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\r\n            tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\r\n            if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\r\n                tmp = 0;\r\n                tmpVec.copyFrom(sphere.center);\r\n            }\r\n\r\n            if (tmp !== -1 && tmp < distance) {\r\n                distance = tmp;\r\n\r\n                // ray between the sphere center and the point on the mesh\r\n                Ray.CreateFromToToRef(sphere.center, tmpVec, tmpRay);\r\n                tmpRay.length = distance * 2;\r\n                intersectionInfo = tmpRay.intersectsMesh(mesh);\r\n\r\n                result.copyFrom(tmpVec);\r\n            }\r\n        }\r\n\r\n        if (distance < sphere.radius) {\r\n            pi.hit = true;\r\n            pi.distance = distance;\r\n            pi.pickedMesh = mesh;\r\n            pi.pickedPoint = result.clone();\r\n            if (intersectionInfo && intersectionInfo.bu !== null && intersectionInfo.bv !== null) {\r\n                pi.faceId = intersectionInfo.faceId;\r\n                pi.subMeshId = intersectionInfo.subMeshId;\r\n                pi.bu = intersectionInfo.bu;\r\n                pi.bv = intersectionInfo.bv;\r\n            }\r\n        }\r\n\r\n        return pi;\r\n    }\r\n}\r\n\r\n//Register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRNearInteraction.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRNearInteraction(xrSessionManager, options);\r\n    },\r\n    WebXRNearInteraction.Version,\r\n    true\r\n);\r\n", "import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Button which can be used to enter a different mode of XR\r\n */\r\nexport class WebXREnterExitUIButton {\r\n    /**\r\n     * Creates a WebXREnterExitUIButton\r\n     * @param element button element\r\n     * @param sessionMode XR initialization session mode\r\n     * @param referenceSpaceType the type of reference space to be used\r\n     */\r\n    constructor(\r\n        /** button element */\r\n        public element: HTMLElement,\r\n        /** XR initialization options for the button */\r\n        public sessionMode: XRSessionMode,\r\n        /** Reference space type */\r\n        public referenceSpaceType: XRReferenceSpaceType\r\n    ) {}\r\n\r\n    /**\r\n     * Extendable function which can be used to update the button's visuals when the state changes\r\n     * @param activeButton the current active button in the UI\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public update(activeButton: Nullable<WebXREnterExitUIButton>) {}\r\n}\r\n\r\n/**\r\n * Options to create the webXR UI\r\n */\r\nexport class WebXREnterExitUIOptions {\r\n    /**\r\n     * User provided buttons to enable/disable WebXR. The system will provide default if not set\r\n     */\r\n    customButtons?: Array<WebXREnterExitUIButton>;\r\n    /**\r\n     * A reference space type to use when creating the default button.\r\n     * Default is local-floor\r\n     */\r\n    referenceSpaceType?: XRReferenceSpaceType;\r\n    /**\r\n     * Context to enter xr with\r\n     */\r\n    renderTarget?: Nullable<WebXRRenderTarget>;\r\n    /**\r\n     * A session mode to use when creating the default button.\r\n     * Default is immersive-vr\r\n     */\r\n    sessionMode?: XRSessionMode;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     */\r\n    optionalFeatures?: string[];\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     */\r\n    requiredFeatures?: string[];\r\n\r\n    /**\r\n     * If set, the `sessiongranted` event will not be registered. `sessiongranted` is used to move seamlessly between WebXR experiences.\r\n     * If set to true the user will be forced to press the \"enter XR\" button even if sessiongranted event was triggered.\r\n     * If not set and a sessiongranted event was triggered, the XR session will start automatically.\r\n     */\r\n    ignoreSessionGrantedEvent?: boolean;\r\n\r\n    /**\r\n     * If defined, this function will be executed if the UI encounters an error when entering XR\r\n     */\r\n    onError?: (error: any) => void;\r\n}\r\n/**\r\n * UI to allow the user to enter/exit XR mode\r\n */\r\nexport class WebXREnterExitUI implements IDisposable {\r\n    private _activeButton: Nullable<WebXREnterExitUIButton> = null;\r\n    private _buttons: Array<WebXREnterExitUIButton> = [];\r\n    private _helper: WebXRExperienceHelper;\r\n    private _renderTarget?: WebXRRenderTarget;\r\n    /**\r\n     * The HTML Div Element to which buttons are added.\r\n     */\r\n    public readonly overlay: HTMLDivElement;\r\n\r\n    /**\r\n     * Fired every time the active button is changed.\r\n     *\r\n     * When xr is entered via a button that launches xr that button will be the callback parameter\r\n     *\r\n     * When exiting xr the callback parameter will be null)\r\n     */\r\n    public activeButtonChangedObservable = new Observable<Nullable<WebXREnterExitUIButton>>();\r\n\r\n    /**\r\n     * Construct a new EnterExit UI class\r\n     *\r\n     * @param _scene babylon scene object to use\r\n     * @param options (read-only) version of the options passed to this UI\r\n     */\r\n    public constructor(\r\n        private _scene: Scene,\r\n        /** version of the options passed to this UI */\r\n        public options: WebXREnterExitUIOptions\r\n    ) {\r\n        this.overlay = document.createElement(\"div\");\r\n        this.overlay.classList.add(\"xr-button-overlay\");\r\n\r\n        // prepare for session granted event\r\n        if (!options.ignoreSessionGrantedEvent && (navigator as any).xr) {\r\n            (navigator as any).xr.addEventListener(\"sessiongranted\", this._onSessionGranted);\r\n        }\r\n\r\n        // if served over HTTP, warn people.\r\n        // Hopefully the browsers will catch up\r\n        if (typeof window !== \"undefined\") {\r\n            if (window.location && window.location.protocol === \"http:\" && window.location.hostname !== \"localhost\") {\r\n                Tools.Warn(\"WebXR can only be served over HTTPS\");\r\n                throw new Error(\"WebXR can only be served over HTTPS\");\r\n            }\r\n        }\r\n\r\n        if (options.customButtons) {\r\n            this._buttons = options.customButtons;\r\n        } else {\r\n            this.overlay.style.cssText = \"z-index:11;position: absolute; right: 20px;bottom: 50px;\";\r\n            const sessionMode = options.sessionMode || \"immersive-vr\";\r\n            const referenceSpaceType = options.referenceSpaceType || \"local-floor\";\r\n            const url =\r\n                typeof SVGSVGElement === \"undefined\"\r\n                    ? \"https://cdn.babylonjs.com/Assets/vrButton.png\"\r\n                    : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\r\n            let css =\r\n                \".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n                url +\r\n                \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\r\n            css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: \"EXIT\"} .xr-error::after { content: \"ERROR\"}';\r\n\r\n            const style = document.createElement(\"style\");\r\n            style.appendChild(document.createTextNode(css));\r\n            document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n            const hmdBtn = document.createElement(\"button\");\r\n            hmdBtn.className = \"babylonVRicon\";\r\n            hmdBtn.title = `${sessionMode} - ${referenceSpaceType}`;\r\n            this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));\r\n            this._buttons[this._buttons.length - 1].update = function (activeButton: WebXREnterExitUIButton) {\r\n                this.element.style.display = activeButton === null || activeButton === this ? \"\" : \"none\";\r\n                hmdBtn.className = \"babylonVRicon\" + (activeButton === this ? \" vrdisplaypresenting\" : \"\");\r\n            };\r\n            this._updateButtons(null);\r\n        }\r\n\r\n        const renderCanvas = _scene.getEngine().getInputElement();\r\n        if (renderCanvas && renderCanvas.parentNode) {\r\n            renderCanvas.parentNode.appendChild(this.overlay);\r\n            _scene.onDisposeObservable.addOnce(() => {\r\n                this.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the helper to be used with this UI component.\r\n     * The UI is bound to an experience helper. If not provided the UI can still be used but the events should be registered by the developer.\r\n     *\r\n     * @param helper the experience helper to attach\r\n     * @param renderTarget an optional render target (in case it is created outside of the helper scope)\r\n     * @returns a promise that resolves when the ui is ready\r\n     */\r\n    public async setHelperAsync(helper: WebXRExperienceHelper, renderTarget?: WebXRRenderTarget): Promise<void> {\r\n        this._helper = helper;\r\n        this._renderTarget = renderTarget;\r\n        const supportedPromises = this._buttons.map((btn) => {\r\n            return helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);\r\n        });\r\n        helper.onStateChangedObservable.add((state) => {\r\n            if (state == WebXRState.NOT_IN_XR) {\r\n                this._updateButtons(null);\r\n            }\r\n        });\r\n        const results = await Promise.all(supportedPromises);\r\n        results.forEach((supported, i) => {\r\n            if (supported) {\r\n                this.overlay.appendChild(this._buttons[i].element);\r\n                this._buttons[i].element.onclick = this._enterXRWithButtonIndex.bind(this, i);\r\n            } else {\r\n                Tools.Warn(`Session mode \"${this._buttons[i].sessionMode}\" not supported in browser`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates UI to allow the user to enter/exit XR mode\r\n     * @param scene the scene to add the ui to\r\n     * @param helper the xr experience helper to enter/exit xr with\r\n     * @param options options to configure the UI\r\n     * @returns the created ui\r\n     */\r\n    public static async CreateAsync(scene: Scene, helper: WebXRExperienceHelper, options: WebXREnterExitUIOptions): Promise<WebXREnterExitUI> {\r\n        const ui = new WebXREnterExitUI(scene, options);\r\n        await ui.setHelperAsync(helper, options.renderTarget || undefined);\r\n        return ui;\r\n    }\r\n\r\n    private async _enterXRWithButtonIndex(idx: number = 0) {\r\n        if (this._helper.state == WebXRState.IN_XR) {\r\n            await this._helper.exitXRAsync();\r\n            this._updateButtons(null);\r\n        } else if (this._helper.state == WebXRState.NOT_IN_XR) {\r\n            try {\r\n                await this._helper.enterXRAsync(this._buttons[idx].sessionMode, this._buttons[idx].referenceSpaceType, this._renderTarget, {\r\n                    optionalFeatures: this.options.optionalFeatures,\r\n                    requiredFeatures: this.options.requiredFeatures,\r\n                });\r\n                this._updateButtons(this._buttons[idx]);\r\n            } catch (e) {\r\n                // make sure button is visible\r\n                this._updateButtons(null);\r\n                const element = this._buttons[idx].element;\r\n                const prevTitle = element.title;\r\n                element.title = \"Error entering XR session : \" + prevTitle;\r\n                element.classList.add(\"xr-error\");\r\n                if (this.options.onError) {\r\n                    this.options.onError(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the XR UI component\r\n     */\r\n    public dispose() {\r\n        const renderCanvas = this._scene.getEngine().getInputElement();\r\n        if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {\r\n            renderCanvas.parentNode.removeChild(this.overlay);\r\n        }\r\n        this.activeButtonChangedObservable.clear();\r\n        (navigator as any).xr.removeEventListener(\"sessiongranted\", this._onSessionGranted);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _onSessionGranted = (evt: { session: XRSession }) => {\r\n        // This section is for future reference.\r\n        // As per specs, evt.session.mode should have the supported session mode, but no browser supports it for now.\r\n\r\n        // // check if the session granted is the same as the one requested\r\n        // const grantedMode = (evt.session as any).mode;\r\n        // if (grantedMode) {\r\n        //     this._buttons.some((btn, idx) => {\r\n        //         if (btn.sessionMode === grantedMode) {\r\n        //             this._enterXRWithButtonIndex(idx);\r\n        //             return true;\r\n        //         }\r\n        //         return false;\r\n        //     });\r\n        // } else\r\n\r\n        if (this._helper) {\r\n            this._enterXRWithButtonIndex(0);\r\n        }\r\n    };\r\n\r\n    private _updateButtons(activeButton: Nullable<WebXREnterExitUIButton>) {\r\n        this._activeButton = activeButton;\r\n        this._buttons.forEach((b) => {\r\n            b.update(this._activeButton);\r\n        });\r\n        this.activeButtonChangedObservable.notifyObservers(this._activeButton);\r\n    }\r\n}\r\n", "import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * @returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (false as default)\r\n     * @param stride defines the vertex stride (optional)\r\n     * @returns the current mesh\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)\r\n     * @returns the source mesh\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices the source data\r\n     * @param totalVertices defines the total number of vertices referenced by indices (could be null)\r\n     * @returns source mesh\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns true if data kind is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * @returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera defines the camera to use to pick the LOD level\r\n     * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n    }\r\n\r\n    if (!this._userInstancedBuffersStorage) {\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#include<fogFragment>(color,gl_FragColor)\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform mat4 view;\n#endif\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            const { x, y, z } = points[index];\r\n            positions.push(x, y, z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                const { r, g, b, a } = color[index];\r\n                vertexColors.push(r, g, b, a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * Construction options for a timer\r\n */\r\nexport interface ITimerOptions<T> {\r\n    /**\r\n     * Time-to-end\r\n     */\r\n    timeout: number;\r\n    /**\r\n     * The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.\r\n     * Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if\r\n     * you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time\r\n     */\r\n    contextObservable: Observable<T>;\r\n    /**\r\n     * Optional parameters when adding an observer to the observable\r\n     */\r\n    observableParameters?: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    /**\r\n     * An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!\r\n     */\r\n    breakCondition?: (data?: ITimerData<T>) => boolean;\r\n    /**\r\n     * Will be triggered when the time condition has met\r\n     */\r\n    onEnded?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Will be triggered when the break condition has met (prematurely ended)\r\n     */\r\n    onAborted?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Optional function to execute on each tick (or count)\r\n     */\r\n    onTick?: (data: ITimerData<any>) => void;\r\n}\r\n\r\n/**\r\n * An interface defining the data sent by the timer\r\n */\r\nexport interface ITimerData<T> {\r\n    /**\r\n     * When did it start\r\n     */\r\n    startTime: number;\r\n    /**\r\n     * Time now\r\n     */\r\n    currentTime: number;\r\n    /**\r\n     * Time passed since started\r\n     */\r\n    deltaTime: number;\r\n    /**\r\n     * How much is completed, in [0.0...1.0].\r\n     * Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls\r\n     */\r\n    completeRate: number;\r\n    /**\r\n     * What the registered observable sent in the last count\r\n     */\r\n    payload: T;\r\n}\r\n\r\n/**\r\n * The current state of the timer\r\n */\r\nexport enum TimerState {\r\n    /**\r\n     * Timer initialized, not yet started\r\n     */\r\n    INIT,\r\n    /**\r\n     * Timer started and counting\r\n     */\r\n    STARTED,\r\n    /**\r\n     * Timer ended (whether aborted or time reached)\r\n     */\r\n    ENDED,\r\n}\r\n\r\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n * @returns an observer that can be used to stop the timer\r\n */\r\nexport function setAndStartTimer<T = any>(options: ITimerOptions<T>): Nullable<Observer<T>> {\r\n    let timer = 0;\r\n    const startTime = Date.now();\r\n    options.observableParameters = options.observableParameters ?? {};\r\n    const observer = options.contextObservable.add(\r\n        (payload: any) => {\r\n            const now = Date.now();\r\n            timer = now - startTime;\r\n            const data: ITimerData<any> = {\r\n                startTime,\r\n                currentTime: now,\r\n                deltaTime: timer,\r\n                completeRate: timer / options.timeout,\r\n                payload,\r\n            };\r\n            options.onTick && options.onTick(data);\r\n            if (options.breakCondition && options.breakCondition()) {\r\n                options.contextObservable.remove(observer);\r\n                options.onAborted && options.onAborted(data);\r\n            }\r\n            if (timer >= options.timeout) {\r\n                options.contextObservable.remove(observer);\r\n                options.onEnded && options.onEnded(data);\r\n            }\r\n        },\r\n        options.observableParameters.mask,\r\n        options.observableParameters.insertFirst,\r\n        options.observableParameters.scope\r\n    );\r\n    return observer;\r\n}\r\n\r\n/**\r\n * An advanced implementation of a timer class\r\n */\r\nexport class AdvancedTimer<T = any> implements IDisposable {\r\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\r\n    public onEachCountObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\r\n    public onTimerAbortedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\r\n    public onTimerEndedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\r\n    public onStateChangedObservable: Observable<TimerState> = new Observable();\r\n\r\n    private _observer: Nullable<Observer<T>> = null;\r\n    private _contextObservable: Observable<T>;\r\n    private _observableParameters: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    private _startTime: number;\r\n    private _timer: number;\r\n    private _state: TimerState;\r\n    private _breakCondition: (data: ITimerData<T>) => boolean;\r\n    private _timeToEnd: number;\r\n    private _breakOnNextTick: boolean = false;\r\n\r\n    /**\r\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n     * @param options construction options for this advanced timer\r\n     */\r\n    constructor(options: ITimerOptions<T>) {\r\n        this._setState(TimerState.INIT);\r\n        this._contextObservable = options.contextObservable;\r\n        this._observableParameters = options.observableParameters ?? {};\r\n        this._breakCondition = options.breakCondition ?? (() => false);\r\n        this._timeToEnd = options.timeout;\r\n        if (options.onEnded) {\r\n            this.onTimerEndedObservable.add(options.onEnded);\r\n        }\r\n        if (options.onTick) {\r\n            this.onEachCountObservable.add(options.onTick);\r\n        }\r\n        if (options.onAborted) {\r\n            this.onTimerAbortedObservable.add(options.onAborted);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\r\n    public set breakCondition(predicate: (data: ITimerData<T>) => boolean) {\r\n        this._breakCondition = predicate;\r\n    }\r\n\r\n    /**\r\n     * Reset ALL associated observables in this advanced timer\r\n     */\r\n    public clearObservables() {\r\n        this.onEachCountObservable.clear();\r\n        this.onTimerAbortedObservable.clear();\r\n        this.onTimerEndedObservable.clear();\r\n        this.onStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n     *\r\n     * @param timeToEnd how much time to measure until timer ended\r\n     */\r\n    public start(timeToEnd: number = this._timeToEnd) {\r\n        if (this._state === TimerState.STARTED) {\r\n            throw new Error(\"Timer already started. Please stop it before starting again\");\r\n        }\r\n        this._timeToEnd = timeToEnd;\r\n        this._startTime = Date.now();\r\n        this._timer = 0;\r\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\r\n        this._setState(TimerState.STARTED);\r\n    }\r\n\r\n    /**\r\n     * Will force a stop on the next tick.\r\n     */\r\n    public stop() {\r\n        if (this._state !== TimerState.STARTED) {\r\n            return;\r\n        }\r\n        this._breakOnNextTick = true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this timer, clearing all resources\r\n     */\r\n    public dispose() {\r\n        if (this._observer) {\r\n            this._contextObservable.remove(this._observer);\r\n        }\r\n        this.clearObservables();\r\n    }\r\n\r\n    private _setState(newState: TimerState) {\r\n        this._state = newState;\r\n        this.onStateChangedObservable.notifyObservers(this._state);\r\n    }\r\n\r\n    private _tick = (payload: T) => {\r\n        const now = Date.now();\r\n        this._timer = now - this._startTime;\r\n        const data: ITimerData<T> = {\r\n            startTime: this._startTime,\r\n            currentTime: now,\r\n            deltaTime: this._timer,\r\n            completeRate: this._timer / this._timeToEnd,\r\n            payload,\r\n        };\r\n        const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\r\n        if (shouldBreak || this._timer >= this._timeToEnd) {\r\n            this._stop(data, shouldBreak);\r\n        } else {\r\n            this.onEachCountObservable.notifyObservers(data);\r\n        }\r\n    };\r\n\r\n    private _stop(data: ITimerData<T>, aborted: boolean = false) {\r\n        this._contextObservable.remove(this._observer);\r\n        this._setState(TimerState.ENDED);\r\n        if (aborted) {\r\n            this.onTimerAbortedObservable.notifyObservers(data);\r\n        } else {\r\n            this.onTimerEndedObservable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n", "import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n        /**\r\n         * Override the default material of the Landing Zone\r\n         */\r\n        teleportationCircleMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long in milliseconds should the \"long press\" take before teleport. Defaults to 3 seconds\r\n     */\r\n    timeToTeleport?: number;\r\n\r\n    /**\r\n     * If the main component is used, how long in milliseconds should the \"long press\" take before teleport starts. Defaults to 0\r\n     */\r\n    timeToTeleportStart?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * define an optional predicate to select which meshes should block the teleportation ray\r\n     */\r\n    blockerMeshesPredicate?: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Should the teleportation ray be blocked by all of the scene's pickable meshes?\r\n     * Defaults to false\r\n     */\r\n    blockAllPickableMeshes?: boolean;\r\n\r\n    /**\r\n     * Color of the teleportation ray when it is blocked by a mesh in the pickBlockerMeshes array\r\n     * Defaults to red.\r\n     */\r\n    blockedRayColor?: Color4;\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n                blocked: boolean;\r\n                initialHit: boolean;\r\n                mainComponentUsed: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _blockedRayColor: Color4;\r\n    private _cachedColor4White = new Color4(1, 1, 1, 1);\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>> = null;\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Observable raised before camera rotation\r\n     */\r\n    public onBeforeCameraTeleportRotation = new Observable<Number>();\r\n\r\n    /**\r\n     *  Observable raised after camera rotation\r\n     */\r\n    public onAfterCameraTeleportRotation = new Observable<Quaternion>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport: Observable<Vector3>;\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport: Observable<Vector3>;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: IWebXRTeleportationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n        this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\r\n\r\n        this._setTargetMeshVisibility(false);\r\n\r\n        // set the observables\r\n        this.onBeforeCameraTeleport = _options.xrInput.xrCamera.onBeforeCameraTeleport;\r\n        this.onAfterCameraTeleport = _options.xrInput.xrCamera.onAfterCameraTeleport;\r\n\r\n        this.parabolicCheckRadius *= this._xrSessionManager.worldScalingFactor;\r\n        this._worldScaleObserver = _xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {\r\n            this.parabolicCheckRadius = (this.parabolicCheckRadius / values.previousScaleFactor) * values.newScaleFactor;\r\n            this._options.teleportationTargetMesh?.scaling.scaleInPlace(values.newScaleFactor / values.previousScaleFactor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n        if (this._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                const controlSelectionFeature = controllerData.xrController.inputSource.targetRayMode !== \"transient-pointer\";\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\r\n                            return true;\r\n                        }\r\n                        if (this._options.blockAllPickableMeshes && o.isPickable) {\r\n                            return true;\r\n                        }\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\r\n                    if (pick && pick.pickedMesh && !floorMeshPicked) {\r\n                        if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\r\n                            controllerData.teleportationState.forward = false;\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.initialHit = true;\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\r\n                            return true;\r\n                        }\r\n                        if (this._options.blockAllPickableMeshes && o.isPickable) {\r\n                            return true;\r\n                        }\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\r\n                    if (pick && pick.pickedMesh && !floorMeshPicked) {\r\n                        if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\r\n                            controllerData.teleportationState.forward = false;\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.initialHit = true;\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible, false, controlSelectionFeature);\r\n            } else {\r\n                this._setTargetMeshVisibility(false, false, true);\r\n            }\r\n        } else {\r\n            this._disposeBezierCurve();\r\n            this._setTargetMeshVisibility(false, false, true);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n                blocked: false,\r\n                initialHit: false,\r\n                mainComponentUsed: false,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.mainComponentUsed = true;\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n\r\n                            const teleportLocal = () => {\r\n                                // simulate \"forward\" thumbstick push\r\n                                controllerData.teleportationState.forward = true;\r\n                                controllerData.teleportationState.initialHit = false;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                controllerData.teleportationState.currentRotation = 0;\r\n                                const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                setAndStartTimer({\r\n                                    timeout: timeToSelect,\r\n                                    contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                    breakCondition: () => !mainComponent.pressed,\r\n                                    onEnded: () => {\r\n                                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                            this._teleportForward(xrController.uniqueId);\r\n                                        }\r\n                                    },\r\n                                });\r\n                            };\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // delay if the start time is defined\r\n                                    if (this._options.timeToTeleportStart) {\r\n                                        setAndStartTimer({\r\n                                            timeout: this._options.timeToTeleportStart,\r\n                                            contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                            onEnded: () => {\r\n                                                // check if still pressed\r\n                                                if (mainComponent.pressed) {\r\n                                                    teleportLocal();\r\n                                                }\r\n                                            },\r\n                                        });\r\n                                    } else {\r\n                                        teleportLocal();\r\n                                    }\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        this.onBeforeCameraTeleportRotation.notifyObservers(rotation);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                        this.onAfterCameraTeleportRotation.notifyObservers(this._options.xrInput.xrCamera.rotationQuaternion);\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.blocked) {\r\n                                    controllerData.teleportationState.blocked = false;\r\n                                    this._setTargetMeshVisibility(false);\r\n                                }\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            controllerData.teleportationState.mainComponentUsed = true;\r\n            let breakObserver = false;\r\n            const teleportLocal = () => {\r\n                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                controllerData.teleportationState.forward = true;\r\n                controllerData.teleportationState.initialHit = false;\r\n                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                controllerData.teleportationState.currentRotation = 0;\r\n                const timeToSelect = this._options.timeToTeleport || 3000;\r\n                setAndStartTimer({\r\n                    timeout: timeToSelect,\r\n                    contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                    onEnded: () => {\r\n                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                            this._teleportForward(xrController.uniqueId);\r\n                        }\r\n                    },\r\n                });\r\n            };\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    breakObserver = false;\r\n                    // check if start time is defined\r\n                    if (this._options.timeToTeleportStart) {\r\n                        setAndStartTimer({\r\n                            timeout: this._options.timeToTeleportStart,\r\n                            contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                            onEnded: () => {\r\n                                // make sure pointer up was not triggered during this time\r\n                                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                    teleportLocal();\r\n                                }\r\n                            },\r\n                            breakCondition: () => {\r\n                                if (breakObserver) {\r\n                                    breakObserver = false;\r\n                                    return true;\r\n                                }\r\n                                return false;\r\n                            },\r\n                        });\r\n                    } else {\r\n                        teleportLocal();\r\n                    }\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    breakObserver = true;\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n\r\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\r\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\r\n        } else {\r\n            const length = 512;\r\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n            dynamicTexture.hasAlpha = true;\r\n            const context = dynamicTexture.getContext();\r\n            const centerX = length / 2;\r\n            const centerY = length / 2;\r\n            const radius = 200;\r\n            context.beginPath();\r\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n            context.fill();\r\n            context.lineWidth = 10;\r\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n            context.stroke();\r\n            context.closePath();\r\n            dynamicTexture.update();\r\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n            teleportationTarget.material = teleportationCircleMaterial;\r\n        }\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys: { frame: number; value: number }[] = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n        this._options.teleportationTargetMesh.scaling.setAll(this._xrSessionManager.worldScalingFactor);\r\n        // hide the teleportation target mesh right after creating it.\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean, force?: boolean, controlSelectionFeature?: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature && controlSelectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature && controlSelectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disposeBezierCurve() {\r\n        if (this._quadraticBezierCurve) {\r\n            this._quadraticBezierCurve.dispose();\r\n            this._quadraticBezierCurve = null;\r\n        }\r\n    }\r\n\r\n    private _colorArray: Color4[] = Array(24).fill(this._cachedColor4White);\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\r\n        const colorsArray = this._colorArray.fill(color || this._cachedColor4White);\r\n        // take out the first 2 points, to not start directly from the controller\r\n        const points = quadraticBezierVectors.getPoints();\r\n        points.shift();\r\n        points.shift();\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: points, instance: this._quadraticBezierCurve as LinesMesh, updatable: true, colors: colorsArray },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n", "import { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IWebXRInputOptions } from \"./webXRInput\";\r\nimport { WebXRInput } from \"./webXRInput\";\r\nimport type { IWebXRControllerPointerSelectionOptions } from \"./features/WebXRControllerPointerSelection\";\r\nimport { WebXRControllerPointerSelection } from \"./features/WebXRControllerPointerSelection\";\r\nimport type { IWebXRNearInteractionOptions } from \"./features/WebXRNearInteraction\";\r\nimport { WebXRNearInteraction } from \"./features/WebXRNearInteraction\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXREnterExitUIOptions } from \"./webXREnterExitUI\";\r\nimport { WebXREnterExitUI } from \"./webXREnterExitUI\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { IWebXRTeleportationOptions } from \"./features/WebXRControllerTeleportation\";\r\nimport { WebXRHandTracking, type IWebXRHandTrackingOptions } from \"./features/WebXRHandTracking\";\r\nimport { WebXRMotionControllerTeleportation } from \"./features/WebXRControllerTeleportation\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Options for the default xr helper\r\n */\r\nexport class WebXRDefaultExperienceOptions {\r\n    /**\r\n     * Enable or disable default UI to enter XR\r\n     */\r\n    public disableDefaultUI?: boolean;\r\n    /**\r\n     * Should pointer selection not initialize.\r\n     * Note that disabling pointer selection also disables teleportation.\r\n     * Defaults to false.\r\n     */\r\n    public disablePointerSelection?: boolean;\r\n    /**\r\n     * Should teleportation not initialize. Defaults to false.\r\n     */\r\n    public disableTeleportation?: boolean;\r\n    /**\r\n     * Should nearInteraction not initialize. Defaults to false.\r\n     */\r\n    public disableNearInteraction?: boolean;\r\n\r\n    /**\r\n     * Should hand tracking be disabled. Defaults to false.\r\n     */\r\n    public disableHandTracking?: boolean;\r\n    /**\r\n     * Floor meshes that will be used for teleport\r\n     */\r\n    public floorMeshes?: Array<AbstractMesh>;\r\n    /**\r\n     * If set to true, the first frame will not be used to reset position\r\n     * The first frame is mainly used when copying transformation from the old camera\r\n     * Mainly used in AR\r\n     */\r\n    public ignoreNativeCameraTransformation?: boolean;\r\n    /**\r\n     * Optional configuration for the XR input object\r\n     */\r\n    public inputOptions?: Partial<IWebXRInputOptions>;\r\n    /**\r\n     * optional configuration for pointer selection\r\n     */\r\n    public pointerSelectionOptions?: Partial<IWebXRControllerPointerSelectionOptions>;\r\n    /**\r\n     * optional configuration for near interaction\r\n     */\r\n    public nearInteractionOptions?: Partial<IWebXRNearInteractionOptions>;\r\n\r\n    /**\r\n     * optional configuration for hand tracking\r\n     */\r\n    public handSupportOptions?: Partial<IWebXRHandTrackingOptions>;\r\n    /**\r\n     * optional configuration for teleportation\r\n     */\r\n    public teleportationOptions?: Partial<IWebXRTeleportationOptions>;\r\n    /**\r\n     * optional configuration for the output canvas\r\n     */\r\n    public outputCanvasOptions?: WebXRManagedOutputCanvasOptions;\r\n    /**\r\n     * optional UI options. This can be used among other to change session mode and reference space type\r\n     */\r\n    public uiOptions?: Partial<WebXREnterExitUIOptions>;\r\n    /**\r\n     * When loading teleportation and pointer select, use stable versions instead of latest.\r\n     */\r\n    public useStablePlugins?: boolean;\r\n\r\n    /**\r\n     * An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes\r\n     */\r\n    public renderingGroupId?: number;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     * If set to true, all features we support will be added\r\n     */\r\n    public optionalFeatures?: boolean | string[];\r\n}\r\n\r\n/**\r\n * Default experience for webxr\r\n */\r\nexport class WebXRDefaultExperience {\r\n    /**\r\n     * Base experience\r\n     */\r\n    public baseExperience: WebXRExperienceHelper;\r\n    /**\r\n     * Enables ui for entering/exiting xr\r\n     */\r\n    public enterExitUI: WebXREnterExitUI;\r\n    /**\r\n     * Input experience extension\r\n     */\r\n    public input: WebXRInput;\r\n    /**\r\n     * Enables laser pointer and selection\r\n     */\r\n    public pointerSelection: WebXRControllerPointerSelection;\r\n    /**\r\n     * Default target xr should render to\r\n     */\r\n    public renderTarget: WebXRRenderTarget;\r\n    /**\r\n     * Enables teleportation\r\n     */\r\n    public teleportation: WebXRMotionControllerTeleportation;\r\n\r\n    /**\r\n     * Enables near interaction for hands/controllers\r\n     */\r\n    public nearInteraction: WebXRNearInteraction;\r\n\r\n    private constructor() {}\r\n\r\n    /**\r\n     * Creates the default xr experience\r\n     * @param scene scene\r\n     * @param options options for basic configuration\r\n     * @returns resulting WebXRDefaultExperience\r\n     */\r\n    public static CreateAsync(scene: Scene, options: WebXRDefaultExperienceOptions = {}) {\r\n        const result = new WebXRDefaultExperience();\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            result.dispose();\r\n        });\r\n        // init the UI right after construction\r\n        if (!options.disableDefaultUI) {\r\n            const uiOptions: WebXREnterExitUIOptions = {\r\n                renderTarget: result.renderTarget,\r\n                ...(options.uiOptions || {}),\r\n            };\r\n            if (options.optionalFeatures) {\r\n                if (typeof options.optionalFeatures === \"boolean\") {\r\n                    uiOptions.optionalFeatures = [\"hit-test\", \"anchors\", \"plane-detection\", \"hand-tracking\"];\r\n                } else {\r\n                    uiOptions.optionalFeatures = options.optionalFeatures;\r\n                }\r\n            }\r\n            result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);\r\n        }\r\n\r\n        // Create base experience\r\n        return WebXRExperienceHelper.CreateAsync(scene)\r\n            .then((xrHelper) => {\r\n                result.baseExperience = xrHelper;\r\n\r\n                if (options.ignoreNativeCameraTransformation) {\r\n                    result.baseExperience.camera.compensateOnFirstFrame = false;\r\n                }\r\n\r\n                // Add controller support\r\n                result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {\r\n                    controllerOptions: {\r\n                        renderingGroupId: options.renderingGroupId,\r\n                    },\r\n                    ...(options.inputOptions || {}),\r\n                });\r\n\r\n                if (!options.disablePointerSelection) {\r\n                    // Add default pointer selection\r\n                    const pointerSelectionOptions = {\r\n                        ...options.pointerSelectionOptions,\r\n                        xrInput: result.input,\r\n                        renderingGroupId: options.renderingGroupId,\r\n                    };\r\n\r\n                    result.pointerSelection = <WebXRControllerPointerSelection>(\r\n                        result.baseExperience.featuresManager.enableFeature(\r\n                            WebXRControllerPointerSelection.Name,\r\n                            options.useStablePlugins ? \"stable\" : \"latest\",\r\n                            <IWebXRControllerPointerSelectionOptions>pointerSelectionOptions\r\n                        )\r\n                    );\r\n\r\n                    if (!options.disableTeleportation) {\r\n                        // Add default teleportation, including rotation\r\n                        result.teleportation = <WebXRMotionControllerTeleportation>result.baseExperience.featuresManager.enableFeature(\r\n                            WebXRMotionControllerTeleportation.Name,\r\n                            options.useStablePlugins ? \"stable\" : \"latest\",\r\n                            <IWebXRTeleportationOptions>{\r\n                                floorMeshes: options.floorMeshes,\r\n                                xrInput: result.input,\r\n                                renderingGroupId: options.renderingGroupId,\r\n                                ...options.teleportationOptions,\r\n                            }\r\n                        );\r\n                        result.teleportation.setSelectionFeature(result.pointerSelection);\r\n                    }\r\n                }\r\n\r\n                if (!options.disableNearInteraction) {\r\n                    // Add default pointer selection\r\n                    result.nearInteraction = <WebXRNearInteraction>result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRNearInteraction.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRNearInteractionOptions>{\r\n                            xrInput: result.input,\r\n                            farInteractionFeature: result.pointerSelection,\r\n                            renderingGroupId: options.renderingGroupId,\r\n                            useUtilityLayer: true,\r\n                            enableNearInteractionOnAllControllers: true,\r\n                            ...options.nearInteractionOptions,\r\n                        }\r\n                    );\r\n                }\r\n\r\n                if (!options.disableHandTracking) {\r\n                    // Add default hand tracking\r\n                    result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRHandTracking.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRHandTrackingOptions>{\r\n                            xrInput: result.input,\r\n                            ...options.handSupportOptions,\r\n                        },\r\n                        undefined,\r\n                        false\r\n                    );\r\n                }\r\n\r\n                // Create the WebXR output target\r\n                result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);\r\n\r\n                if (!options.disableDefaultUI) {\r\n                    // Create ui for entering/exiting xr\r\n                    return result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);\r\n                } else {\r\n                    return;\r\n                }\r\n            })\r\n            .then(() => {\r\n                return result;\r\n            })\r\n            .catch((error) => {\r\n                Logger.Error(\"Error initializing XR\");\r\n                Logger.Error(error);\r\n                return result;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        if (this.baseExperience) {\r\n            this.baseExperience.dispose();\r\n        }\r\n        if (this.input) {\r\n            this.input.dispose();\r\n        }\r\n        if (this.enterExitUI) {\r\n            this.enterExitUI.dispose();\r\n        }\r\n        if (this.renderTarget) {\r\n            this.renderTarget.dispose();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a", "rejectionReason", "name", "_CameraProperty", "name", "WebXRState", "WebXRTrackingState", "name", "i", "name", "Xbox360Button", "Xbox360Dpad", "DualShockButton", "DualShockDpad", "name", "name", "name", "controllerCache", "pose", "radius", "angle", "i", "v", "name", "name", "ControllerOrbAnimationState", "WebXRNearControllerMode", "touchCollisionMesh", "touchCollisionMeshFunction", "hydrateCollisionMeshFunction", "name", "name", "shader", "shader", "name", "name", "dashSize", "gapSize", "TimerState", "name"]
}
