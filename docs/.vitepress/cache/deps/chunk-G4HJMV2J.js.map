{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.constants.ts", "../../../dev/core/src/Misc/arrayTools.ts", "../../../dev/core/src/Maths/math.scalar.functions.ts"],
  "sourcesContent": ["/**\r\n * Constant used to convert a value to gamma space\r\n * @ignorenaming\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const ToGammaSpace = 1 / 2.2;\r\n\r\n/**\r\n * Constant used to convert a value to linear space\r\n * @ignorenaming\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const ToLinearSpace = 2.2;\r\n\r\n/**\r\n * Constant Golden Ratio value in Babylon.js\r\n * @ignorenaming\r\n */\r\nexport const PHI = (1 + Math.sqrt(5)) / 2;\r\n\r\n/**\r\n * Constant used to define the minimal number value in Babylon.js\r\n * @ignorenaming\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst Epsilon = 0.001;\r\nexport { Epsilon };\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport type { Nullable, Tuple } from \"../types\";\r\n\r\n/**\r\n * Class containing a set of static utilities functions for arrays.\r\n */\r\nexport class ArrayTools {\r\n    /**\r\n     * Returns an array of the given size filled with elements built from the given constructor and the parameters.\r\n     * @param size the number of element to construct and put in the array.\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\r\n     * @returns a new array filled with new objects.\r\n     */\r\n    public static BuildArray<T>(size: number, itemBuilder: () => T): Array<T> {\r\n        const a: T[] = [];\r\n        for (let i = 0; i < size; ++i) {\r\n            a.push(itemBuilder());\r\n        }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.\r\n     * @param size he number of element to construct and put in the tuple.\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.\r\n     * @returns a new tuple filled with new objects.\r\n     */\r\n    public static BuildTuple<T, N extends number>(size: N, itemBuilder: () => T): Tuple<T, N> {\r\n        return ArrayTools.BuildArray(size, itemBuilder) as any;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the callback type used when an observed array function is triggered.\r\n * @internal\r\n */\r\nexport type _ObserveCallback = (functionName: string, previousLength: number) => void;\r\n\r\n/**\r\n * Observes a function and calls the given callback when it is called.\r\n * @param object Defines the object the function to observe belongs to.\r\n * @param functionName Defines the name of the function to observe.\r\n * @param callback Defines the callback to call when the function is called.\r\n * @returns A function to call to stop observing\r\n */\r\nfunction _observeArrayfunction(object: { [key: string]: any }, functionName: string, callback: _ObserveCallback): Nullable<() => void> {\r\n    // Finds the function to observe\r\n    const oldFunction = object[functionName];\r\n    if (typeof oldFunction !== \"function\") {\r\n        return null;\r\n    }\r\n\r\n    // Creates a new function that calls the callback and the old function\r\n    const newFunction = function () {\r\n        const previousLength = object.length;\r\n        const returnValue = newFunction.previous.apply(object, arguments);\r\n        callback(functionName, previousLength);\r\n        return returnValue;\r\n    } as any;\r\n\r\n    // Doublishly links the new function and the old function\r\n    oldFunction.next = newFunction;\r\n    newFunction.previous = oldFunction;\r\n\r\n    // Replaces the old function with the new function\r\n    object[functionName] = newFunction;\r\n\r\n    // Returns a function to disable the hook\r\n    return () => {\r\n        // Only unhook if the function is still hooked\r\n        const previous = newFunction.previous;\r\n        if (!previous) {\r\n            return;\r\n        }\r\n\r\n        // Finds the ref to the next function in the chain\r\n        const next = newFunction.next;\r\n\r\n        // If in the middle of the chain, link the previous and next functions\r\n        if (next) {\r\n            previous.next = next;\r\n            next.previous = previous;\r\n        }\r\n        // If at the end of the chain, remove the reference to the previous function\r\n        // and restore the previous function\r\n        else {\r\n            previous.next = undefined;\r\n            object[functionName] = previous;\r\n        }\r\n\r\n        // Lose reference to the previous and next functions\r\n        newFunction.next = undefined;\r\n        newFunction.previous = undefined;\r\n    };\r\n}\r\n\r\n/**\r\n * Defines the list of functions to proxy when observing an array.\r\n * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.\r\n */\r\nconst observedArrayFunctions = [\"push\", \"splice\", \"pop\", \"shift\", \"unshift\"];\r\n\r\n/**\r\n * Observes an array and notifies the given observer when the array is modified.\r\n * @param array Defines the array to observe\r\n * @param callback Defines the function to call when the array is modified (in the limit of the observed array functions)\r\n * @returns A function to call to stop observing the array\r\n * @internal\r\n */\r\nexport function _ObserveArray<T>(array: T[], callback: _ObserveCallback) {\r\n    // Observes all the required array functions and stores the unhook functions\r\n    const unObserveFunctions = observedArrayFunctions.map((name) => {\r\n        return _observeArrayfunction(array, name, callback);\r\n    });\r\n\r\n    // Returns a function that unhook all the observed functions\r\n    return () => {\r\n        unObserveFunctions.forEach((unObserveFunction) => {\r\n            unObserveFunction?.();\r\n        });\r\n    };\r\n}\r\n", "/**\r\n * Extract int value\r\n * @param value number value\r\n * @returns int value\r\n */\r\nexport function ExtractAsInt(value: number) {\r\n    return parseInt(value.toString().replace(/\\W/g, \"\"));\r\n}\r\n\r\n/**\r\n * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n * @param a number\r\n * @param b number\r\n * @param epsilon (default = 1.401298E-45)\r\n * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n */\r\nexport function WithinEpsilon(a: number, b: number, epsilon: number = 1.401298e-45): boolean {\r\n    return Math.abs(a - b) <= epsilon;\r\n}\r\n\r\n/**\r\n * Returns a random float number between and min and max values\r\n * @param min min value of random\r\n * @param max max value of random\r\n * @returns random value\r\n */\r\nexport function RandomRange(min: number, max: number): number {\r\n    if (min === max) {\r\n        return min;\r\n    }\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n * @param start start value\r\n * @param end target value\r\n * @param amount amount to lerp between\r\n * @returns the lerped value\r\n */\r\nexport function Lerp(start: number, end: number, amount: number): number {\r\n    return start + (end - start) * amount;\r\n}\r\n\r\n/**\r\n * Returns the value itself if it's between min and max.\r\n * Returns min if the value is lower than min.\r\n * Returns max if the value is greater than max.\r\n * @param value the value to clmap\r\n * @param min the min value to clamp to (default: 0)\r\n * @param max the max value to clamp to (default: 1)\r\n * @returns the clamped value\r\n */\r\nexport function Clamp(value: number, min = 0, max = 1): number {\r\n    return Math.min(max, Math.max(min, value));\r\n}\r\n\r\n/**\r\n * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n * @param angle The angle to normalize in radian.\r\n * @returns The converted angle.\r\n */\r\nexport function NormalizeRadians(angle: number): number {\r\n    // More precise but slower version kept for reference.\r\n    // angle = angle % Tools.TwoPi;\r\n    // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n\r\n    //if (angle > Math.PI) {\r\n    //\tangle -= Tools.TwoPi;\r\n    //}\r\n\r\n    angle -= Math.PI * 2 * Math.floor((angle + Math.PI) / (Math.PI * 2));\r\n\r\n    return angle;\r\n}\r\n\r\n/**\r\n * Returns a string : the upper case translation of the number i to hexadecimal.\r\n * @param i number\r\n * @returns the upper case translation of the number i to hexadecimal.\r\n */\r\nexport function ToHex(i: number): string {\r\n    const str = i.toString(16);\r\n\r\n    if (i <= 15) {\r\n        return (\"0\" + str).toUpperCase();\r\n    }\r\n\r\n    return str.toUpperCase();\r\n}\r\n"],
  "mappings": ";;;;;AAAA,IAKa,cAOA,eAMA,KAOP;AAzBN;;AAKO,IAAM,eAAe,IAAI;AAOzB,IAAM,gBAAgB;AAMtB,IAAM,OAAO,IAAI,KAAK,KAAK,CAAC,KAAK;AAOxC,IAAM,UAAU;;;;;ACqBhB,SAAS,sBAAsB,QAAgC,cAAsB,UAA0B;AAE3G,QAAM,cAAc,OAAO,YAAY;AACvC,MAAI,OAAO,gBAAgB,YAAY;AACnC,WAAO;;AAIX,QAAM,cAAc,WAAA;AAChB,UAAM,iBAAiB,OAAO;AAC9B,UAAM,cAAc,YAAY,SAAS,MAAM,QAAQ,SAAS;AAChE,aAAS,cAAc,cAAc;AACrC,WAAO;EACX;AAGA,cAAY,OAAO;AACnB,cAAY,WAAW;AAGvB,SAAO,YAAY,IAAI;AAGvB,SAAO,MAAK;AAER,UAAM,WAAW,YAAY;AAC7B,QAAI,CAAC,UAAU;AACX;;AAIJ,UAAM,OAAO,YAAY;AAGzB,QAAI,MAAM;AACN,eAAS,OAAO;AAChB,WAAK,WAAW;WAIf;AACD,eAAS,OAAO;AAChB,aAAO,YAAY,IAAI;;AAI3B,gBAAY,OAAO;AACnB,gBAAY,WAAW;EAC3B;AACJ;AAeM,SAAU,cAAiB,OAAY,UAA0B;AAEnE,QAAM,qBAAqB,uBAAuB,IAAI,CAAC,SAAQ;AAC3D,WAAO,sBAAsB,OAAO,MAAM,QAAQ;EACtD,CAAC;AAGD,SAAO,MAAK;AACR,uBAAmB,QAAQ,CAAC,sBAAqB;AAC7C;IACJ,CAAC;EACL;AACJ;AA1HA,IAOa,YA8FP;AArGN;;AAOM,IAAO,aAAP,MAAO,YAAU;;;;;;;MAOZ,OAAO,WAAc,MAAc,aAAoB;AAC1D,cAAM,IAAS,CAAA;AACf,iBAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC3B,YAAE,KAAK,YAAW,CAAE;;AAExB,eAAO;MACX;;;;;;;MAQO,OAAO,WAAgC,MAAS,aAAoB;AACvE,eAAO,YAAW,WAAW,MAAM,WAAW;MAClD;;AAuEJ,IAAM,yBAAyB,CAAC,QAAQ,UAAU,OAAO,SAAS,SAAS;;;;;ACrFrE,SAAU,cAAc,GAAW,GAAW,UAAkB,aAAY;AAC9E,SAAO,KAAK,IAAI,IAAI,CAAC,KAAK;AAC9B;AAQM,SAAU,YAAY,KAAa,KAAW;AAChD,MAAI,QAAQ,KAAK;AACb,WAAO;;AAEX,SAAO,KAAK,OAAM,KAAM,MAAM,OAAO;AACzC;AASM,SAAU,KAAK,OAAe,KAAa,QAAc;AAC3D,SAAO,SAAS,MAAM,SAAS;AACnC;AAWM,SAAU,MAAM,OAAe,MAAM,GAAG,MAAM,GAAC;AACjD,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC;AAC7C;AAOM,SAAU,iBAAiB,OAAa;AAS1C,WAAS,KAAK,KAAK,IAAI,KAAK,OAAO,QAAQ,KAAK,OAAO,KAAK,KAAK,EAAE;AAEnE,SAAO;AACX;AAOM,SAAU,MAAM,GAAS;AAC3B,QAAM,MAAM,EAAE,SAAS,EAAE;AAEzB,MAAI,KAAK,IAAI;AACT,YAAQ,MAAM,KAAK,YAAW;;AAGlC,SAAO,IAAI,YAAW;AAC1B;AAzFA;;;;",
  "names": []
}
