{
  "version": 3,
  "sources": ["../../../dev/core/src/XR/webXRLayerWrapper.ts", "../../../dev/core/src/Materials/Textures/MultiviewRenderTarget.ts", "../../../dev/core/src/XR/webXRRenderTargetTextureProvider.ts", "../../../dev/core/src/XR/webXRWebGLLayer.ts", "../../../dev/core/src/XR/webXRManagedOutputCanvas.ts", "../../../dev/core/src/XR/native/nativeXRRenderTarget.ts", "../../../dev/core/src/XR/webXRSessionManager.ts", "../../../dev/core/src/Cameras/targetCamera.ts", "../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../../dev/core/src/Cameras/freeCamera.ts", "../../../dev/core/src/XR/webXRTypes.ts", "../../../dev/core/src/XR/webXRCamera.ts", "../../../dev/core/src/Cameras/touchCamera.ts", "../../../dev/core/src/Gamepads/gamepad.ts", "../../../dev/core/src/Gamepads/xboxGamepad.ts", "../../../dev/core/src/Gamepads/dualShockGamepad.ts", "../../../dev/core/src/Gamepads/gamepadManager.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts", "../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraGamepadInput.ts", "../../../dev/core/src/Gamepads/gamepadSceneComponent.ts", "../../../dev/core/src/Cameras/universalCamera.ts", "../../../dev/core/src/XR/webXRExperienceHelper.ts", "../../../dev/core/src/XR/motionController/webXRControllerComponent.ts", "../../../dev/core/src/XR/motionController/webXRAbstractMotionController.ts", "../../../dev/core/src/XR/motionController/webXRGenericMotionController.ts", "../../../dev/core/src/Meshes/Builders/sphereBuilder.ts", "../../../dev/core/src/Materials/prePassConfiguration.ts", "../../../dev/core/src/Materials/materialFlags.ts", "../../../dev/core/src/Shaders/ShadersInclude/decalFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/defaultFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/sceneUboDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/meshUboDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/defaultUboDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/prePassDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/oitDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/mainUVVaryingDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/helperFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightUboDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightsFragmentFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/shadowsFragmentFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/samplerFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/fresnelFunction.ts", "../../../dev/core/src/Shaders/ShadersInclude/reflectionFunction.ts", "../../../dev/core/src/Shaders/ShadersInclude/imageProcessingDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/imageProcessingFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/bumpFragmentMainFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/bumpFragmentFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/logDepthDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/bumpFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/decalFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/depthPrePass.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/logDepthFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/oitFragment.ts", "../../../dev/core/src/Shaders/default.fragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/decalVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/defaultVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/uvAttributeDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/bonesDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/instancesDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/prePassVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/samplerVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/bumpVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightVxFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightVxUboDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertexGlobal.ts", "../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/instancesVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/bonesVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/bakedVertexAnimation.ts", "../../../dev/core/src/Shaders/ShadersInclude/prePassVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/uvVariableDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/samplerVertexImplementation.ts", "../../../dev/core/src/Shaders/ShadersInclude/bumpVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/shadowsVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/vertexColorMixing.ts", "../../../dev/core/src/Shaders/ShadersInclude/pointCloudVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/logDepthVertex.ts", "../../../dev/core/src/Shaders/default.vertex.ts", "../../../dev/core/src/Materials/materialPluginManager.ts", "../../../dev/core/src/Materials/materialPluginBase.ts", "../../../dev/core/src/Materials/material.detailMapConfiguration.ts", "../../../dev/core/src/Materials/standardMaterial.ts", "../../../dev/core/src/XR/motionController/webXRProfiledMotionController.ts", "../../../dev/core/src/XR/motionController/webXRMotionControllerManager.ts", "../../../dev/core/src/XR/webXRInputSource.ts", "../../../dev/core/src/XR/webXRInput.ts", "../../../dev/core/src/Meshes/Builders/cylinderBuilder.ts", "../../../dev/core/src/Meshes/Builders/torusBuilder.ts", "../../../dev/core/src/Culling/ray.ts", "../../../dev/core/src/Lights/light.ts", "../../../dev/core/src/Lights/hemisphericLight.ts", "../../../dev/core/src/Rendering/utilityLayerRenderer.ts", "../../../dev/core/src/XR/features/WebXRControllerPointerSelection.ts", "../../../dev/core/src/Animations/animationKey.ts", "../../../dev/core/src/Animations/animationRange.ts", "../../../dev/core/src/Animations/animation.ts", "../../../dev/core/src/Animations/easing.ts", "../../../dev/core/src/Meshes/subMesh.project.ts", "../../../dev/core/src/XR/features/WebXRNearInteraction.ts", "../../../dev/core/src/XR/webXREnterExitUI.ts", "../../../dev/core/src/Engines/Extensions/engine.dynamicTexture.ts", "../../../dev/core/src/Materials/Textures/dynamicTexture.ts", "../../../dev/core/src/Meshes/groundMesh.ts", "../../../dev/core/src/Meshes/Builders/groundBuilder.ts", "../../../dev/core/src/Meshes/instancedMesh.ts", "../../../dev/core/src/Materials/shaderMaterial.ts", "../../../dev/core/src/Shaders/color.fragment.ts", "../../../dev/core/src/Shaders/color.vertex.ts", "../../../dev/core/src/Meshes/linesMesh.ts", "../../../dev/core/src/Meshes/Builders/linesBuilder.ts", "../../../dev/core/src/Misc/timer.ts", "../../../dev/core/src/XR/features/WebXRControllerTeleportation.ts", "../../../dev/core/src/XR/webXRDefaultExperience.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRCompositionLayer */\r\n// TODO (rgerd): Extend for all other subclasses of XRCompositionLayer.\r\nexport type WebXRCompositionLayerType = \"XRProjectionLayer\";\r\nexport type WebXRQuadLayerType = \"XRQuadLayer\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRLayer */\r\nexport type WebXRLayerType = \"XRWebGLLayer\" | WebXRCompositionLayerType | WebXRQuadLayerType;\r\n\r\n/**\r\n * Wrapper over subclasses of XRLayer.\r\n * @internal\r\n */\r\nexport class WebXRLayerWrapper {\r\n    private _rttWrapper: Nullable<WebXRLayerRenderTargetTextureProvider> = null;\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this.layerType == \"XRWebGLLayer\" && typeof (this.layer as XRWebGLLayer).fixedFoveation == \"number\";\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        if (this.isFixedFoveationSupported) {\r\n            return (this.layer as XRWebGLLayer).fixedFoveation!;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        if (this.isFixedFoveationSupported) {\r\n            const val = Math.max(0, Math.min(1, value || 0));\r\n            (this.layer as XRWebGLLayer).fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a render target provider for the wrapped layer.\r\n     * @param xrSessionManager The XR Session Manager\r\n     * @returns A new render target texture provider for the wrapped layer.\r\n     */\r\n    public createRenderTargetTextureProvider(xrSessionManager: WebXRSessionManager): WebXRLayerRenderTargetTextureProvider {\r\n        this._rttWrapper = this._createRenderTargetTextureProvider(xrSessionManager);\r\n        return this._rttWrapper;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this._rttWrapper) {\r\n            this._rttWrapper.dispose();\r\n            this._rttWrapper = null;\r\n        }\r\n    }\r\n\r\n    protected constructor(\r\n        /** The width of the layer's framebuffer. */\r\n        public getWidth: () => number,\r\n        /** The height of the layer's framebuffer. */\r\n        public getHeight: () => number,\r\n        /** The XR layer that this WebXRLayerWrapper wraps. */\r\n        public readonly layer: XRLayer,\r\n        /** The type of XR layer that is being wrapped. */\r\n        public readonly layerType: WebXRLayerType,\r\n        /** Create a render target provider for the wrapped layer. */\r\n        private _createRenderTargetTextureProvider: (xrSessionManager: WebXRSessionManager) => WebXRLayerRenderTargetTextureProvider\r\n    ) {}\r\n}\r\n", "import { RenderTargetTexture } from \"../Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * Renders to multiple views with a single draw call\r\n * @see https://www.khronos.org/registry/webgl/extensions/OVR_multiview2/\r\n */\r\nexport class MultiviewRenderTarget extends RenderTargetTexture {\r\n    public set samples(value: number) {\r\n        // We override this setter because multisampling is handled by framebufferTextureMultisampleMultiviewOVR\r\n        this._samples = value;\r\n    }\r\n\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Creates a multiview render target\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"multiview rtt\", size, scene, false, true, Constants.TEXTURETYPE_UNSIGNED_INT, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = this.getScene()!.getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n        this.samples = this._getEngine()!.getCaps().maxSamples || this.samples;\r\n        this._texture.samples = this._samples;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        this.getScene()!.getEngine().bindMultiviewFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 2;\r\n    }\r\n}\r\n", "import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @internal\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(\r\n        private readonly _scene: Scene,\r\n        public readonly layerWrapper: WebXRLayerWrapper\r\n    ) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        renderTargetWrapper._samples = renderTargetTexture.samples;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\n\r\n/**\r\n * Wraps xr webgl layers.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerWrapper extends WebXRLayerWrapper {\r\n    /**\r\n     * @param layer is the layer to be wrapped.\r\n     * @returns a new WebXRLayerWrapper wrapping the provided XRWebGLLayer.\r\n     */\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRWebGLLayer.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    // The dimensions will always be defined in this class.\r\n    protected _framebufferDimensions: { framebufferWidth: number; framebufferHeight: number };\r\n    private _rtt: Nullable<RenderTargetTexture>;\r\n    private _framebuffer: WebGLFramebuffer;\r\n    private _layer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        public readonly layerWrapper: WebXRWebGLLayerWrapper\r\n    ) {\r\n        super(scene, layerWrapper);\r\n        this._layer = layerWrapper.layer;\r\n        this._framebufferDimensions = {\r\n            framebufferWidth: this._layer.framebufferWidth,\r\n            framebufferHeight: this._layer.framebufferHeight,\r\n        };\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const xrViewport = this._layer.getViewport(view);\r\n        if (!xrViewport) {\r\n            return false;\r\n        }\r\n        const framebufferWidth = this._framebufferDimensions.framebufferWidth;\r\n        const framebufferHeight = this._framebufferDimensions.framebufferHeight;\r\n        viewport.x = xrViewport.x / framebufferWidth;\r\n        viewport.y = xrViewport.y / framebufferHeight;\r\n        viewport.width = xrViewport.width / framebufferWidth;\r\n        viewport.height = xrViewport.height / framebufferHeight;\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        const layerWidth = this._layer.framebufferWidth;\r\n        const layerHeight = this._layer.framebufferHeight;\r\n        const framebuffer = this._layer.framebuffer;\r\n\r\n        if (\r\n            !this._rtt ||\r\n            layerWidth !== this._framebufferDimensions.framebufferWidth ||\r\n            layerHeight !== this._framebufferDimensions.framebufferHeight ||\r\n            framebuffer !== this._framebuffer\r\n        ) {\r\n            this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);\r\n            this._framebufferDimensions.framebufferWidth = layerWidth;\r\n            this._framebufferDimensions.framebufferHeight = layerHeight;\r\n            this._framebuffer = framebuffer;\r\n        }\r\n\r\n        return this._rtt;\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this.getRenderTargetTextureForEye(view.eye);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\n\r\n/**\r\n * Configuration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerInit;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: Nullable<ThinEngine> = null;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    private _xrLayerWrapper: Nullable<WebXRLayerWrapper> = null;\r\n\r\n    /**\r\n     * Observers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()\r\n    ) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n    }\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\r\n            this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\r\n            return this.xrLayer;\r\n        };\r\n\r\n        // support canvases without makeXRCompatible\r\n        if (!(this.canvasContext as any).makeXRCompatible) {\r\n            return Promise.resolve(createLayer());\r\n        }\r\n\r\n        return (this.canvasContext as any)\r\n            .makeXRCompatible()\r\n            .then(\r\n                // catch any error and continue. When using the emulator is throws this error for no apparent reason.\r\n                () => {},\r\n                () => {\r\n                    // log the error, continue nonetheless!\r\n                    Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\r\n                }\r\n            )\r\n            .then(() => {\r\n                return createLayer();\r\n            });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce(() => {\r\n                this._setCanvasSize(true);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this._xrLayerWrapper) {\r\n        if (!this._canvas || !this._engine) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.getWidth() + \"px\";\r\n                    this._canvas.style.height = xrLayer.getHeight() + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRLayerWrapper } from \"../webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { WebXRRenderTarget } from \"../webXRTypes\";\r\n\r\n/**\r\n * Wraps XRWebGLLayer's created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerWrapper extends WebXRLayerWrapper {\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new NativeXRLayerRenderTargetTextureProvider(sessionManager, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures for layers created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    private _nativeRTTProvider: WebXRLayerRenderTargetTextureProvider;\r\n    private _nativeLayer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        sessionManager: WebXRSessionManager,\r\n        public readonly layerWrapper: NativeXRLayerWrapper\r\n    ) {\r\n        super(sessionManager.scene, layerWrapper);\r\n        this._nativeRTTProvider = (navigator as any).xr.getNativeRenderTargetProvider(\r\n            sessionManager.session,\r\n            this._createRenderTargetTexture.bind(this),\r\n            this._destroyRenderTargetTexture.bind(this)\r\n        );\r\n        this._nativeLayer = layerWrapper.layer;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport): boolean {\r\n        viewport.x = 0;\r\n        viewport.y = 0;\r\n        viewport.width = 1;\r\n        viewport.height = 1;\r\n        return true;\r\n    }\r\n\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        // TODO (rgerd): Update the contract on the BabylonNative side to call this \"getRenderTargetTextureForEye\"\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(eye);\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(view.eye);\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return {\r\n            framebufferWidth: this._nativeLayer.framebufferWidth,\r\n            framebufferHeight: this._nativeLayer.framebufferHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the xr layer that will be used as the xr session's base layer.\r\n * @internal\r\n */\r\nexport class NativeXRRenderTarget implements WebXRRenderTarget {\r\n    public canvasContext: WebGLRenderingContext;\r\n    public xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    private _nativeRenderTarget: WebXRRenderTarget;\r\n\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        this._nativeRenderTarget = (navigator as any).xr.getWebXRRenderTarget(_xrSessionManager.scene.getEngine());\r\n    }\r\n\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        await this._nativeRenderTarget.initializeXRLayerAsync(xrSession);\r\n        this.xrLayer = this._nativeRenderTarget.xrLayer!;\r\n        return this.xrLayer;\r\n    }\r\n\r\n    dispose(): void {\r\n        /* empty */\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n\r\n    /**\r\n     * Fires when the xr reference space has been initialized\r\n     */\r\n    public onXRReferenceSpaceInitialized: Observable<XRReferenceSpace> = new Observable<XRReferenceSpace>();\r\n\r\n    /**\r\n     * Fires when the session manager is rendering the first frame\r\n     */\r\n    public onXRReady: Observable<WebXRSessionManager> = new Observable<WebXRSessionManager>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    private _worldScalingFactor: number = 1;\r\n\r\n    /**\r\n     * Observable raised when the world scale has changed\r\n     */\r\n    public onWorldScaleFactorChangedObservable: Observable<{\r\n        previousScaleFactor: number;\r\n        newScaleFactor: number;\r\n    }> = new Observable(undefined, true);\r\n\r\n    /**\r\n     * Scale factor to apply to all XR-related elements (camera, controllers)\r\n     */\r\n    public get worldScalingFactor(): number {\r\n        return this._worldScalingFactor;\r\n    }\r\n\r\n    public set worldScalingFactor(value: number) {\r\n        const oldValue = this._worldScalingFactor;\r\n        this._worldScalingFactor = value;\r\n        this.onWorldScaleFactorChangedObservable.notifyObservers({\r\n            previousScaleFactor: oldValue,\r\n            newScaleFactor: value,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine();\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this.onWorldScaleFactorChangedObservable.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public async exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            try {\r\n                return await this.session.end();\r\n            } catch {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            }\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionMode = xrSessionMode;\r\n            this.inXRSession = true;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    this.inXRSession = false;\r\n\r\n                    // Notify frame observers\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                    if (this._engine) {\r\n                        // make sure dimensions object is restored\r\n                        this._engine.framebufferDimensionsObject = null;\r\n\r\n                        // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                        this._engine.restoreDefaultFramebuffer();\r\n\r\n                        // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                        this._engine.customAnimationFrameRequester = null;\r\n                        this._engine._renderLoop();\r\n                    }\r\n\r\n                    // Dispose render target textures.\r\n                    // Only dispose on native because we can't destroy opaque textures on browser.\r\n                    if (this.isNative) {\r\n                        this._baseLayerRTTProvider?.dispose();\r\n                    }\r\n                    this._baseLayerRTTProvider = null;\r\n                    this._baseLayerWrapper = null;\r\n                },\r\n                { once: true }\r\n            );\r\n\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: (callback: FrameRequestCallback) => this.session.requestAnimationFrame(callback),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    const framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    // equality can be tested as it should be the same object\r\n                    if (this._engine.framebufferDimensionsObject !== framebufferDimensionsObject) {\r\n                        this._engine.framebufferDimensionsObject = framebufferDimensionsObject;\r\n                    }\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n        this.onXRFrameObservable.addOnce(() => {\r\n            this.onXRReady.notifyObservers(this);\r\n        });\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            // eslint-disable-next-line no-throw-literal\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                this.onXRReferenceSpaceInitialized.notifyObservers(referenceSpace);\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated Use updateRenderState() instead.\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return Promise.resolve(this.session.updateRenderState(state));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getBaseLayerWrapper(): Nullable<WebXRLayerWrapper> {\r\n        return this._baseLayerWrapper;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    public updateTargetFrameRate(rate: number): Promise<void> {\r\n        return this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the features enabled on the current session\r\n     * This is only available in-session!\r\n     * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\r\n     */\r\n    public get enabledFeatures(): Nullable<string[]> {\r\n        return this.session?.enabledFeatures ?? null;\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the context menu event\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * States of the webXR experience\r\n */\r\nexport enum WebXRState {\r\n    /**\r\n     * Transitioning to being in XR mode\r\n     */\r\n    ENTERING_XR,\r\n    /**\r\n     * Transitioning to non XR mode\r\n     */\r\n    EXITING_XR,\r\n    /**\r\n     * In XR mode and presenting\r\n     */\r\n    IN_XR,\r\n    /**\r\n     * Not entered XR mode\r\n     */\r\n    NOT_IN_XR,\r\n}\r\n\r\n/**\r\n * The state of the XR camera's tracking\r\n */\r\nexport enum WebXRTrackingState {\r\n    /**\r\n     * No transformation received, device is not being tracked\r\n     */\r\n    NOT_TRACKING,\r\n    /**\r\n     * Tracking lost - using emulated position\r\n     */\r\n    TRACKING_LOST,\r\n    /**\r\n     * Transformation tracking works normally\r\n     */\r\n    TRACKING,\r\n}\r\n\r\n/**\r\n * Abstraction of the XR render target\r\n */\r\nexport interface WebXRRenderTarget extends IDisposable {\r\n    /**\r\n     * xrpresent context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;\r\n}\r\n", "import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private static _ScaleReadOnly = Vector3.One();\r\n\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * This will be triggered after the first XR Frame initialized the camera,\r\n     * including the right number of views and their rendering parameters\r\n     */\r\n    public onXRCameraInitializedObservable = new Observable<WebXRCamera>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     * @deprecated use onBeforeCameraTeleport of the teleportation feature instead\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     * @deprecated use onAfterCameraTeleport of the teleportation feature instead\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * The last XRViewerPose from the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRViewerPose?: XRViewerPose;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        private _xrSessionManager: WebXRSessionManager\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n        this._deferOnly = true;\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.add(() => {\r\n                // only run if in session\r\n                if (!this._xrSessionManager.currentFrame) {\r\n                    return;\r\n                }\r\n                this._updateDepthNearFar();\r\n            });\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            () => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                if (this.onXRCameraInitializedObservable.hasObservers()) {\r\n                    this.onXRCameraInitializedObservable.notifyObservers(this);\r\n                    this.onXRCameraInitializedObservable.clear();\r\n                }\r\n\r\n                if (this._deferredUpdated) {\r\n                    this.position.copyFrom(this._deferredPositionUpdate);\r\n                    this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                }\r\n\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     *\r\n     * Note - this value is multiplied by the worldScalingFactor (if set), so it will be in the same units as the scene.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y * this._xrSessionManager.worldScalingFactor;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Set the target for the camera to look at.\r\n     * Note that this only rotates around the Y axis, as opposed to the default behavior of other cameras\r\n     * @param target the target to set the camera to look at\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        // only rotate around the y axis!\r\n        const tmpVector = TmpVectors.Vector3[1];\r\n        target.subtractToRef(this.position, tmpVector);\r\n        tmpVector.y = 0;\r\n        tmpVector.normalize();\r\n        const yRotation = Math.atan2(tmpVector.x, tmpVector.z);\r\n        this.rotationQuaternion.toEulerAnglesToRef(tmpVector);\r\n        Quaternion.FromEulerAnglesToRef(tmpVector.x, yRotation, tmpVector.z, this.rotationQuaternion);\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        this._lastXRViewerPose = undefined;\r\n    }\r\n\r\n    private _updateDepthNearFar() {\r\n        const far = (this.maxZ || 10000) * this._xrSessionManager.worldScalingFactor;\r\n        const xrRenderState: XRRenderStateInit = {\r\n            // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n            depthFar: far,\r\n            depthNear: this.minZ,\r\n        };\r\n\r\n        this._xrSessionManager.updateRenderState(xrRenderState);\r\n        this._cache.minZ = this.minZ;\r\n        this._cache.maxZ = far;\r\n    }\r\n\r\n    private _rotate180 = new Quaternion(0, 1, 0, 0);\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        this._lastXRViewerPose = pose || undefined;\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        // check min/max Z and update if not the same as in cache\r\n        if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\r\n            this._updateDepthNearFar();\r\n        }\r\n\r\n        if (pose.transform) {\r\n            const orientation = pose.transform.orientation;\r\n            if (pose.transform.orientation.x === undefined) {\r\n                // Babylon native polyfill can return an undefined orientation value\r\n                // When not initialized\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // add any custom render targets to this camera, if available in the scene\r\n            const customRenderTargets = this.getScene().customRenderTargets;\r\n            // use a for loop\r\n            for (let i = 0; i < customRenderTargets.length; i++) {\r\n                const rt = customRenderTargets[i];\r\n                // make sure we don't add the same render target twice\r\n                if (currentRig.customRenderTargets.indexOf(rt) === -1) {\r\n                    currentRig.customRenderTargets.push(rt);\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.parent = this.parent;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            } else {\r\n                currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\r\n            if (this._renderingMultiview) {\r\n                // For multiview, the render target texture is the same per-view (just the slice index is different),\r\n                // so we only need to set the output render target once for the rig parent.\r\n                if (i == 0) {\r\n                    this._xrSessionManager.trySetViewportForView(this.viewport, view);\r\n                    this.outputRenderTarget = renderTargetTexture;\r\n                }\r\n            } else {\r\n                // Update viewport\r\n                this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\r\n\r\n                // Set cameras to render to the session's render target\r\n                currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            }\r\n\r\n            // Replicate parent rig camera behavior\r\n            currentRig.layerMask = this.layerMask;\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            const removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            const referencedMat = TmpVectors.Matrix[0];\r\n            const poseMat = TmpVectors.Matrix[1];\r\n            const transformMat = TmpVectors.Matrix[2];\r\n\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\r\n            referencedMat.invert().multiplyToRef(poseMat, transformMat);\r\n            transformMat.invert();\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                transformMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\r\n            const transform = new XRRigidTransform(\r\n                {\r\n                    x: this._referencedPosition.x / this._xrSessionManager.worldScalingFactor,\r\n                    y: this._referencedPosition.y / this._xrSessionManager.worldScalingFactor,\r\n                    z: this._referencedPosition.z / this._xrSessionManager.worldScalingFactor,\r\n                },\r\n                {\r\n                    x: this._referenceQuaternion.x,\r\n                    y: this._referenceQuaternion.y,\r\n                    z: this._referenceQuaternion.z,\r\n                    w: this._referenceQuaternion.w,\r\n                }\r\n            );\r\n            this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n        }\r\n    }\r\n}\r\n", "import { FreeCamera } from \"./freeCamera\";\r\nimport type { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TouchCamera\", (name, scene) => {\r\n    return () => new TouchCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera controlled by touch.\r\n * This is like a universal camera minus the Gamepad controls.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class TouchCamera extends FreeCamera {\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    public get touchAngularSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchAngularSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    public get touchMoveSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchMoveSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new touch camera.\r\n     * This represents a FPS type of camera controlled by touch.\r\n     * This is like a universal camera minus the Gamepad controls.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addTouch();\r\n\r\n        this._setupInputs();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TouchCamera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _setupInputs() {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.touchEnabled = false;\r\n        } else {\r\n            touch.allowMouse = true;\r\n        }\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * Represents a gamepad control stick position\r\n */\r\nexport class StickValues {\r\n    /**\r\n     * Initializes the gamepad x and y control stick values\r\n     * @param x The x component of the gamepad control stick value\r\n     * @param y The y component of the gamepad control stick value\r\n     */\r\n    constructor(\r\n        /**\r\n         * The x component of the control stick\r\n         */\r\n        public x: number,\r\n        /**\r\n         * The y component of the control stick\r\n         */\r\n        public y: number\r\n    ) {}\r\n}\r\n\r\n/**\r\n * An interface which manages callbacks for gamepad button changes\r\n */\r\nexport interface GamepadButtonChanges {\r\n    /**\r\n     * Called when a gamepad has been changed\r\n     */\r\n    changed: boolean;\r\n    /**\r\n     * Called when a gamepad press event has been triggered\r\n     */\r\n    pressChanged: boolean;\r\n    /**\r\n     * Called when a touch event has been triggered\r\n     */\r\n    touchChanged: boolean;\r\n    /**\r\n     * Called when a value has changed\r\n     */\r\n    valueChanged: boolean;\r\n}\r\n\r\n/**\r\n * Represents a gamepad\r\n */\r\nexport class Gamepad {\r\n    /**\r\n     * Specifies what type of gamepad this represents\r\n     */\r\n    public type: number;\r\n\r\n    private _leftStick: StickValues = { x: 0, y: 0 };\r\n    private _rightStick: StickValues = { x: 0, y: 0 };\r\n\r\n    /** @internal */\r\n    public _isConnected = true;\r\n\r\n    private _leftStickAxisX: number;\r\n    private _leftStickAxisY: number;\r\n    private _rightStickAxisX: number;\r\n    private _rightStickAxisY: number;\r\n\r\n    /**\r\n     * Triggered when the left control stick has been changed\r\n     */\r\n    private _onleftstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Triggered when the right control stick has been changed\r\n     */\r\n    private _onrightstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Represents a gamepad controller\r\n     */\r\n    public static GAMEPAD = 0;\r\n    /**\r\n     * Represents a generic controller\r\n     */\r\n    public static GENERIC = 1;\r\n    /**\r\n     * Represents an XBox controller\r\n     */\r\n    public static XBOX = 2;\r\n    /**\r\n     * Represents a pose-enabled controller\r\n     */\r\n    public static POSE_ENABLED = 3;\r\n    /**\r\n     * Represents an Dual Shock controller\r\n     */\r\n    public static DUALSHOCK = 4;\r\n\r\n    /**\r\n     * Specifies whether the left control stick should be Y-inverted\r\n     */\r\n    protected _invertLeftStickY: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the gamepad has been connected\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this._isConnected;\r\n    }\r\n\r\n    /**\r\n     * Initializes the gamepad\r\n     * @param id The id of the gamepad\r\n     * @param index The index of the gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     * @param leftStickX The x component of the left joystick\r\n     * @param leftStickY The y component of the left joystick\r\n     * @param rightStickX The x component of the right joystick\r\n     * @param rightStickY The y component of the right joystick\r\n     */\r\n    constructor(\r\n        /**\r\n         * The id of the gamepad\r\n         */\r\n        public id: string,\r\n        /**\r\n         * The index of the gamepad\r\n         */\r\n        public index: number,\r\n        /**\r\n         * The browser gamepad\r\n         */\r\n        public browserGamepad: any,\r\n        leftStickX: number = 0,\r\n        leftStickY: number = 1,\r\n        rightStickX: number = 2,\r\n        rightStickY: number = 3\r\n    ) {\r\n        this.type = Gamepad.GAMEPAD;\r\n        this._leftStickAxisX = leftStickX;\r\n        this._leftStickAxisY = leftStickY;\r\n        this._rightStickAxisX = rightStickX;\r\n        this._rightStickAxisY = rightStickY;\r\n        if (this.browserGamepad.axes.length >= 2) {\r\n            this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n        }\r\n        if (this.browserGamepad.axes.length >= 4) {\r\n            this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the left joystick has changed\r\n     * @param callback callback to trigger\r\n     */\r\n    public onleftstickchanged(callback: (values: StickValues) => void) {\r\n        this._onleftstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the right joystick has changed\r\n     * @param callback callback to trigger\r\n     */\r\n    public onrightstickchanged(callback: (values: StickValues) => void) {\r\n        this._onrightstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left joystick\r\n     */\r\n    public get leftStick(): StickValues {\r\n        return this._leftStick;\r\n    }\r\n    /**\r\n     * Sets the left joystick values\r\n     */\r\n    public set leftStick(newValues: StickValues) {\r\n        if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {\r\n            this._onleftstickchanged(newValues);\r\n        }\r\n        this._leftStick = newValues;\r\n    }\r\n    /**\r\n     * Gets the right joystick\r\n     */\r\n    public get rightStick(): StickValues {\r\n        return this._rightStick;\r\n    }\r\n    /**\r\n     * Sets the right joystick value\r\n     */\r\n    public set rightStick(newValues: StickValues) {\r\n        if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {\r\n            this._onrightstickchanged(newValues);\r\n        }\r\n        this._rightStick = newValues;\r\n    }\r\n\r\n    /**\r\n     * Updates the gamepad joystick positions\r\n     */\r\n\r\n    public update() {\r\n        if (this._leftStick) {\r\n            this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n            if (this._invertLeftStickY) {\r\n                this.leftStick.y *= -1;\r\n            }\r\n        }\r\n        if (this._rightStick) {\r\n            this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {}\r\n}\r\n\r\n/**\r\n * Represents a generic gamepad\r\n */\r\nexport class GenericPad extends Gamepad {\r\n    private _buttons: Array<number>;\r\n    private _onbuttondown: (buttonPressed: number) => void;\r\n    private _onbuttonup: (buttonReleased: number) => void;\r\n\r\n    /**\r\n     * Observable triggered when a button has been pressed\r\n     */\r\n    public onButtonDownObservable = new Observable<number>();\r\n    /**\r\n     * Observable triggered when a button has been released\r\n     */\r\n    public onButtonUpObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Callback triggered when a button has been pressed\r\n     * @param callback Called when a button has been pressed\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: number) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n    /**\r\n     * Callback triggered when a button has been released\r\n     * @param callback Called when a button has been released\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: number) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Initializes the generic gamepad\r\n     * @param id The id of the generic gamepad\r\n     * @param index The index of the generic gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     */\r\n    constructor(id: string, index: number, browserGamepad: any) {\r\n        super(id, index, browserGamepad);\r\n        this.type = Gamepad.GENERIC;\r\n        this._buttons = new Array(browserGamepad.buttons.length);\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonIndex: number): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonIndex);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonIndex);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonIndex);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonIndex);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Updates the generic gamepad\r\n     */\r\n    public update() {\r\n        super.update();\r\n        for (let index = 0; index < this._buttons.length; index++) {\r\n            this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the generic gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"../Gamepads/gamepad\";\r\n/**\r\n * Defines supported buttons for XBox360 compatible gamepads\r\n */\r\nexport enum Xbox360Button {\r\n    /** A */\r\n    A = 0,\r\n    /** B */\r\n    B = 1,\r\n    /** X */\r\n    X = 2,\r\n    /** Y */\r\n    Y = 3,\r\n    /** Left button */\r\n    LB = 4,\r\n    /** Right button */\r\n    RB = 5,\r\n    /** Back */\r\n    Back = 8,\r\n    /** Start */\r\n    Start = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for XBox360 DPad  */\r\nexport enum Xbox360Dpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a XBox360 gamepad\r\n */\r\nexport class Xbox360Pad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: Xbox360Button) => void;\r\n    private _onbuttonup: (buttonReleased: Xbox360Button) => void;\r\n    private _ondpaddown: (dPadPressed: Xbox360Dpad) => void;\r\n    private _ondpadup: (dPadReleased: Xbox360Dpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<Xbox360Dpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<Xbox360Dpad>();\r\n\r\n    private _buttonA: number = 0;\r\n    private _buttonB: number = 0;\r\n    private _buttonX: number = 0;\r\n    private _buttonY: number = 0;\r\n    private _buttonBack: number = 0;\r\n    private _buttonStart: number = 0;\r\n    private _buttonLB: number = 0;\r\n    private _buttonRB: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    private _isXboxOnePad: boolean = false;\r\n\r\n    /**\r\n     * Creates a new XBox360 gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     * @param xboxOne defines if it is a XBox One gamepad\r\n     */\r\n    constructor(id: string, index: number, gamepad: any, xboxOne: boolean = false) {\r\n        super(id, index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.XBOX;\r\n        this._isXboxOnePad = xboxOne;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: Xbox360Button) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: Xbox360Button) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: Xbox360Dpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: Xbox360Dpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: Xbox360Button): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDPadValue(newValue: number, currentValue: number, buttonType: Xbox360Dpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `A` button\r\n     */\r\n    public get buttonA(): number {\r\n        return this._buttonA;\r\n    }\r\n    /**\r\n     * Sets the value of the `A` button\r\n     */\r\n    public set buttonA(value) {\r\n        this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `B` button\r\n     */\r\n    public get buttonB(): number {\r\n        return this._buttonB;\r\n    }\r\n    /**\r\n     * Sets the value of the `B` button\r\n     */\r\n    public set buttonB(value) {\r\n        this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `X` button\r\n     */\r\n    public get buttonX(): number {\r\n        return this._buttonX;\r\n    }\r\n    /**\r\n     * Sets the value of the `X` button\r\n     */\r\n    public set buttonX(value) {\r\n        this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Y` button\r\n     */\r\n    public get buttonY(): number {\r\n        return this._buttonY;\r\n    }\r\n    /**\r\n     * Sets the value of the `Y` button\r\n     */\r\n    public set buttonY(value) {\r\n        this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Start` button\r\n     */\r\n    public get buttonStart(): number {\r\n        return this._buttonStart;\r\n    }\r\n    /**\r\n     * Sets the value of the `Start` button\r\n     */\r\n    public set buttonStart(value) {\r\n        this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Back` button\r\n     */\r\n    public get buttonBack(): number {\r\n        return this._buttonBack;\r\n    }\r\n    /**\r\n     * Sets the value of the `Back` button\r\n     */\r\n    public set buttonBack(value) {\r\n        this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Left` button\r\n     */\r\n    public get buttonLB(): number {\r\n        return this._buttonLB;\r\n    }\r\n    /**\r\n     * Sets the value of the `Left` button\r\n     */\r\n    public set buttonLB(value) {\r\n        this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Right` button\r\n     */\r\n    public get buttonRB(): number {\r\n        return this._buttonRB;\r\n    }\r\n    /**\r\n     * Sets the value of the `Right` button\r\n     */\r\n    public set buttonRB(value) {\r\n        this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this._isXboxOnePad) {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        } else {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"./gamepad\";\r\n\r\n/**\r\n * Defines supported buttons for DualShock compatible gamepads\r\n */\r\nexport enum DualShockButton {\r\n    /** Cross */\r\n    Cross = 0,\r\n    /** Circle */\r\n    Circle = 1,\r\n    /** Square */\r\n    Square = 2,\r\n    /** Triangle */\r\n    Triangle = 3,\r\n    /** L1 */\r\n    L1 = 4,\r\n    /** R1 */\r\n    R1 = 5,\r\n    /** Share */\r\n    Share = 8,\r\n    /** Options */\r\n    Options = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for DualShock DPad  */\r\nexport enum DualShockDpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a DualShock gamepad\r\n */\r\nexport class DualShockPad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: DualShockButton) => void;\r\n    private _onbuttonup: (buttonReleased: DualShockButton) => void;\r\n    private _ondpaddown: (dPadPressed: DualShockDpad) => void;\r\n    private _ondpadup: (dPadReleased: DualShockDpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<DualShockDpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<DualShockDpad>();\r\n\r\n    private _buttonCross: number = 0;\r\n    private _buttonCircle: number = 0;\r\n    private _buttonSquare: number = 0;\r\n    private _buttonTriangle: number = 0;\r\n    private _buttonShare: number = 0;\r\n    private _buttonOptions: number = 0;\r\n    private _buttonL1: number = 0;\r\n    private _buttonR1: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    /**\r\n     * Creates a new DualShock gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     */\r\n    constructor(id: string, index: number, gamepad: any) {\r\n        super(id.replace(\"STANDARD GAMEPAD\", \"SONY PLAYSTATION DUALSHOCK\"), index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.DUALSHOCK;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: DualShockButton) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: DualShockButton) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: DualShockDpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: DualShockDpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: DualShockButton): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDPadValue(newValue: number, currentValue: number, buttonType: DualShockDpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Cross` button\r\n     */\r\n    public get buttonCross(): number {\r\n        return this._buttonCross;\r\n    }\r\n    /**\r\n     * Sets the value of the `Cross` button\r\n     */\r\n    public set buttonCross(value) {\r\n        this._buttonCross = this._setButtonValue(value, this._buttonCross, DualShockButton.Cross);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Circle` button\r\n     */\r\n    public get buttonCircle(): number {\r\n        return this._buttonCircle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Circle` button\r\n     */\r\n    public set buttonCircle(value) {\r\n        this._buttonCircle = this._setButtonValue(value, this._buttonCircle, DualShockButton.Circle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Square` button\r\n     */\r\n    public get buttonSquare(): number {\r\n        return this._buttonSquare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Square` button\r\n     */\r\n    public set buttonSquare(value) {\r\n        this._buttonSquare = this._setButtonValue(value, this._buttonSquare, DualShockButton.Square);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Triangle` button\r\n     */\r\n    public get buttonTriangle(): number {\r\n        return this._buttonTriangle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Triangle` button\r\n     */\r\n    public set buttonTriangle(value) {\r\n        this._buttonTriangle = this._setButtonValue(value, this._buttonTriangle, DualShockButton.Triangle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Options` button\r\n     */\r\n    public get buttonOptions(): number {\r\n        return this._buttonOptions;\r\n    }\r\n    /**\r\n     * Sets the value of the `Options` button\r\n     */\r\n    public set buttonOptions(value) {\r\n        this._buttonOptions = this._setButtonValue(value, this._buttonOptions, DualShockButton.Options);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Share` button\r\n     */\r\n    public get buttonShare(): number {\r\n        return this._buttonShare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Share` button\r\n     */\r\n    public set buttonShare(value) {\r\n        this._buttonShare = this._setButtonValue(value, this._buttonShare, DualShockButton.Share);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `L1` button\r\n     */\r\n    public get buttonL1(): number {\r\n        return this._buttonL1;\r\n    }\r\n    /**\r\n     * Sets the value of the `L1` button\r\n     */\r\n    public set buttonL1(value) {\r\n        this._buttonL1 = this._setButtonValue(value, this._buttonL1, DualShockButton.L1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `R1` button\r\n     */\r\n    public get buttonR1(): number {\r\n        return this._buttonR1;\r\n    }\r\n    /**\r\n     * Sets the value of the `R1` button\r\n     */\r\n    public set buttonR1(value) {\r\n        this._buttonR1 = this._setButtonValue(value, this._buttonR1, DualShockButton.R1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, DualShockButton.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, DualShockButton.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDPadValue(value, this._dPadUp, DualShockDpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDPadValue(value, this._dPadDown, DualShockDpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDPadValue(value, this._dPadLeft, DualShockDpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDPadValue(value, this._dPadRight, DualShockDpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public update() {\r\n        super.update();\r\n        this.buttonCross = this.browserGamepad.buttons[0].value;\r\n        this.buttonCircle = this.browserGamepad.buttons[1].value;\r\n        this.buttonSquare = this.browserGamepad.buttons[2].value;\r\n        this.buttonTriangle = this.browserGamepad.buttons[3].value;\r\n        this.buttonL1 = this.browserGamepad.buttons[4].value;\r\n        this.buttonR1 = this.browserGamepad.buttons[5].value;\r\n        this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n        this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n        this.buttonShare = this.browserGamepad.buttons[8].value;\r\n        this.buttonOptions = this.browserGamepad.buttons[9].value;\r\n        this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n        this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n        this.dPadUp = this.browserGamepad.buttons[12].value;\r\n        this.dPadDown = this.browserGamepad.buttons[13].value;\r\n        this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n        this.dPadRight = this.browserGamepad.buttons[15].value;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @internal */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && navigator.getGamepads;\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            this._checkGamepadsStatus();\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @internal */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring) {\r\n            Engine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Manage the gamepad inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Define the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Define the Gamepad controlling the input\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadAngularSensibility = 200;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    /**\r\n     * Defines the minimum value at which any analog stick input is ignored.\r\n     * Note: This value should only be a value between 0 and 1.\r\n     */\r\n    public deadzoneDelta = 0.1;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    // private members\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _cameraTransform: Matrix = Matrix.Identity();\r\n    private _deltaTransform: Vector3 = Vector3.Zero();\r\n    private _vector3: Vector3 = Vector3.Zero();\r\n    private _vector2: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        // check if there are already other controllers connected\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad && this.gamepad.leftStick) {\r\n            const camera = this.camera;\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (this.gamepadMoveSensibility !== 0) {\r\n                lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;\r\n                lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;\r\n            }\r\n\r\n            let rsValues = this.gamepad.rightStick;\r\n            if (rsValues && this.gamepadAngularSensibility !== 0) {\r\n                rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;\r\n                rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;\r\n            } else {\r\n                rsValues = { x: 0, y: 0 };\r\n            }\r\n\r\n            if (!camera.rotationQuaternion) {\r\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\r\n            } else {\r\n                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\r\n            }\r\n\r\n            const speed = camera._computeLocalCameraSpeed() * 50.0;\r\n            this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);\r\n\r\n            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\r\n            camera.cameraDirection.addInPlace(this._deltaTransform);\r\n            this._vector2.copyFromFloats(rsValues.y, rsValues.x);\r\n            camera.cameraRotation.addInPlace(this._vector2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && this._pointA?.pointerId !== evt.pointerId && this._pointB?.pointerId !== evt.pointerId) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type type of event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point The current position of the pointer\r\n     * @param offsetX The offsetX of the pointer when the event occurred\r\n     * @param offsetY The offsetY of the pointer when the event occurred\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the event to be handled\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n/**\r\n * Manage the gamepad inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the gamepad the input is gathering event from.\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadRotationSensibility = 80;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad) {\r\n            const camera = this.camera;\r\n            const rsValues = this.gamepad.rightStick;\r\n\r\n            if (rsValues) {\r\n                if (rsValues.x != 0) {\r\n                    const normalizedRX = rsValues.x / this.gamepadRotationSensibility;\r\n                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\r\n                        camera.inertialAlphaOffset += normalizedRX;\r\n                    }\r\n                }\r\n\r\n                if (rsValues.y != 0) {\r\n                    const normalizedRY = (rsValues.y / this.gamepadRotationSensibility) * this._yAxisScale;\r\n                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\r\n                        camera.inertialBetaOffset += normalizedRY;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (lsValues && lsValues.y != 0) {\r\n                const normalizedLY = lsValues.y / this.gamepadMoveSensibility;\r\n                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\r\n                    this.camera.inertialRadiusOffset -= normalizedLY;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\r\n", "import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { GamepadManager } from \"./gamepadManager\";\r\n\r\nimport { FreeCameraInputsManager } from \"../Cameras/freeCameraInputsManager\";\r\nimport { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { ArcRotateCameraGamepadInput } from \"../Cameras/Inputs/arcRotateCameraGamepadInput\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _gamepadManager: Nullable<GamepadManager>;\r\n\r\n        /**\r\n         * Gets the gamepad manager associated with the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/input/gamepads\r\n         */\r\n        gamepadManager: GamepadManager;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"gamepadManager\", {\r\n    get: function (this: Scene) {\r\n        if (!this._gamepadManager) {\r\n            this._gamepadManager = new GamepadManager(this);\r\n            let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD) as GamepadSystemSceneComponent;\r\n            if (!component) {\r\n                component = new GamepadSystemSceneComponent(this);\r\n                this._addComponent(component);\r\n            }\r\n        }\r\n\r\n        return this._gamepadManager;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../Cameras/freeCameraInputsManager\" {\r\n    /**\r\n     * Interface representing a free camera inputs manager\r\n     */\r\n    export interface FreeCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the FreeCameraInputsManager.\r\n         * @returns the FreeCameraInputsManager\r\n         */\r\n        addGamepad(): FreeCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the free camera inputs manager\r\n * @returns the FreeCameraInputsManager\r\n */\r\nFreeCameraInputsManager.prototype.addGamepad = function (): FreeCameraInputsManager {\r\n    this.add(new FreeCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\ndeclare module \"../Cameras/arcRotateCameraInputsManager\" {\r\n    /**\r\n     * Interface representing an arc rotate camera inputs manager\r\n     */\r\n    export interface ArcRotateCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the ArcRotateCamera InputManager.\r\n         * @returns the camera inputs manager\r\n         */\r\n        addGamepad(): ArcRotateCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the arc rotate camera inputs manager\r\n * @returns the camera inputs manager\r\n */\r\nArcRotateCameraInputsManager.prototype.addGamepad = function (): ArcRotateCameraInputsManager {\r\n    this.add(new ArcRotateCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the gamepad scene component responsible to manage gamepads in a given scene\r\n */\r\nexport class GamepadSystemSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_GAMEPAD;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for gamepads\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n        if (gamepadManager) {\r\n            gamepadManager.dispose();\r\n            this.scene._gamepadManager = null;\r\n        }\r\n    }\r\n\r\n    private _beforeCameraUpdate(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n\r\n        if (gamepadManager && gamepadManager._isMonitoring) {\r\n            gamepadManager._checkGamepadsStatus();\r\n        }\r\n    }\r\n}\r\n", "import { TouchCamera } from \"./touchCamera\";\r\nimport { Node } from \"../node\";\r\nimport type { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"./camera\";\r\n\r\nimport \"../Gamepads/gamepadSceneComponent\";\r\n\r\nNode.AddNodeConstructor(\"FreeCamera\", (name, scene) => {\r\n    // Forcing to use the Universal camera\r\n    return () => new UniversalCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n * which still works and will still be found in many Playgrounds.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class UniversalCamera extends TouchCamera {\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadAngularSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadAngularSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadMoveSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadMoveSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n     * which still works and will still be found in many Playgrounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addGamepad();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"UniversalCamera\";\r\n    }\r\n}\r\n\r\nCamera._CreateDefaultParsedCamera = (name: string, scene: Scene) => {\r\n    return new UniversalCamera(name, Vector3.Zero(), scene);\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { UniversalCamera } from \"../Cameras/universalCamera\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Options for setting up XR spectator camera.\r\n */\r\nexport interface WebXRSpectatorModeOption {\r\n    /**\r\n     * Expected refresh rate (frames per sec) for a spectator camera.\r\n     */\r\n    fps?: number;\r\n    /**\r\n     * The index of rigCameras array in a WebXR camera.\r\n     */\r\n    preferredCameraIndex?: number;\r\n}\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _attachedToElement: boolean = false;\r\n    private _spectatorCamera: Nullable<UniversalCamera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n    private _spectatorMode = false;\r\n    private _lastTimestamp = 0;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param _scene The scene the helper should be created in\r\n     */\r\n    private constructor(private _scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(_scene);\r\n        this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        _scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        const helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.exitXRAsync();\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        this._spectatorCamera?.dispose();\r\n        if (this._nonVRCamera) {\r\n            this._scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public async enterXRAsync(\r\n        sessionMode: XRSessionMode,\r\n        referenceSpaceType: XRReferenceSpaceType,\r\n        renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(),\r\n        sessionCreationOptions: XRSessionInit = {}\r\n    ): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        try {\r\n            await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\r\n            await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.camera.maxZ || 10000,\r\n                depthNear: this.camera.minZ,\r\n            };\r\n\r\n            // The layers feature will have already initialized the xr session's layers on session init.\r\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\r\n                const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n                xrRenderState.baseLayer = baseLayer;\r\n            }\r\n\r\n            this.sessionManager.updateRenderState(xrRenderState);\r\n            // run the render loop\r\n            this.sessionManager.runXRRenderLoop();\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this._scene.autoClear;\r\n            this._nonVRCamera = this._scene.activeCamera;\r\n            this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;\r\n            this._nonVRCamera?.detachControl();\r\n\r\n            this._scene.activeCamera = this.camera;\r\n            // do not compensate when AR session is used\r\n            if (sessionMode !== \"immersive-ar\") {\r\n                this._nonXRToXRCamera();\r\n            } else {\r\n                // Kept here, TODO - check if needed\r\n                this._scene.autoClear = false;\r\n                this.camera.compensateOnFirstFrame = false;\r\n                // reset the camera's position to the origin\r\n                this.camera.position.set(0, 0, 0);\r\n                this.camera.rotationQuaternion.set(0, 0, 0, 1);\r\n                this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n            }\r\n\r\n            this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\r\n                if (this.state !== WebXRState.EXITING_XR) {\r\n                    this._setState(WebXRState.EXITING_XR);\r\n                }\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                this.camera.rigCameras.forEach((c) => {\r\n                    c.outputRenderTarget = null;\r\n                });\r\n\r\n                // Restore scene settings\r\n                this._scene.autoClear = this._originalSceneAutoClear;\r\n                this._scene.activeCamera = this._nonVRCamera;\r\n                if (this._attachedToElement && this._nonVRCamera) {\r\n                    this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\r\n                }\r\n                if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                    if ((<any>this._nonVRCamera).setPosition) {\r\n                        (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                    } else {\r\n                        this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                    }\r\n                }\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n\r\n            // Wait until the first frame arrives before setting state to in xr\r\n            this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                this._setState(WebXRState.IN_XR);\r\n            });\r\n            return this.sessionManager;\r\n        } catch (e) {\r\n            Logger.Log(e);\r\n            Logger.Log(e.message);\r\n            this._setState(WebXRState.NOT_IN_XR);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enable spectator mode for desktop VR experiences.\r\n     * When spectator mode is enabled a camera will be attached to the desktop canvas and will\r\n     * display the first rig camera's view on the desktop canvas.\r\n     * Please note that this will degrade performance, as it requires another camera render.\r\n     * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\r\n     * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\r\n     */\r\n    public enableSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        if (!this._spectatorMode) {\r\n            this._spectatorMode = true;\r\n            this._switchSpectatorMode(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable spectator mode for desktop VR experiences.\r\n     */\r\n    public disableSpecatatorMode(): void {\r\n        if (this._spectatorMode) {\r\n            this._spectatorMode = false;\r\n            this._switchSpectatorMode();\r\n        }\r\n    }\r\n\r\n    private _switchSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        const fps = options?.fps ? options.fps : 1000.0;\r\n        const refreshRate = (1.0 / fps) * 1000.0;\r\n        const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;\r\n\r\n        const updateSpectatorCamera = () => {\r\n            if (this._spectatorCamera) {\r\n                const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\r\n                if (delta >= refreshRate) {\r\n                    this._lastTimestamp = this.sessionManager.currentTimestamp;\r\n                    this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\r\n                    this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\r\n                }\r\n            }\r\n        };\r\n        if (this._spectatorMode) {\r\n            if (cameraIndex >= this.camera.rigCameras.length) {\r\n                throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\r\n            }\r\n            const onStateChanged = () => {\r\n                if (this.state === WebXRState.IN_XR) {\r\n                    this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\r\n                    this._spectatorCamera.rotationQuaternion = new Quaternion();\r\n                    this._scene.activeCameras = [this.camera, this._spectatorCamera];\r\n                    this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\r\n                    this._scene.onAfterRenderCameraObservable.add((camera) => {\r\n                        if (camera === this.camera) {\r\n                            // reset the dimensions object for correct resizing\r\n                            this._scene.getEngine().framebufferDimensionsObject = null;\r\n                        }\r\n                    });\r\n                } else if (this.state === WebXRState.EXITING_XR) {\r\n                    this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n                    this._scene.activeCameras = null;\r\n                }\r\n            };\r\n            this.onStateChangedObservable.add(onStateChanged);\r\n            onStateChanged();\r\n        } else {\r\n            this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n            this._scene.activeCameras = [this.camera];\r\n        }\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n", "import type { IMinimalMotionControllerObject, MotionControllerComponentType } from \"./webXRAbstractMotionController\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { IDisposable } from \"../../scene\";\r\n\r\n/**\r\n * X-Y values for axes in WebXR\r\n */\r\nexport interface IWebXRMotionControllerAxesValue {\r\n    /**\r\n     * The value of the x axis\r\n     */\r\n    x: number;\r\n    /**\r\n     * The value of the y-axis\r\n     */\r\n    y: number;\r\n}\r\n\r\n/**\r\n * changed / previous values for the values of this component\r\n */\r\nexport interface IWebXRMotionControllerComponentChangesValues<T> {\r\n    /**\r\n     * current (this frame) value\r\n     */\r\n    current: T;\r\n    /**\r\n     * previous (last change) value\r\n     */\r\n    previous: T;\r\n}\r\n\r\n/**\r\n * Represents changes in the component between current frame and last values recorded\r\n */\r\nexport interface IWebXRMotionControllerComponentChanges {\r\n    /**\r\n     * will be populated with previous and current values if axes changed\r\n     */\r\n    axes?: IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue>;\r\n    /**\r\n     * will be populated with previous and current values if pressed changed\r\n     */\r\n    pressed?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if touched changed\r\n     */\r\n    touched?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if value changed\r\n     */\r\n    value?: IWebXRMotionControllerComponentChangesValues<number>;\r\n}\r\n/**\r\n * This class represents a single component (for example button or thumbstick) of a motion controller\r\n */\r\nexport class WebXRControllerComponent implements IDisposable {\r\n    private _axes: IWebXRMotionControllerAxesValue = {\r\n        x: 0,\r\n        y: 0,\r\n    };\r\n    private _changes: IWebXRMotionControllerComponentChanges = {};\r\n    private _currentValue: number = 0;\r\n    private _hasChanges: boolean = false;\r\n    private _pressed: boolean = false;\r\n    private _touched: boolean = false;\r\n\r\n    /**\r\n     * button component type\r\n     */\r\n    public static BUTTON_TYPE: MotionControllerComponentType = \"button\";\r\n    /**\r\n     * squeeze component type\r\n     */\r\n    public static SQUEEZE_TYPE: MotionControllerComponentType = \"squeeze\";\r\n    /**\r\n     * Thumbstick component type\r\n     */\r\n    public static THUMBSTICK_TYPE: MotionControllerComponentType = \"thumbstick\";\r\n    /**\r\n     * Touchpad component type\r\n     */\r\n    public static TOUCHPAD_TYPE: MotionControllerComponentType = \"touchpad\";\r\n    /**\r\n     * trigger component type\r\n     */\r\n    public static TRIGGER_TYPE: MotionControllerComponentType = \"trigger\";\r\n\r\n    /**\r\n     * If axes are available for this component (like a touchpad or thumbstick) the observers will be notified when\r\n     * the axes data changes\r\n     */\r\n    public onAxisValueChangedObservable: Observable<{ x: number; y: number }> = new Observable();\r\n    /**\r\n     * Observers registered here will be triggered when the state of a button changes\r\n     * State change is either pressed / touched / value\r\n     */\r\n    public onButtonStateChangedObservable: Observable<WebXRControllerComponent> = new Observable();\r\n\r\n    /**\r\n     * Creates a new component for a motion controller.\r\n     * It is created by the motion controller itself\r\n     *\r\n     * @param id the id of this component\r\n     * @param type the type of the component\r\n     * @param _buttonIndex index in the buttons array of the gamepad\r\n     * @param _axesIndices indices of the values in the axes array of the gamepad\r\n     */\r\n    constructor(\r\n        /**\r\n         * the id of this component\r\n         */\r\n        public id: string,\r\n        /**\r\n         * the type of the component\r\n         */\r\n        public type: MotionControllerComponentType,\r\n        private _buttonIndex: number = -1,\r\n        private _axesIndices: number[] = []\r\n    ) {}\r\n\r\n    /**\r\n     * The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }\r\n     */\r\n    public get axes(): IWebXRMotionControllerAxesValue {\r\n        return this._axes;\r\n    }\r\n\r\n    /**\r\n     * Get the changes. Elements will be populated only if they changed with their previous and current value\r\n     */\r\n    public get changes(): IWebXRMotionControllerComponentChanges {\r\n        return this._changes;\r\n    }\r\n\r\n    /**\r\n     * Return whether or not the component changed the last frame\r\n     */\r\n    public get hasChanges(): boolean {\r\n        return this._hasChanges;\r\n    }\r\n\r\n    /**\r\n     * is the button currently pressed\r\n     */\r\n    public get pressed(): boolean {\r\n        return this._pressed;\r\n    }\r\n\r\n    /**\r\n     * is the button currently touched\r\n     */\r\n    public get touched(): boolean {\r\n        return this._touched;\r\n    }\r\n\r\n    /**\r\n     * Get the current value of this component\r\n     */\r\n    public get value(): number {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Dispose this component\r\n     */\r\n    public dispose(): void {\r\n        this.onAxisValueChangedObservable.clear();\r\n        this.onButtonStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Are there axes correlating to this component\r\n     * @returns true is axes data is available\r\n     */\r\n    public isAxes(): boolean {\r\n        return this._axesIndices.length !== 0;\r\n    }\r\n\r\n    /**\r\n     * Is this component a button (hence - pressable)\r\n     * @returns true if can be pressed\r\n     */\r\n    public isButton(): boolean {\r\n        return this._buttonIndex !== -1;\r\n    }\r\n\r\n    /**\r\n     * update this component using the gamepad object it is in. Called on every frame\r\n     * @param nativeController the native gamepad controller object\r\n     */\r\n    public update(nativeController: IMinimalMotionControllerObject) {\r\n        let buttonUpdated = false;\r\n        let axesUpdate = false;\r\n        this._hasChanges = false;\r\n        this._changes = {};\r\n\r\n        if (this.isButton()) {\r\n            const button = nativeController.buttons[this._buttonIndex];\r\n            // defensive, in case a profile was forced\r\n            if (!button) {\r\n                return;\r\n            }\r\n            if (this._currentValue !== button.value) {\r\n                this.changes.value = {\r\n                    current: button.value,\r\n                    previous: this._currentValue,\r\n                };\r\n                buttonUpdated = true;\r\n                this._currentValue = button.value;\r\n            }\r\n            if (this._touched !== button.touched) {\r\n                this.changes.touched = {\r\n                    current: button.touched,\r\n                    previous: this._touched,\r\n                };\r\n                buttonUpdated = true;\r\n                this._touched = button.touched;\r\n            }\r\n            if (this._pressed !== button.pressed) {\r\n                this.changes.pressed = {\r\n                    current: button.pressed,\r\n                    previous: this._pressed,\r\n                };\r\n                buttonUpdated = true;\r\n                this._pressed = button.pressed;\r\n            }\r\n        }\r\n\r\n        if (this.isAxes()) {\r\n            if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {\r\n                this.changes.axes = {\r\n                    current: {\r\n                        x: nativeController.axes[this._axesIndices[0]],\r\n                        y: this._axes.y,\r\n                    },\r\n                    previous: {\r\n                        x: this._axes.x,\r\n                        y: this._axes.y,\r\n                    },\r\n                };\r\n                this._axes.x = nativeController.axes[this._axesIndices[0]];\r\n                axesUpdate = true;\r\n            }\r\n\r\n            if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {\r\n                if (this.changes.axes) {\r\n                    this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];\r\n                } else {\r\n                    this.changes.axes = {\r\n                        current: {\r\n                            x: this._axes.x,\r\n                            y: nativeController.axes[this._axesIndices[1]],\r\n                        },\r\n                        previous: {\r\n                            x: this._axes.x,\r\n                            y: this._axes.y,\r\n                        },\r\n                    };\r\n                }\r\n                this._axes.y = nativeController.axes[this._axesIndices[1]];\r\n                axesUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (buttonUpdated) {\r\n            this._hasChanges = true;\r\n            this.onButtonStateChangedObservable.notifyObservers(this);\r\n        }\r\n        if (axesUpdate) {\r\n            this._hasChanges = true;\r\n            this.onAxisValueChangedObservable.notifyObservers(this._axes);\r\n        }\r\n    }\r\n}\r\n", "import type { IDisposable, Scene } from \"../../scene\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\n\r\n/**\r\n * Handedness type in xrInput profiles. These can be used to define layouts in the Layout Map.\r\n */\r\nexport type MotionControllerHandedness = \"none\" | \"left\" | \"right\";\r\n/**\r\n * The type of components available in motion controllers.\r\n * This is not the name of the component.\r\n */\r\nexport type MotionControllerComponentType = \"trigger\" | \"squeeze\" | \"touchpad\" | \"thumbstick\" | \"button\";\r\n\r\n/**\r\n * The state of a controller component\r\n */\r\nexport type MotionControllerComponentStateType = \"default\" | \"touched\" | \"pressed\";\r\n\r\n/**\r\n * The schema of motion controller layout.\r\n * No object will be initialized using this interface\r\n * This is used just to define the profile.\r\n */\r\nexport interface IMotionControllerLayout {\r\n    /**\r\n     * Path to load the assets. Usually relative to the base path\r\n     */\r\n    assetPath: string;\r\n    /**\r\n     * Available components (unsorted)\r\n     */\r\n    components: {\r\n        /**\r\n         * A map of component Ids\r\n         */\r\n        [componentId: string]: {\r\n            /**\r\n             * The type of input the component outputs\r\n             */\r\n            type: MotionControllerComponentType;\r\n            /**\r\n             * The indices of this component in the gamepad object\r\n             */\r\n            gamepadIndices: {\r\n                /**\r\n                 * Index of button\r\n                 */\r\n                button?: number;\r\n                /**\r\n                 * If available, index of x-axis\r\n                 */\r\n                xAxis?: number;\r\n                /**\r\n                 * If available, index of y-axis\r\n                 */\r\n                yAxis?: number;\r\n            };\r\n            /**\r\n             * The mesh's root node name\r\n             */\r\n            rootNodeName: string;\r\n            /**\r\n             * Animation definitions for this model\r\n             */\r\n            visualResponses: {\r\n                [stateKey: string]: {\r\n                    /**\r\n                     * What property will be animated\r\n                     */\r\n                    componentProperty: \"xAxis\" | \"yAxis\" | \"button\" | \"state\";\r\n                    /**\r\n                     * What states influence this visual response\r\n                     */\r\n                    states: MotionControllerComponentStateType[];\r\n                    /**\r\n                     * Type of animation - movement or visibility\r\n                     */\r\n                    valueNodeProperty: \"transform\" | \"visibility\";\r\n                    /**\r\n                     * Base node name to move. Its position will be calculated according to the min and max nodes\r\n                     */\r\n                    valueNodeName?: string;\r\n                    /**\r\n                     * Minimum movement node\r\n                     */\r\n                    minNodeName?: string;\r\n                    /**\r\n                     * Max movement node\r\n                     */\r\n                    maxNodeName?: string;\r\n                };\r\n            };\r\n            /**\r\n             * If touch enabled, what is the name of node to display user feedback\r\n             */\r\n            touchPointNodeName?: string;\r\n        };\r\n    };\r\n    /**\r\n     * Is it xr standard mapping or not\r\n     */\r\n    gamepadMapping: \"\" | \"xr-standard\";\r\n    /**\r\n     * Base root node of this entire model\r\n     */\r\n    rootNodeName: string;\r\n    /**\r\n     * Defines the main button component id\r\n     */\r\n    selectComponentId: string;\r\n}\r\n\r\n/**\r\n * A definition for the layout map in the input profile\r\n */\r\nexport interface IMotionControllerLayoutMap {\r\n    /**\r\n     * Layouts with handedness type as a key\r\n     */\r\n    [handedness: string /* handedness */]: IMotionControllerLayout;\r\n}\r\n\r\n/**\r\n * The XR Input profile schema\r\n * Profiles can be found here:\r\n * https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/registry/profiles\r\n */\r\nexport interface IMotionControllerProfile {\r\n    /**\r\n     * fallback profiles for this profileId\r\n     */\r\n    fallbackProfileIds: string[];\r\n    /**\r\n     * The layout map, with handedness as key\r\n     */\r\n    layouts: IMotionControllerLayoutMap;\r\n    /**\r\n     * The id of this profile\r\n     * correlates to the profile(s) in the xrInput.profiles array\r\n     */\r\n    profileId: string;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller button animation\r\n * The meshes are provided to the _lerpButtonTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerButtonMeshMap {\r\n    /**\r\n     * the mesh that defines the pressed value mesh position.\r\n     * This is used to find the max-position of this button\r\n     */\r\n    pressedMesh: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the unpressed value mesh position.\r\n     * This is used to find the min (or initial) position of this button\r\n     */\r\n    unpressedMesh: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when value changes\r\n     */\r\n    valueMesh: AbstractMesh;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller axis animation.\r\n * This will be expanded when touchpad animations are fully supported\r\n * The meshes are provided to the _lerpAxisTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerMeshMap {\r\n    /**\r\n     * the mesh that defines the maximum value mesh position.\r\n     */\r\n    maxMesh?: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the minimum value mesh position.\r\n     */\r\n    minMesh?: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when axis value changes\r\n     */\r\n    valueMesh?: AbstractMesh;\r\n}\r\n\r\n/**\r\n * The elements needed for change-detection of the gamepad objects in motion controllers\r\n */\r\nexport interface IMinimalMotionControllerObject {\r\n    /**\r\n     * Available axes of this controller\r\n     */\r\n    axes: number[];\r\n    /**\r\n     * An array of available buttons\r\n     */\r\n    buttons: Array<{\r\n        /**\r\n         * Value of the button/trigger\r\n         */\r\n        value: number;\r\n        /**\r\n         * If the button/trigger is currently touched\r\n         */\r\n        touched: boolean;\r\n        /**\r\n         * If the button/trigger is currently pressed\r\n         */\r\n        pressed: boolean;\r\n    }>;\r\n\r\n    /**\r\n     * EXPERIMENTAL haptic support.\r\n     */\r\n    hapticActuators?: Array<{\r\n        pulse: (value: number, duration: number) => Promise<boolean>;\r\n    }>;\r\n}\r\n\r\n/**\r\n * An Abstract Motion controller\r\n * This class receives an xrInput and a profile layout and uses those to initialize the components\r\n * Each component has an observable to check for changes in value and state\r\n */\r\nexport abstract class WebXRAbstractMotionController implements IDisposable {\r\n    private _initComponent = (id: string) => {\r\n        if (!id) {\r\n            return;\r\n        }\r\n        const componentDef = this.layout.components[id];\r\n        const type = componentDef.type;\r\n        const buttonIndex = componentDef.gamepadIndices.button;\r\n        // search for axes\r\n        const axes: number[] = [];\r\n        if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {\r\n            axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);\r\n        }\r\n\r\n        this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);\r\n    };\r\n\r\n    private _modelReady: boolean = false;\r\n\r\n    /**\r\n     * A map of components (WebXRControllerComponent) in this motion controller\r\n     * Components have a ComponentType and can also have both button and axis definitions\r\n     */\r\n    public readonly components: {\r\n        [id: string]: WebXRControllerComponent;\r\n    } = {};\r\n\r\n    /**\r\n     * Disable the model's animation. Can be set at any time.\r\n     */\r\n    public disableAnimation: boolean = false;\r\n    /**\r\n     * Observers registered here will be triggered when the model of this controller is done loading\r\n     */\r\n    public onModelLoadedObservable: Observable<WebXRAbstractMotionController> = new Observable();\r\n    /**\r\n     * The profile id of this motion controller\r\n     */\r\n    public abstract profileId: string;\r\n    /**\r\n     * The root mesh of the model. It is null if the model was not yet initialized\r\n     */\r\n    public rootMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * constructs a new abstract motion controller\r\n     * @param scene the scene to which the model of the controller will be added\r\n     * @param layout The profile layout to load\r\n     * @param gamepadObject The gamepad object correlating to this controller\r\n     * @param handedness handedness (left/right/none) of this controller\r\n     * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading\r\n     * @param _controllerCache a cache holding controller models already loaded in this session\r\n     */\r\n    constructor(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected layout: IMotionControllerLayout,\r\n        /**\r\n         * The gamepad object correlating to this controller\r\n         */\r\n        public gamepadObject: IMinimalMotionControllerObject,\r\n        /**\r\n         * handedness (left/right/none) of this controller\r\n         */\r\n        public handedness: MotionControllerHandedness,\r\n        /**\r\n         * @internal\r\n         */\r\n        public _doNotLoadControllerMesh: boolean = false,\r\n        private _controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        // initialize the components\r\n        if (layout.components) {\r\n            Object.keys(layout.components).forEach(this._initComponent);\r\n        }\r\n        // Model is loaded in WebXRInput\r\n    }\r\n\r\n    /**\r\n     * Dispose this controller, the model mesh and all its components\r\n     */\r\n    public dispose(): void {\r\n        this.getComponentIds().forEach((id) => this.getComponent(id).dispose());\r\n        if (this.rootMesh) {\r\n            this.rootMesh.getChildren(undefined, true).forEach((node) => {\r\n                node.setEnabled(false);\r\n            });\r\n            this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns all components of specific type\r\n     * @param type the type to search for\r\n     * @returns an array of components with this type\r\n     */\r\n    public getAllComponentsOfType(type: MotionControllerComponentType): WebXRControllerComponent[] {\r\n        return this.getComponentIds()\r\n            .map((id) => this.components[id])\r\n            .filter((component) => component.type === type);\r\n    }\r\n\r\n    /**\r\n     * get a component based an its component id as defined in layout.components\r\n     * @param id the id of the component\r\n     * @returns the component correlates to the id or undefined if not found\r\n     */\r\n    public getComponent(id: string): WebXRControllerComponent {\r\n        return this.components[id];\r\n    }\r\n\r\n    /**\r\n     * Get the list of components available in this motion controller\r\n     * @returns an array of strings correlating to available components\r\n     */\r\n    public getComponentIds(): string[] {\r\n        return Object.keys(this.components);\r\n    }\r\n\r\n    /**\r\n     * Get the first component of specific type\r\n     * @param type type of component to find\r\n     * @returns a controller component or null if not found\r\n     */\r\n    public getComponentOfType(type: MotionControllerComponentType): Nullable<WebXRControllerComponent> {\r\n        return this.getAllComponentsOfType(type)[0] || null;\r\n    }\r\n\r\n    /**\r\n     * Get the main (Select) component of this controller as defined in the layout\r\n     * @returns the main component of this controller\r\n     */\r\n    public getMainComponent(): WebXRControllerComponent {\r\n        return this.getComponent(this.layout.selectComponentId);\r\n    }\r\n\r\n    /**\r\n     * Loads the model correlating to this controller\r\n     * When the mesh is loaded, the onModelLoadedObservable will be triggered\r\n     * @returns A promise fulfilled with the result of the model loading\r\n     */\r\n    public async loadModel(): Promise<boolean> {\r\n        const useGeneric = !this._getModelLoadingConstraints();\r\n        let loadingParams = this._getGenericFilenameAndPath();\r\n        // Checking if GLB loader is present\r\n        if (useGeneric) {\r\n            Logger.Warn(\"Falling back to generic models\");\r\n        } else {\r\n            loadingParams = this._getFilenameAndPath();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const meshesLoaded = (meshes: AbstractMesh[]) => {\r\n                if (useGeneric) {\r\n                    this._getGenericParentMesh(meshes);\r\n                } else {\r\n                    this._setRootMesh(meshes);\r\n                }\r\n                this._processLoadedModel(meshes);\r\n                this._modelReady = true;\r\n                this.onModelLoadedObservable.notifyObservers(this);\r\n                resolve(true);\r\n            };\r\n            if (this._controllerCache) {\r\n                // look for it in the cache\r\n                const found = this._controllerCache.filter((c) => {\r\n                    return c.filename === loadingParams.filename && c.path === loadingParams.path;\r\n                });\r\n                if (found[0]) {\r\n                    found[0].meshes.forEach((mesh) => mesh.setEnabled(true));\r\n                    meshesLoaded(found[0].meshes);\r\n                    return;\r\n                    // found, don't continue to load\r\n                }\r\n            }\r\n            SceneLoader.ImportMesh(\r\n                \"\",\r\n                loadingParams.path,\r\n                loadingParams.filename,\r\n                this.scene,\r\n                (meshes) => {\r\n                    if (this._controllerCache) {\r\n                        this._controllerCache.push({\r\n                            ...loadingParams,\r\n                            meshes,\r\n                        });\r\n                    }\r\n                    meshesLoaded(meshes);\r\n                },\r\n                null,\r\n                (_scene: Scene, message: string) => {\r\n                    Logger.Log(message);\r\n                    Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);\r\n                    reject(message);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update this model using the current XRFrame\r\n     * @param xrFrame the current xr frame to use and update the model\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame): void {\r\n        this.getComponentIds().forEach((id) => this.getComponent(id).update(this.gamepadObject));\r\n        this.updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Backwards compatibility due to a deeply-integrated typo\r\n     */\r\n    public get handness() {\r\n        return this.handedness;\r\n    }\r\n\r\n    /**\r\n     * Pulse (vibrate) this controller\r\n     * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called\r\n     * Consecutive calls to this function will cancel the last pulse call\r\n     *\r\n     * @param value the strength of the pulse in 0.0...1.0 range\r\n     * @param duration Duration of the pulse in milliseconds\r\n     * @param hapticActuatorIndex optional index of actuator (will usually be 0)\r\n     * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued\r\n     */\r\n    public pulse(value: number, duration: number, hapticActuatorIndex: number = 0): Promise<boolean> {\r\n        if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {\r\n            return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);\r\n        } else {\r\n            return Promise.resolve(false);\r\n        }\r\n    }\r\n\r\n    // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n    protected _getChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name === name, false)[0];\r\n    }\r\n\r\n    // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n    protected _getImmediateChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name == name, true)[0];\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axisMap\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @internal\r\n     */\r\n    protected _lerpTransform(axisMap: IMotionControllerMeshMap, axisValue: number, fixValueCoordinates?: boolean): void {\r\n        if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {\r\n            return;\r\n        }\r\n\r\n        if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;\r\n        Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);\r\n        Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);\r\n    }\r\n\r\n    /**\r\n     * Update the model itself with the current frame data\r\n     * @param xrFrame the frame to use for updating the model mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected updateModel(xrFrame: XRFrame): void {\r\n        if (!this._modelReady) {\r\n            return;\r\n        }\r\n        this._updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Get the filename and path for this controller's model\r\n     * @returns a map of filename and path\r\n     */\r\n    protected abstract _getFilenameAndPath(): { filename: string; path: string };\r\n    /**\r\n     * This function is called before the mesh is loaded. It checks for loading constraints.\r\n     * For example, this function can check if the GLB loader is available\r\n     * If this function returns false, the generic controller will be loaded instead\r\n     * @returns Is the client ready to load the mesh\r\n     */\r\n    protected abstract _getModelLoadingConstraints(): boolean;\r\n    /**\r\n     * This function will be called after the model was successfully loaded and can be used\r\n     * for mesh transformations before it is available for the user\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _processLoadedModel(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * Set the root mesh for this controller. Important for the WebXR controller class\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _setRootMesh(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * A function executed each frame that updates the mesh (if needed)\r\n     * @param xrFrame the current xrFrame\r\n     */\r\n    protected abstract _updateModel(xrFrame: XRFrame): void;\r\n\r\n    private _getGenericFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    private _getGenericParentMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            if (!mesh.parent) {\r\n                mesh.isPickable = false;\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        });\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n}\r\n", "import type { IMinimalMotionControllerObject, MotionControllerHandedness, IMotionControllerLayoutMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\n\r\n/**\r\n * A generic trigger-only motion controller for WebXR\r\n */\r\nexport class WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {\r\n    /**\r\n     * Static version of the profile id of this controller\r\n     */\r\n    public static ProfileId = \"generic-trigger\";\r\n\r\n    public profileId = WebXRGenericTriggerMotionController.ProfileId;\r\n\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        super(scene, GenericTriggerLayout[handedness], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _processLoadedModel(meshes: AbstractMesh[]): void {\r\n        // nothing to do\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            mesh.isPickable = false;\r\n            if (!mesh.parent) {\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        });\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op\r\n    }\r\n}\r\n\r\n// https://github.com/immersive-web/webxr-input-profiles/blob/master/packages/registry/profiles/generic/generic-trigger-touchpad-thumbstick.json\r\nconst GenericTriggerLayout: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n    none: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n", "import type { Matrix } from \"../Maths/math.vector\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Configuration needed for prepass-capable materials\r\n */\r\nexport class PrePassConfiguration {\r\n    /**\r\n     * Previous world matrices of meshes carrying this material\r\n     * Used for computing velocity\r\n     */\r\n    public previousWorldMatrices: { [index: number]: Matrix } = {};\r\n    /**\r\n     * Previous view project matrix\r\n     * Used for computing velocity\r\n     */\r\n    public previousViewProjection: Matrix;\r\n    /**\r\n     * Current view projection matrix\r\n     * Used for computing velocity\r\n     */\r\n    public currentViewProjection: Matrix;\r\n    /**\r\n     * Previous bones of meshes carrying this material\r\n     * Used for computing velocity\r\n     */\r\n    public previousBones: { [index: number]: Float32Array } = {};\r\n\r\n    private _lastUpdateFrameId: number;\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\"previousWorld\", \"previousViewProjection\", \"mPreviousBones\");\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static AddSamplers(samplers: string[]): void {\r\n        // pass\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param effect defines the effect to update\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param mesh The mesh\r\n     * @param world World matrix of this mesh\r\n     * @param isFrozen Is the material frozen\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindForSubMesh(effect: Effect, scene: Scene, mesh: Mesh, world: Matrix, isFrozen: boolean): void {\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {\r\n            if (scene.prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE) !== -1) {\r\n                if (!this.previousWorldMatrices[mesh.uniqueId]) {\r\n                    this.previousWorldMatrices[mesh.uniqueId] = world.clone();\r\n                }\r\n\r\n                if (!this.previousViewProjection) {\r\n                    this.previousViewProjection = scene.getTransformMatrix().clone();\r\n                    this.currentViewProjection = scene.getTransformMatrix().clone();\r\n                }\r\n\r\n                const engine = scene.getEngine();\r\n\r\n                if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {\r\n                    // First update of the prepass configuration for this rendering pass\r\n                    this._lastUpdateFrameId = engine.frameId;\r\n                    this.previousViewProjection.copyFrom(this.currentViewProjection);\r\n                    this.currentViewProjection.copyFrom(scene.getTransformMatrix());\r\n                } else if (this._lastUpdateFrameId !== engine.frameId) {\r\n                    // The scene transformation did not change from the previous frame (so no camera motion), we must update previousViewProjection accordingly\r\n                    this._lastUpdateFrameId = engine.frameId;\r\n                    this.previousViewProjection.copyFrom(this.currentViewProjection);\r\n                }\r\n\r\n                effect.setMatrix(\"previousWorld\", this.previousWorldMatrices[mesh.uniqueId]);\r\n                effect.setMatrix(\"previousViewProjection\", this.previousViewProjection);\r\n\r\n                this.previousWorldMatrices[mesh.uniqueId] = world.clone();\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * This groups all the flags used to control the materials channel.\r\n */\r\nexport class MaterialFlags {\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    private static _DiffuseTextureEnabled = true;\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return this._DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        if (this._DiffuseTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DiffuseTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _DetailTextureEnabled = true;\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return this._DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        if (this._DetailTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DetailTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _DecalMapEnabled = true;\r\n    /**\r\n     * Are decal maps enabled in the application.\r\n     */\r\n    public static get DecalMapEnabled(): boolean {\r\n        return this._DecalMapEnabled;\r\n    }\r\n    public static set DecalMapEnabled(value: boolean) {\r\n        if (this._DecalMapEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DecalMapEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _AmbientTextureEnabled = true;\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return this._AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        if (this._AmbientTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AmbientTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _OpacityTextureEnabled = true;\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return this._OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        if (this._OpacityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._OpacityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ReflectionTextureEnabled = true;\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return this._ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        if (this._ReflectionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ReflectionTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _EmissiveTextureEnabled = true;\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return this._EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        if (this._EmissiveTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._EmissiveTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _SpecularTextureEnabled = true;\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return this._SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        if (this._SpecularTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SpecularTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _BumpTextureEnabled = true;\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return this._BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        if (this._BumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._BumpTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _LightmapTextureEnabled = true;\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return this._LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        if (this._LightmapTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._LightmapTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _RefractionTextureEnabled = true;\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return this._RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        if (this._RefractionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ColorGradingTextureEnabled = true;\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return this._ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        if (this._ColorGradingTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ColorGradingTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _FresnelEnabled = true;\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return this._FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        if (this._FresnelEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._FresnelEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_FresnelDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatTextureEnabled = true;\r\n    /**\r\n     * Are clear coat textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTextureEnabled(): boolean {\r\n        return this._ClearCoatTextureEnabled;\r\n    }\r\n    public static set ClearCoatTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatBumpTextureEnabled = true;\r\n    /**\r\n     * Are clear coat bump textures enabled in the application.\r\n     */\r\n    public static get ClearCoatBumpTextureEnabled(): boolean {\r\n        return this._ClearCoatBumpTextureEnabled;\r\n    }\r\n    public static set ClearCoatBumpTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatBumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatBumpTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatTintTextureEnabled = true;\r\n    /**\r\n     * Are clear coat tint textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTintTextureEnabled(): boolean {\r\n        return this._ClearCoatTintTextureEnabled;\r\n    }\r\n    public static set ClearCoatTintTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTintTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTintTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _SheenTextureEnabled = true;\r\n    /**\r\n     * Are sheen textures enabled in the application.\r\n     */\r\n    public static get SheenTextureEnabled(): boolean {\r\n        return this._SheenTextureEnabled;\r\n    }\r\n    public static set SheenTextureEnabled(value: boolean) {\r\n        if (this._SheenTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SheenTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _AnisotropicTextureEnabled = true;\r\n    /**\r\n     * Are anisotropic textures enabled in the application.\r\n     */\r\n    public static get AnisotropicTextureEnabled(): boolean {\r\n        return this._AnisotropicTextureEnabled;\r\n    }\r\n    public static set AnisotropicTextureEnabled(value: boolean) {\r\n        if (this._AnisotropicTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AnisotropicTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ThicknessTextureEnabled = true;\r\n    /**\r\n     * Are thickness textures enabled in the application.\r\n     */\r\n    public static get ThicknessTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set ThicknessTextureEnabled(value: boolean) {\r\n        if (this._ThicknessTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ThicknessTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _RefractionIntensityTextureEnabled = true;\r\n    /**\r\n     * Are refraction intensity textures enabled in the application.\r\n     */\r\n    public static get RefractionIntensityTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set RefractionIntensityTextureEnabled(value: boolean) {\r\n        if (this._RefractionIntensityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionIntensityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _TranslucencyIntensityTextureEnabled = true;\r\n    /**\r\n     * Are translucency intensity textures enabled in the application.\r\n     */\r\n    public static get TranslucencyIntensityTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set TranslucencyIntensityTextureEnabled(value: boolean) {\r\n        if (this._TranslucencyIntensityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._TranslucencyIntensityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _IridescenceTextureEnabled = true;\r\n    /**\r\n     * Are translucency intensity textures enabled in the application.\r\n     */\r\n    public static get IridescenceTextureEnabled(): boolean {\r\n        return this._IridescenceTextureEnabled;\r\n    }\r\n    public static set IridescenceTextureEnabled(value: boolean) {\r\n        if (this._IridescenceTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._IridescenceTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalFragmentDeclaration\";\nconst shader = `#ifdef DECAL\nuniform vec4 vDecalInfos;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalFragmentDeclaration\";\n\nconst name = \"defaultFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"sceneUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const sceneUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"meshUboDeclaration\";\nconst shader = `#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const meshUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\n\nconst name = \"defaultUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Material\n{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassDeclaration\";\nconst shader = `#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const prePassDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"oitDeclaration\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \nlayout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const oitDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"mainUVVaryingDeclaration\";\nconst shader = `#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const mainUVVaryingDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"helperFunctions\";\nconst shader = `const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const helperFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightFragmentDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightsFragmentFunctions\";\nconst shader = `struct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)\n{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}\nelse\n{lightVectorW=normalize(-lightData.xyz);}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)\n{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;\n#endif\nreturn result;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightsFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsFragmentFunctions\";\nconst shader = `#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}\n#define inline\nfloat computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);}\n#define inline\nfloat computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\n#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n/* disable_uniformity_analysis */\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.)\n);const vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}\nelse\n{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nif (numBlocker<1.0) {return 1.0;}\nelse\n{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerFragmentDeclaration\";\nconst shader = `#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fresnelFunction\";\nconst shader = `#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fresnelFunction = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"reflectionFunction\";\nconst shader = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*(view*worldPos));}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*vec4(positionW,1.));}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const reflectionFunction = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"imageProcessingDeclaration\";\nconst shader = `#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\n#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n#ifdef DITHER\nuniform float ditherIntensity;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"imageProcessingFunctions\";\nconst shader = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{float sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;}\n#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);const mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);vec3 RRTAndODTFit(vec3 v)\n{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}\nvec3 ACESFitted(vec3 color)\n{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpFragmentMainFunctions\";\nconst shader = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\n{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}\n#else\nmat4 toNormalMatrix(mat4 m)\n{float\na00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\na10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\na20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\na30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\nb00=a00*a11-a01*a10,\nb01=a00*a12-a02*a10,\nb02=a00*a13-a03*a10,\nb03=a01*a12-a02*a11,\nb04=a01*a13-a03*a11,\nb05=a02*a13-a03*a12,\nb06=a20*a31-a21*a30,\nb07=a20*a32-a22*a30,\nb08=a20*a33-a23*a30,\nb09=a21*a32-a22*a31,\nb10=a21*a33-a23*a31,\nb11=a22*a33-a23*a32,\ndet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(\na11*b11-a12*b10+a13*b09,\na02*b10-a01*b11-a03*b09,\na31*b05-a32*b04+a33*b03,\na22*b04-a21*b05-a23*b03,\na12*b08-a10*b11-a13*b07,\na00*b11-a02*b08+a03*b07,\na32*b02-a30*b05-a33*b01,\na20*b05-a22*b02+a23*b01,\na10*b10-a11*b08+a13*b06,\na01*b08-a00*b10-a03*b06,\na30*b04-a31*b02+a33*b00,\na21*b02-a20*b04-a23*b00,\na11*b07-a10*b09-a12*b06,\na00*b09-a01*b07+a02*b06,\na31*b01-a30*b03-a32*b00,\na20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);}\n#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentMainFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./samplerFragmentDeclaration\";\n\nconst name = \"bumpFragmentFunctions\";\nconst shader = `#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)\n{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)\n{}\nelse if (currSampledHeight>currRayHeight)\n{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}\nelse\n{currRayHeight-=stepSize;vLastOffset=vCurrOffset;\n#ifdef PARALLAX_RHS\nvCurrOffset-=stepSize*vMaxOffset;\n#else\nvCurrOffset+=stepSize*vMaxOffset;\n#endif\nlastSampledHeight=currSampledHeight;}}\nreturn vCurrOffset;}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;\n#ifdef PARALLAX_RHS\nreturn texCoordOffset;\n#else\nreturn -texCoordOffset;\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthDeclaration\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogFragmentDeclaration\";\nconst shader = `#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragment\";\nconst shader = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpFragment\";\nconst shader = `vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalFragment\";\nconst shader = `#ifdef DECAL\n#ifdef GAMMADECAL\ndecalColor.rgb=toLinearSpace(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalColor.a*=decalColor.a;\n#endif\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"depthPrePass\";\nconst shader = `#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);return;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const depthPrePass = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightFragment\";\nconst shader = `#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {index{X}=i;break;}}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{index{X}+=1;float nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;shadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\naggShadow+=shadow;numLights+=1.0;\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthFragment\";\nconst shader = `#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogFragment\";\nconst shader = `#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"oitFragment\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;\n#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn;}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\ndepth.rg=vec2(-fragDepth,fragDepth);return;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const oitFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/defaultFragmentDeclaration\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/samplerFragmentDeclaration\";\nimport \"./ShadersInclude/fresnelFunction\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/decalFragment\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/oitFragment\";\n\nconst name = \"defaultPixelShader\";\nconst shader = `#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\naggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; \n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); \n#else\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\n#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalVertexDeclaration\";\nconst shader = `#ifdef DECAL\nuniform vec4 vDecalInfos;uniform mat4 decalMatrix;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalVertexDeclaration\";\n\nconst name = \"defaultVertexDeclaration\";\nconst shader = `uniform mat4 viewProjection;uniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;uniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"uvAttributeDeclaration\";\nconst shader = `#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const uvAttributeDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bonesDeclaration\";\nconst shader = `#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bakedVertexAnimationDeclaration\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimationDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"instancesDeclaration\";\nconst shader = `#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassVertexDeclaration\";\nconst shader = `#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const prePassVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerVertexDeclaration\";\nconst shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpVertexDeclaration\";\nconst shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertexDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogVertexDeclaration\";\nconst shader = `#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightVxFragmentDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightVxFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightVxUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightVxUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertexGlobalDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobalDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertexDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#elif {X}==0\nuniform int morphTargetCount;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertexGlobal\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobal = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertex\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];\n#endif\n}\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"instancesVertex\";\nconst shader = `#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bakedVertexAnimation\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimation = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassVertex\";\nconst shader = `#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const prePassVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"uvVariableDeclaration\";\nconst shader = `#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const uvVariableDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerVertexImplementation\";\nconst shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}\n#ifdef UV2\nelse if (v_INFONAME_==1.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerVertexImplementation = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpVertex\";\nconst shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertex\";\nconst shader = `#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogVertex\";\nconst shader = `#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsVertex\";\nconst shader = `#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"vertexColorMixing\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvColor=vec4(1.0);\n#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvColor*=color;\n#else\nvColor.rgb*=color.rgb;\n#endif\n#endif\n#ifdef INSTANCESCOLOR\nvColor*=instanceColor;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const vertexColorMixing = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pointCloudVertex\";\nconst shader = `#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pointCloudVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthVertex\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/defaultVertexDeclaration\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/pointCloudVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"defaultVertexShader\";\nconst shader = `#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultVertexShader = { name, shader };\n", "import type { ProcessingOptions, ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport type {\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginDisposed,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginHardBindForSubMesh,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginFillRenderTargetTextures,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\n\r\ndeclare module \"./material\" {\r\n    export interface Material {\r\n        /**\r\n         * Plugin manager for this material\r\n         */\r\n        pluginManager?: MaterialPluginManager;\r\n    }\r\n}\r\n\r\nconst rxOption = new RegExp(\"^([gimus]+)!\");\r\n\r\n/**\r\n * Class that manages the plugins of a material\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginManager {\r\n    /** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\r\n    private static _MaterialPluginClassToMainDefine: { [name: string]: string } = {};\r\n    private static _MaterialPluginCounter: number = 0;\r\n\r\n    protected _material: Material;\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    /** @internal */\r\n    public _plugins: MaterialPluginBase[] = [];\r\n    protected _activePlugins: MaterialPluginBase[] = [];\r\n    protected _activePluginsForExtraEvents: MaterialPluginBase[] = [];\r\n    protected _codeInjectionPoints: { [shaderType: string]: { [codeName: string]: boolean } };\r\n    protected _defineNamesFromPlugins?: { [name: string]: { type: string; default: any } };\r\n    protected _uboDeclaration: string;\r\n    protected _vertexDeclaration: string;\r\n    protected _fragmentDeclaration: string;\r\n    protected _uniformList: string[];\r\n    protected _samplerList: string[];\r\n    protected _uboList: string[];\r\n\r\n    static {\r\n        EngineStore.OnEnginesDisposedObservable.add(() => {\r\n            UnregisterAllMaterialPlugins();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the plugin manager\r\n     * @param material material that this manager will manage the plugins for\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material;\r\n        this._scene = material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addPlugin(plugin: MaterialPluginBase): boolean {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === plugin.name) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (this._material._uniformBufferLayoutBuilt) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\r\n        }\r\n\r\n        const pluginClassName = plugin.getClassName();\r\n        if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\r\n            MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\r\n        }\r\n\r\n        this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);\r\n\r\n        this._plugins.push(plugin);\r\n        this._plugins.sort((a, b) => a.priority - b.priority);\r\n\r\n        this._codeInjectionPoints = {};\r\n\r\n        const defineNamesFromPlugins: { [name: string]: { type: string; default: any } } = {};\r\n        defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\r\n            type: \"boolean\",\r\n            default: true,\r\n        };\r\n\r\n        for (const plugin of this._plugins) {\r\n            plugin.collectDefines(defineNamesFromPlugins);\r\n            this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\r\n            this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\r\n        }\r\n\r\n        this._defineNamesFromPlugins = defineNamesFromPlugins;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activatePlugin(plugin: MaterialPluginBase): void {\r\n        if (this._activePlugins.indexOf(plugin) === -1) {\r\n            this._activePlugins.push(plugin);\r\n            this._activePlugins.sort((a, b) => a.priority - b.priority);\r\n\r\n            this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\r\n            this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\r\n            this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\r\n            this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\r\n\r\n            if (plugin.registerForExtraEvents) {\r\n                this._activePluginsForExtraEvents.push(plugin);\r\n                this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\r\n                this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a plugin from the list of plugins managed by this manager\r\n     * @param name name of the plugin\r\n     * @returns the plugin if found, else null\r\n     */\r\n    public getPlugin<T = MaterialPluginBase>(name: string): Nullable<T> {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === name) {\r\n                return this._plugins[i] as T;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _handlePluginEventIsReadyForSubMesh(eventData: MaterialPluginIsReadyForSubMesh): void {\r\n        let isReady = true;\r\n        for (const plugin of this._activePlugins) {\r\n            isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n        eventData.isReadyForSubMesh = isReady;\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefinesBeforeAttributes(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefines(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHardBindForSubMesh(eventData: MaterialPluginHardBindForSubMesh): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventBindForSubMesh(eventData: MaterialPluginBindForSubMesh): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHasRenderTargetTextures(eventData: MaterialPluginHasRenderTargetTextures): void {\r\n        let hasRenderTargetTextures = false;\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            hasRenderTargetTextures = plugin.hasRenderTargetTextures();\r\n            if (hasRenderTargetTextures) {\r\n                break;\r\n            }\r\n        }\r\n        eventData.hasRenderTargetTextures = hasRenderTargetTextures;\r\n    }\r\n\r\n    protected _handlePluginEventFillRenderTargetTextures(eventData: MaterialPluginFillRenderTargetTextures): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.fillRenderTargetTextures(eventData.renderTargets);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEvent(\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ): void {\r\n        switch (id) {\r\n            case MaterialPluginEvent.GetActiveTextures: {\r\n                const eventData = info as MaterialPluginGetActiveTextures;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getActiveTextures(eventData.activeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetAnimatables: {\r\n                const eventData = info as MaterialPluginGetAnimatables;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getAnimatables(eventData.animatables);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.HasTexture: {\r\n                const eventData = info as MaterialPluginHasTexture;\r\n                let hasTexture = false;\r\n                for (const plugin of this._activePlugins) {\r\n                    hasTexture = plugin.hasTexture(eventData.texture);\r\n                    if (hasTexture) {\r\n                        break;\r\n                    }\r\n                }\r\n                eventData.hasTexture = hasTexture;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.Disposed: {\r\n                const eventData = info as MaterialPluginDisposed;\r\n                for (const plugin of this._plugins) {\r\n                    plugin.dispose(eventData.forceDisposeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetDefineNames: {\r\n                const eventData = info as MaterialPluginGetDefineNames;\r\n                eventData.defineNames = this._defineNamesFromPlugins;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareEffect: {\r\n                const eventData = info as MaterialPluginPrepareEffect;\r\n                for (const plugin of this._activePlugins) {\r\n                    eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\r\n                    plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\r\n                }\r\n                if (this._uniformList.length > 0) {\r\n                    eventData.uniforms.push(...this._uniformList);\r\n                }\r\n                if (this._samplerList.length > 0) {\r\n                    eventData.samplers.push(...this._samplerList);\r\n                }\r\n                if (this._uboList.length > 0) {\r\n                    eventData.uniformBuffersNames.push(...this._uboList);\r\n                }\r\n                eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareUniformBuffer: {\r\n                const eventData = info as MaterialPluginPrepareUniformBuffer;\r\n                this._uboDeclaration = \"\";\r\n                this._vertexDeclaration = \"\";\r\n                this._fragmentDeclaration = \"\";\r\n                this._uniformList = [];\r\n                this._samplerList = [];\r\n                this._uboList = [];\r\n                for (const plugin of this._plugins) {\r\n                    const uniforms = plugin.getUniforms();\r\n                    if (uniforms) {\r\n                        if (uniforms.ubo) {\r\n                            for (const uniform of uniforms.ubo) {\r\n                                if (uniform.size && uniform.type) {\r\n                                    const arraySize = uniform.arraySize ?? 0;\r\n                                    eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);\r\n                                    this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : \"\"};\\n`;\r\n                                }\r\n                                this._uniformList.push(uniform.name);\r\n                            }\r\n                        }\r\n                        if (uniforms.vertex) {\r\n                            this._vertexDeclaration += uniforms.vertex + \"\\n\";\r\n                        }\r\n                        if (uniforms.fragment) {\r\n                            this._fragmentDeclaration += uniforms.fragment + \"\\n\";\r\n                        }\r\n                    }\r\n                    plugin.getSamplers(this._samplerList);\r\n                    plugin.getUniformBuffersNames(this._uboList);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _collectPointNames(shaderType: string, customCode: Nullable<{ [pointName: string]: string }> | undefined): void {\r\n        if (!customCode) {\r\n            return;\r\n        }\r\n        for (const pointName in customCode) {\r\n            if (!this._codeInjectionPoints[shaderType]) {\r\n                this._codeInjectionPoints[shaderType] = {};\r\n            }\r\n            this._codeInjectionPoints[shaderType][pointName] = true;\r\n        }\r\n    }\r\n\r\n    protected _injectCustomCode(eventData: MaterialPluginPrepareEffect, existingCallback?: (shaderType: string, code: string) => string): ShaderCustomProcessingFunction {\r\n        return (shaderType: string, code: string) => {\r\n            if (existingCallback) {\r\n                code = existingCallback(shaderType, code);\r\n            }\r\n            if (this._uboDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\r\n            }\r\n            if (this._vertexDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\r\n            }\r\n            if (this._fragmentDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\r\n            }\r\n            const points = this._codeInjectionPoints?.[shaderType];\r\n            if (!points) {\r\n                return code;\r\n            }\r\n            let processorOptions: Nullable<ProcessingOptions> = null;\r\n            for (let pointName in points) {\r\n                let injectedCode = \"\";\r\n                for (const plugin of this._activePlugins) {\r\n                    let customCode = plugin.getCustomCode(shaderType)?.[pointName];\r\n                    if (!customCode) {\r\n                        continue;\r\n                    }\r\n                    if (plugin.resolveIncludes) {\r\n                        if (processorOptions === null) {\r\n                            const shaderLanguage = ShaderLanguage.GLSL;\r\n                            processorOptions = {\r\n                                defines: [], // not used by _ProcessIncludes\r\n                                indexParameters: eventData.indexParameters,\r\n                                isFragment: false,\r\n                                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n                                processor: undefined as any, // not used by _ProcessIncludes\r\n                                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n                                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),\r\n                                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),\r\n                                version: undefined as any, // not used by _ProcessIncludes\r\n                                platformName: this._engine.shaderPlatformName,\r\n                                processingContext: undefined as any, // not used by _ProcessIncludes\r\n                                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                                processCodeAfterIncludes: undefined as any, // not used by _ProcessIncludes\r\n                            };\r\n                        }\r\n                        processorOptions.isFragment = shaderType === \"fragment\";\r\n                        ShaderProcessor._ProcessIncludes(customCode, processorOptions, (code) => (customCode = code));\r\n                    }\r\n                    injectedCode += customCode + \"\\n\";\r\n                }\r\n                if (injectedCode.length > 0) {\r\n                    if (pointName.charAt(0) === \"!\") {\r\n                        // pointName is a regular expression\r\n                        pointName = pointName.substring(1);\r\n\r\n                        let regexFlags = \"g\";\r\n                        if (pointName.charAt(0) === \"!\") {\r\n                            // no flags\r\n                            regexFlags = \"\";\r\n                            pointName = pointName.substring(1);\r\n                        } else {\r\n                            // get the flag(s)\r\n                            const matchOption = rxOption.exec(pointName);\r\n                            if (matchOption && matchOption.length >= 2) {\r\n                                regexFlags = matchOption[1];\r\n                                pointName = pointName.substring(regexFlags.length + 1);\r\n                            }\r\n                        }\r\n\r\n                        if (regexFlags.indexOf(\"g\") < 0) {\r\n                            // we force the \"g\" flag so that the regexp object is stateful!\r\n                            regexFlags += \"g\";\r\n                        }\r\n\r\n                        const sourceCode = code;\r\n                        const rx = new RegExp(pointName, regexFlags);\r\n                        let match = rx.exec(sourceCode);\r\n                        while (match !== null) {\r\n                            let newCode = injectedCode;\r\n                            for (let i = 0; i < match.length; ++i) {\r\n                                newCode = newCode.replace(\"$\" + i, match[i]);\r\n                            }\r\n                            code = code.replace(match[0], newCode);\r\n                            match = rx.exec(sourceCode);\r\n                        }\r\n                    } else {\r\n                        const fullPointName = \"#define \" + pointName;\r\n                        code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n                    }\r\n                }\r\n            }\r\n            return code;\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Type for plugin material factories.\r\n */\r\nexport type PluginMaterialFactory = (material: Material) => Nullable<MaterialPluginBase>;\r\n\r\nconst plugins: Array<[string, PluginMaterialFactory]> = [];\r\nlet inited = false;\r\nlet observer: Nullable<Observer<Material>> = null;\r\n\r\n/**\r\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\r\n * @param pluginName The plugin name\r\n * @param factory The factory function which allows to create the plugin\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RegisterMaterialPlugin(pluginName: string, factory: PluginMaterialFactory): void {\r\n    if (!inited) {\r\n        observer = Material.OnEventObservable.add((material: Material) => {\r\n            for (const [, factory] of plugins) {\r\n                factory(material);\r\n            }\r\n        }, MaterialPluginEvent.Created);\r\n        inited = true;\r\n    }\r\n    const existing = plugins.filter(([name, _factory]) => name === pluginName);\r\n    if (existing.length > 0) {\r\n        existing[0][1] = factory;\r\n    } else {\r\n        plugins.push([pluginName, factory]);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a material plugin from the list of global plugins.\r\n * @param pluginName The plugin name\r\n * @returns true if the plugin has been removed, else false\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterMaterialPlugin(pluginName: string): boolean {\r\n    for (let i = 0; i < plugins.length; ++i) {\r\n        if (plugins[i][0] === pluginName) {\r\n            plugins.splice(i, 1);\r\n            if (plugins.length === 0) {\r\n                UnregisterAllMaterialPlugins();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Clear the list of global material plugins\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterAllMaterialPlugins(): void {\r\n    plugins.length = 0;\r\n    inited = false;\r\n    Material.OnEventObservable.remove(observer);\r\n    observer = null;\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { MaterialPluginManager } from \"./materialPluginManager\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { Material } from \"./material\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"./Textures/renderTargetTexture\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Base class for material plugins.\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginBase {\r\n    /**\r\n     * Defines the name of the plugin\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Defines the priority of the plugin. Lower numbers run first.\r\n     */\r\n    @serialize()\r\n    public priority: number = 500;\r\n\r\n    /**\r\n     * Indicates that any #include directive in the plugin code must be replaced by the corresponding code.\r\n     */\r\n    @serialize()\r\n    public resolveIncludes: boolean = false;\r\n\r\n    /**\r\n     * Indicates that this plugin should be notified for the extra events (HasRenderTargetTextures / FillRenderTargetTextures / HardBindForSubMesh)\r\n     */\r\n    @serialize()\r\n    public registerForExtraEvents: boolean = false;\r\n\r\n    protected _material: Material;\r\n    protected _pluginManager: MaterialPluginManager;\r\n    protected _pluginDefineNames?: { [name: string]: any };\r\n\r\n    protected _enable(enable: boolean) {\r\n        if (enable) {\r\n            this._pluginManager._activatePlugin(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to mark defines as being dirty.\r\n     */\r\n    public readonly markAllDefinesAsDirty: () => void;\r\n\r\n    /**\r\n     * Creates a new material plugin\r\n     * @param material parent material of the plugin\r\n     * @param name name of the plugin\r\n     * @param priority priority of the plugin\r\n     * @param defines list of defines used by the plugin. The value of the property is the default value for this property\r\n     * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)\r\n     * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)\r\n     * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)\r\n     */\r\n    constructor(material: Material, name: string, priority: number, defines?: { [key: string]: any }, addToPluginList = true, enable = false, resolveIncludes = false) {\r\n        this._material = material;\r\n        this.name = name;\r\n        this.priority = priority;\r\n        this.resolveIncludes = resolveIncludes;\r\n\r\n        if (!material.pluginManager) {\r\n            material.pluginManager = new MaterialPluginManager(material);\r\n            material.onDisposeObservable.add(() => {\r\n                material.pluginManager = undefined;\r\n            });\r\n        }\r\n\r\n        this._pluginDefineNames = defines;\r\n        this._pluginManager = material.pluginManager;\r\n\r\n        if (addToPluginList) {\r\n            this._pluginManager._addPlugin(this);\r\n        }\r\n\r\n        if (enable) {\r\n            this._enable(true);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty = material._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name useful for serialization or dynamic coding.\r\n     * @returns The class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialPluginBase\";\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine the engine this scene belongs to.\r\n     * @param subMesh the submesh to check for readiness\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(defines: MaterialDefines, scene: Scene, engine: Engine, subMesh: SubMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine the engine this scene belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(forceDisposeTextures?: boolean): void {}\r\n\r\n    /**\r\n     * Returns a list of custom shader code fragments to customize the shader.\r\n     * @param shaderType \"vertex\" or \"fragment\"\r\n     * @returns null if no code to be added, or a list of pointName =\\> code.\r\n     * Note that `pointName` can also be a regular expression if it starts with a `!`.\r\n     * In that case, the string found by the regular expression (if any) will be\r\n     * replaced by the code provided.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getCustomCode(shaderType: string): Nullable<{ [pointName: string]: string }> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Collects all defines.\r\n     * @param defines The object to append to.\r\n     */\r\n    public collectDefines(defines: { [name: string]: { type: string; default: any } }): void {\r\n        if (!this._pluginDefineNames) {\r\n            return;\r\n        }\r\n        for (const key of Object.keys(this._pluginDefineNames)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            const type = typeof this._pluginDefineNames[key];\r\n            defines[key] = {\r\n                type: type === \"number\" ? \"number\" : type === \"string\" ? \"string\" : type === \"boolean\" ? \"boolean\" : \"object\",\r\n                default: this._pluginDefineNames[key],\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene to the material belongs to.\r\n     * @param mesh the mesh being rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefinesBeforeAttributes(defines: MaterialDefines, scene: Scene, mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Sets the defines for the next rendering\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene to the material belongs to.\r\n     * @param mesh the mesh being rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(defines: MaterialDefines, scene: Scene, mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     * @returns true if this uses a render target otherwise false.\r\n     */\r\n    public hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {}\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {}\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getAnimatables(animatables: IAnimatable[]): void {}\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public addFallbacks(defines: MaterialDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplers used by the plugin.\r\n     * @param samplers list that the sampler names should be added to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getSamplers(samplers: string[]): void {}\r\n\r\n    /**\r\n     * Gets the attributes used by the plugin.\r\n     * @param attributes list that the attribute names should be added to.\r\n     * @param scene the scene that the material belongs to.\r\n     * @param mesh the mesh being rendered.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getAttributes(attributes: string[], scene: Scene, mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Gets the uniform buffers names added by the plugin.\r\n     * @param ubos list that the ubo names should be added to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getUniformBuffersNames(ubos: string[]): void {}\r\n\r\n    /**\r\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\r\n     * @returns the description of the uniforms\r\n     */\r\n    public getUniforms(): { ubo?: Array<{ name: string; size?: number; type?: string; arraySize?: number }>; vertex?: string; fragment?: string } {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public copyTo(plugin: MaterialPluginBase): void {\r\n        SerializationHelper.Clone(() => plugin, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a plugin configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport { serialize, expandToProperty, serializeAsTexture } from \"../Misc/decorators\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { MaterialDefines } from \"./materialDefines\";\r\nimport { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { StandardMaterial } from \"./standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"./PBR/pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"./materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialDetailMapDefines extends MaterialDefines {\r\n    DETAIL = false;\r\n    DETAILDIRECTUV = 0;\r\n    DETAIL_NORMALBLENDMETHOD = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the detail map component of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nexport class DetailMapConfiguration extends MaterialPluginBase {\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The detail texture of the material.\r\n     */\r\n    @serializeAsTexture(\"detailTexture\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n     * Bigger values mean stronger blending\r\n     */\r\n    @serialize()\r\n    public diffuseBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n     * Bigger values mean stronger blending. Only used with PBR materials\r\n     */\r\n    @serialize()\r\n    public roughnessBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strong the bump effect from the detail map is\r\n     * Bigger values mean stronger effect\r\n     */\r\n    @serialize()\r\n    public bumpLevel = 1;\r\n\r\n    private _normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n    /**\r\n     * The method used to blend the bump and detail normals together\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalBlendMethod: number;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Enable or disable the detail map on this material\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial | StandardMaterial, addToPluginList = true) {\r\n        super(material, \"DetailMap\", 140, new MaterialDetailMapDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialDetailMapDefines, scene: Scene, engine: Engine): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefines(defines: MaterialDetailMapDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n\r\n            const engine = scene.getEngine();\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                } else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.DETAIL = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"DetailMapConfiguration\";\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"detailSampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vDetailInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"detailMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { PrePassConfiguration } from \"./prePassConfiguration\";\r\n\r\nimport type { IImageProcessingConfigurationDefines } from \"./imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"./imageProcessingConfiguration\";\r\nimport type { ColorCurves } from \"./colorCurves\";\r\nimport type { FresnelParameters } from \"./fresnelParameters\";\r\nimport type { ICustomShaderNameResolveOptions } from \"../Materials/material\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\n\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\n\r\nimport \"../Shaders/default.fragment\";\r\nimport \"../Shaders/default.vertex\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { DetailMapConfiguration } from \"./material.detailMapConfiguration\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"./clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindTextureMatrix,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareAttributesForMorphTargets,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMergedUV,\r\n    PrepareDefinesForMisc,\r\n    PrepareDefinesForMultiview,\r\n    PrepareDefinesForOIT,\r\n    PrepareDefinesForPrePass,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/** @internal */\r\nexport class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public MAINUV3 = false;\r\n    public MAINUV4 = false;\r\n    public MAINUV5 = false;\r\n    public MAINUV6 = false;\r\n    public DIFFUSE = false;\r\n    public DIFFUSEDIRECTUV = 0;\r\n    public BAKED_VERTEX_ANIMATION_TEXTURE = false;\r\n    public AMBIENT = false;\r\n    public AMBIENTDIRECTUV = 0;\r\n    public OPACITY = false;\r\n    public OPACITYDIRECTUV = 0;\r\n    public OPACITYRGB = false;\r\n    public REFLECTION = false;\r\n    public EMISSIVE = false;\r\n    public EMISSIVEDIRECTUV = 0;\r\n    public SPECULAR = false;\r\n    public SPECULARDIRECTUV = 0;\r\n    public BUMP = false;\r\n    public BUMPDIRECTUV = 0;\r\n    public PARALLAX = false;\r\n    public PARALLAX_RHS = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public SPECULAROVERALPHA = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHAFROMDIFFUSE = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public DIFFUSEFRESNEL = false;\r\n    public OPACITYFRESNEL = false;\r\n    public REFLECTIONFRESNEL = false;\r\n    public REFRACTIONFRESNEL = false;\r\n    public EMISSIVEFRESNEL = false;\r\n    public FRESNEL = false;\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public BONES_VELOCITY_ENABLED = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public GLOSSINESS = false;\r\n    public ROUGHNESS = false;\r\n    public EMISSIVEASILLUMINATION = false;\r\n    public LINKEMISSIVEWITHDIFFUSE = false;\r\n    public REFLECTIONFRESNELFROMSPECULAR = false;\r\n    public LIGHTMAP = false;\r\n    public LIGHTMAPDIRECTUV = 0;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public USELIGHTMAPASSHADOWMAP = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public INVERTCUBICMAP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public REFRACTION = false;\r\n    public REFRACTIONMAP_3D = false;\r\n    public REFLECTIONOVERALPHA = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public SHADOWFLOAT = false;\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n    public NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\r\n    public PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\r\n    public ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\r\n    public ALPHABLEND = true;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO_SQRT = false;\r\n    public PREPASS_ALBEDO_SQRT_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_NORMAL_WORLDSPACE = false;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_VELOCITY = false;\r\n    public PREPASS_VELOCITY_INDEX = -1;\r\n    public PREPASS_REFLECTIVITY = false;\r\n    public PREPASS_REFLECTIVITY_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public RGBDLIGHTMAP = false;\r\n    public RGBDREFLECTION = false;\r\n    public RGBDREFRACTION = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public MULTIVIEW = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    /**\r\n     * If the reflection texture on this material is in linear color space\r\n     * @internal\r\n     */\r\n    public IS_REFLECTION_LINEAR = false;\r\n    /**\r\n     * If the refraction texture on this material is in linear color space\r\n     * @internal\r\n     */\r\n    public IS_REFRACTION_LINEAR = false;\r\n    public EXPOSURE = false;\r\n\r\n    public DECAL_AFTER_DETAIL = false;\r\n\r\n    /**\r\n     * Initializes the Standard Material defines.\r\n     * @param externalProperties The external properties\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        super(externalProperties);\r\n        this.rebuild();\r\n    }\r\n\r\n    public setReflectionMode(modeToEnable: string) {\r\n        const modes = [\r\n            \"REFLECTIONMAP_CUBIC\",\r\n            \"REFLECTIONMAP_EXPLICIT\",\r\n            \"REFLECTIONMAP_PLANAR\",\r\n            \"REFLECTIONMAP_PROJECTION\",\r\n            \"REFLECTIONMAP_PROJECTION\",\r\n            \"REFLECTIONMAP_SKYBOX\",\r\n            \"REFLECTIONMAP_SPHERICAL\",\r\n            \"REFLECTIONMAP_EQUIRECTANGULAR\",\r\n            \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\r\n            \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\",\r\n        ];\r\n\r\n        for (const mode of modes) {\r\n            (<any>this)[mode] = mode === modeToEnable;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This is the default material used in Babylon. It is the best trade off between quality\r\n * and performances.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n */\r\nexport class StandardMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The basic texture of the material as viewed under a light.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"ambientTexture\")\r\n    private _ambientTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the transparency of the material from a texture.\r\n     * The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)\r\n     * or from the luminance or the current texel (if texture.getAlphaFromRGB is true)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"reflectionTexture\")\r\n    private _reflectionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the texture used to display the reflection.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"emissiveTexture\")\r\n    private _emissiveTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define texture of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"specularTexture\")\r\n    private _specularTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public specularTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"bumpTexture\")\r\n    private _bumpTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Bump mapping is a technique to simulate bump and dents on a rendered surface.\r\n     * These are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#bump-map\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"lightmapTexture\")\r\n    private _lightmapTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Complex lighting can be computationally expensive to compute at runtime.\r\n     * To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction#lightmaps\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"refractionTexture\")\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the texture used to display the refraction.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The color of the material lit by the environmental background lighting.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#ambient-color-example\r\n     */\r\n    @serializeAsColor3(\"ambient\")\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * The basic color of the material as viewed under a light.\r\n     */\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\r\n    @serializeAsColor3(\"specular\")\r\n    public specularColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Define the color of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * Defines how sharp are the highlights in the material.\r\n     * The bigger the value the sharper giving a more glossy feeling to the result.\r\n     * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\r\n     */\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"useAlphaFromDiffuseTexture\")\r\n    private _useAlphaFromDiffuseTexture = false;\r\n    /**\r\n     * Does the transparency come from the diffuse texture alpha channel.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public useAlphaFromDiffuseTexture: boolean;\r\n\r\n    @serialize(\"useEmissiveAsIllumination\")\r\n    private _useEmissiveAsIllumination = false;\r\n    /**\r\n     * If true, the emissive value is added into the end result, otherwise it is multiplied in.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useEmissiveAsIllumination: boolean;\r\n\r\n    @serialize(\"linkEmissiveWithDiffuse\")\r\n    private _linkEmissiveWithDiffuse = false;\r\n    /**\r\n     * If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing\r\n     * the emissive level when the final color is close to one.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkEmissiveWithDiffuse: boolean;\r\n\r\n    @serialize(\"useSpecularOverAlpha\")\r\n    private _useSpecularOverAlpha = false;\r\n    /**\r\n     * Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularOverAlpha: boolean;\r\n\r\n    @serialize(\"useReflectionOverAlpha\")\r\n    private _useReflectionOverAlpha = false;\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useReflectionOverAlpha: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    /**\r\n     * Does lights from the scene impacts this material.\r\n     * It can be a nice trick for performance to disable lighting on a fully emissive material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"useObjectSpaceNormalMap\")\r\n    private _useObjectSpaceNormalMap = false;\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap: boolean;\r\n\r\n    @serialize(\"useParallax\")\r\n    private _useParallax = false;\r\n    /**\r\n     * Is parallax enabled or not.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/parallaxMapping\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax: boolean;\r\n\r\n    @serialize(\"useParallaxOcclusion\")\r\n    private _useParallaxOcclusion = false;\r\n    /**\r\n     * Is parallax occlusion enabled or not.\r\n     * If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/parallaxMapping\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion: boolean;\r\n\r\n    /**\r\n     * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\r\n     */\r\n    @serialize()\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    @serialize(\"roughness\")\r\n    private _roughness = 0;\r\n    /**\r\n     * Helps to define how blurry the reflections should appears in the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: number;\r\n\r\n    /**\r\n     * In case of refraction, define the value of the index of refraction.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @serialize()\r\n    public indexOfRefraction = 0.98;\r\n\r\n    /**\r\n     * Invert the refraction texture alongside the y axis.\r\n     * It can be useful with procedural textures or probe for instance.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @serialize()\r\n    public invertRefractionY = true;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    public alphaCutOff = 0.4;\r\n\r\n    @serialize(\"useLightmapAsShadowmap\")\r\n    private _useLightmapAsShadowmap = false;\r\n    /**\r\n     * In case of light mapping, define whether the map contains light or shadow informations.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap: boolean;\r\n\r\n    // Fresnel\r\n    @serializeAsFresnelParameters(\"diffuseFresnelParameters\")\r\n    private _diffuseFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the diffuse fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public diffuseFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"opacityFresnelParameters\")\r\n    private _opacityFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the opacity fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")\r\n    public opacityFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"reflectionFresnelParameters\")\r\n    private _reflectionFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the reflection fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public reflectionFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"refractionFresnelParameters\")\r\n    private _refractionFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the refraction fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public refractionFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"emissiveFresnelParameters\")\r\n    private _emissiveFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the emissive fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public emissiveFresnelParameters: FresnelParameters;\r\n\r\n    @serialize(\"useReflectionFresnelFromSpecular\")\r\n    private _useReflectionFresnelFromSpecular = false;\r\n    /**\r\n     * If true automatically deducts the fresnels values from the material specularity.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public useReflectionFresnelFromSpecular: boolean;\r\n\r\n    @serialize(\"useGlossinessFromSpecularMapAlpha\")\r\n    private _useGlossinessFromSpecularMapAlpha = false;\r\n    /**\r\n     * Defines if the glossiness/roughness of the material should be read from the specular map alpha channel\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGlossinessFromSpecularMapAlpha: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize(\"invertNormalMapX\")\r\n    private _invertNormalMapX = false;\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX: boolean;\r\n\r\n    @serialize(\"invertNormalMapY\")\r\n    private _invertNormalMapY = false;\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY: boolean;\r\n\r\n    @serialize(\"twoSidedLighting\")\r\n    private _twoSidedLighting = false;\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting: boolean;\r\n\r\n    @serialize(\"applyDecalMapAfterDetailMap\")\r\n    private _applyDecalMapAfterDetailMap = false;\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public applyDecalMapAfterDetailMap: boolean;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines additional PrePass parameters for the material.\r\n     */\r\n    public readonly prePassConfiguration: PrePassConfiguration;\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return !this.disableDepthWrite;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): number {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: number) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): number {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: number) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this._imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return this._imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        this._imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\r\n    public readonly detailMap: DetailMapConfiguration;\r\n\r\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n    protected _worldViewProjectionMatrix = Matrix.Zero();\r\n    protected _globalAmbientColor = new Color3(0, 0, 0);\r\n    protected _cacheHasRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Instantiates a new standard material.\r\n     * This is the default material used in Babylon. It is the best trade off between quality\r\n     * and performances.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.detailMap = new DetailMapConfiguration(this);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n        this.prePassConfiguration = new PrePassConfiguration();\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._reflectionTexture);\r\n            }\r\n\r\n            if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n            }\r\n\r\n            this._eventInfo.renderTargets = this._renderTargets;\r\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\r\n\r\n            return this._renderTargets;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return this._cacheHasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"StandardMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"StandardMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this.alpha < 1.0 ||\r\n            this._opacityTexture != null ||\r\n            this._shouldUseAlphaFromDiffuseTexture() ||\r\n            (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the alpha value of the diffuse texture should be used for alpha blending.\r\n     */\r\n    protected _shouldUseAlphaFromDiffuseTexture(): boolean {\r\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    protected _hasAlphaChannel(): boolean {\r\n        return (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._opacityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns the diffuse texture in case of the standard material.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return this._diffuseTexture;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n            subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <StandardMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Multiview\r\n        PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\r\n\r\n        // Order independant transparency\r\n        PrepareDefinesForOIT(scene, defines, oit);\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            this._eventInfo.hasRenderTargetTextures = false;\r\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\r\n            defines._needUVs = false;\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                defines[\"MAINUV\" + i] = false;\r\n            }\r\n            if (scene.texturesEnabled) {\r\n                defines.DIFFUSEDIRECTUV = 0;\r\n                defines.BUMPDIRECTUV = 0;\r\n                defines.AMBIENTDIRECTUV = 0;\r\n                defines.OPACITYDIRECTUV = 0;\r\n                defines.EMISSIVEDIRECTUV = 0;\r\n                defines.SPECULARDIRECTUV = 0;\r\n                defines.LIGHTMAPDIRECTUV = 0;\r\n\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    }\r\n                } else {\r\n                    defines.DIFFUSE = false;\r\n                }\r\n\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    }\r\n                } else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                    }\r\n                } else {\r\n                    defines.OPACITY = false;\r\n                }\r\n\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (!this._reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needNormals = true;\r\n                        defines.REFLECTION = true;\r\n\r\n                        defines.ROUGHNESS = this._roughness > 0;\r\n                        defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\r\n                        defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\r\n                        defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\r\n                        defines.REFLECTIONMAP_OPPOSITEZ =\r\n                            defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;\r\n                        defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\r\n\r\n                        switch (this._reflectionTexture.coordinatesMode) {\r\n                            case Texture.EXPLICIT_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\r\n                                break;\r\n                            case Texture.PLANAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\r\n                                break;\r\n                            case Texture.PROJECTION_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\r\n                                break;\r\n                            case Texture.SKYBOX_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\r\n                                break;\r\n                            case Texture.SPHERICAL_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\r\n                                break;\r\n                            case Texture.EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.CUBIC_MODE:\r\n                            case Texture.INVCUBIC_MODE:\r\n                            default:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\r\n                                break;\r\n                        }\r\n\r\n                        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = (<any>this._reflectionTexture).boundingBoxSize ? true : false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n                }\r\n\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    }\r\n                } else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                        defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                    }\r\n                } else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    if (!this._specularTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\r\n                        defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\r\n                    }\r\n                } else {\r\n                    defines.SPECULAR = false;\r\n                }\r\n\r\n                if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\r\n                    // Bump texture can not be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n\r\n                        defines.PARALLAX = this._useParallax;\r\n                        defines.PARALLAX_RHS = scene.useRightHandedSystem;\r\n                        defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\r\n                    }\r\n\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.BUMP = false;\r\n                    defines.PARALLAX = false;\r\n                    defines.PARALLAX_RHS = false;\r\n                    defines.PARALLAXOCCLUSION = false;\r\n                }\r\n\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (!this._refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.REFRACTION = true;\r\n\r\n                        defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\r\n                        defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\r\n                        defines.USE_LOCAL_REFRACTIONMAP_CUBIC = (<any>this._refractionTexture).boundingBoxSize ? true : false;\r\n                    }\r\n                } else {\r\n                    defines.REFRACTION = false;\r\n                }\r\n\r\n                defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\r\n            } else {\r\n                defines.DIFFUSE = false;\r\n                defines.AMBIENT = false;\r\n                defines.OPACITY = false;\r\n                defines.REFLECTION = false;\r\n                defines.EMISSIVE = false;\r\n                defines.LIGHTMAP = false;\r\n                defines.BUMP = false;\r\n                defines.REFRACTION = false;\r\n            }\r\n\r\n            defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\r\n\r\n            defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\r\n\r\n            defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\r\n\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n\r\n            defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\r\n\r\n            defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        if (!this._eventInfo.isReadyForSubMesh) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n\r\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\r\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\r\n        }\r\n\r\n        if (defines._areFresnelDirty) {\r\n            if (StandardMaterial.FresnelEnabled) {\r\n                // Fresnel\r\n                if (\r\n                    this._diffuseFresnelParameters ||\r\n                    this._opacityFresnelParameters ||\r\n                    this._emissiveFresnelParameters ||\r\n                    this._refractionFresnelParameters ||\r\n                    this._reflectionFresnelParameters\r\n                ) {\r\n                    defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;\r\n\r\n                    defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\r\n\r\n                    defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;\r\n\r\n                    defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\r\n\r\n                    defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;\r\n\r\n                    defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;\r\n\r\n                    defines._needNormals = true;\r\n                    defines.FRESNEL = true;\r\n                }\r\n            } else {\r\n                defines.FRESNEL = false;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(\r\n            mesh,\r\n            scene,\r\n            this._useLogarithmicDepth,\r\n            this.pointsCloud,\r\n            this.fogEnabled,\r\n            this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest,\r\n            defines,\r\n            this._applyDecalMapAfterDetailMap\r\n        );\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        // External config\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.mesh = mesh;\r\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true, true);\r\n\r\n        // External config\r\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\r\n\r\n        // Get correct effect\r\n        let forceWasNotReadyPreviously = false;\r\n\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.REFLECTION) {\r\n                fallbacks.addFallback(0, \"REFLECTION\");\r\n            }\r\n\r\n            if (defines.SPECULAR) {\r\n                fallbacks.addFallback(0, \"SPECULAR\");\r\n            }\r\n\r\n            if (defines.BUMP) {\r\n                fallbacks.addFallback(0, \"BUMP\");\r\n            }\r\n\r\n            if (defines.PARALLAX) {\r\n                fallbacks.addFallback(1, \"PARALLAX\");\r\n            }\r\n\r\n            if (defines.PARALLAX_RHS) {\r\n                fallbacks.addFallback(1, \"PARALLAX_RHS\");\r\n            }\r\n\r\n            if (defines.PARALLAXOCCLUSION) {\r\n                fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\r\n            }\r\n\r\n            if (defines.SPECULAROVERALPHA) {\r\n                fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\r\n            }\r\n\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(0, \"POINTSIZE\");\r\n            }\r\n\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n\r\n            if (defines.SPECULARTERM) {\r\n                fallbacks.addFallback(0, \"SPECULARTERM\");\r\n            }\r\n\r\n            if (defines.DIFFUSEFRESNEL) {\r\n                fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\r\n            }\r\n\r\n            if (defines.OPACITYFRESNEL) {\r\n                fallbacks.addFallback(2, \"OPACITYFRESNEL\");\r\n            }\r\n\r\n            if (defines.REFLECTIONFRESNEL) {\r\n                fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\r\n            }\r\n\r\n            if (defines.EMISSIVEFRESNEL) {\r\n                fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\r\n            }\r\n\r\n            if (defines.FRESNEL) {\r\n                fallbacks.addFallback(4, \"FRESNEL\");\r\n            }\r\n\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.TANGENT) {\r\n                attribs.push(VertexBuffer.TangentKind);\r\n            }\r\n\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                if (defines[\"UV\" + i]) {\r\n                    attribs.push(`uv${i === 1 ? \"\" : i}`);\r\n                }\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n            PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n            PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n\r\n            let shaderName = \"default\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vAmbientColor\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vEmissiveColor\",\r\n                \"visibility\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"vAmbientInfos\",\r\n                \"vOpacityInfos\",\r\n                \"vReflectionInfos\",\r\n                \"vEmissiveInfos\",\r\n                \"vSpecularInfos\",\r\n                \"vBumpInfos\",\r\n                \"vLightmapInfos\",\r\n                \"vRefractionInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"ambientMatrix\",\r\n                \"opacityMatrix\",\r\n                \"reflectionMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"specularMatrix\",\r\n                \"bumpMatrix\",\r\n                \"normalMatrix\",\r\n                \"lightmapMatrix\",\r\n                \"refractionMatrix\",\r\n                \"diffuseLeftColor\",\r\n                \"diffuseRightColor\",\r\n                \"opacityParts\",\r\n                \"reflectionLeftColor\",\r\n                \"reflectionRightColor\",\r\n                \"emissiveLeftColor\",\r\n                \"emissiveRightColor\",\r\n                \"refractionLeftColor\",\r\n                \"refractionRightColor\",\r\n                \"vReflectionPosition\",\r\n                \"vReflectionSize\",\r\n                \"vRefractionPosition\",\r\n                \"vRefractionSize\",\r\n                \"logarithmicDepthConstant\",\r\n                \"vTangentSpaceParams\",\r\n                \"alphaCutOff\",\r\n                \"boneTextureWidth\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n            ];\r\n\r\n            const samplers = [\r\n                \"diffuseSampler\",\r\n                \"ambientSampler\",\r\n                \"opacitySampler\",\r\n                \"reflectionCubeSampler\",\r\n                \"reflection2DSampler\",\r\n                \"emissiveSampler\",\r\n                \"specularSampler\",\r\n                \"bumpSampler\",\r\n                \"lightmapSampler\",\r\n                \"refractionCubeSampler\",\r\n                \"refraction2DSampler\",\r\n                \"boneSampler\",\r\n                \"morphTargets\",\r\n                \"oitDepthSampler\",\r\n                \"oitFrontColorSampler\",\r\n            ];\r\n\r\n            const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\r\n\r\n            const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };\r\n\r\n            this._eventInfo.fallbacks = fallbacks;\r\n            this._eventInfo.fallbackRank = 0;\r\n            this._eventInfo.defines = defines;\r\n            this._eventInfo.uniforms = uniforms;\r\n            this._eventInfo.attributes = attribs;\r\n            this._eventInfo.samplers = samplers;\r\n            this._eventInfo.uniformBuffersNames = uniformBuffers;\r\n            this._eventInfo.customCode = undefined;\r\n            this._eventInfo.mesh = mesh;\r\n            this._eventInfo.indexParameters = indexParameters;\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\r\n\r\n            PrePassConfiguration.AddUniforms(uniforms);\r\n            PrePassConfiguration.AddSamplers(samplers);\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights,\r\n            });\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n            if (this.customShaderNameResolve) {\r\n                shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n            }\r\n\r\n            const join = defines.toString();\r\n\r\n            const previousEffect = subMesh.effect;\r\n            let effect = scene.getEngine().createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters,\r\n                    processFinalCode: csnrOptions.processFinalCode,\r\n                    processCodeAfterIncludes: this._eventInfo.customCode,\r\n                    multiTarget: defines.PREPASS,\r\n                },\r\n                engine\r\n            );\r\n\r\n            this._eventInfo.customCode = undefined;\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    forceWasNotReadyPreviously = this.isFrozen;\r\n\r\n                    if (lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Builds the material UBO layouts.\r\n     * Used internally during the effect preparation.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        // Order is important !\r\n        const ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"diffuseLeftColor\", 4);\r\n        ubo.addUniform(\"diffuseRightColor\", 4);\r\n        ubo.addUniform(\"opacityParts\", 4);\r\n        ubo.addUniform(\"reflectionLeftColor\", 4);\r\n        ubo.addUniform(\"reflectionRightColor\", 4);\r\n        ubo.addUniform(\"refractionLeftColor\", 4);\r\n        ubo.addUniform(\"refractionRightColor\", 4);\r\n        ubo.addUniform(\"emissiveLeftColor\", 4);\r\n        ubo.addUniform(\"emissiveRightColor\", 4);\r\n\r\n        ubo.addUniform(\"vDiffuseInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 2);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vSpecularInfos\", 2);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n\r\n        ubo.addUniform(\"diffuseMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"specularMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"alphaCutOff\", 1);\r\n        ubo.addUniform(\"refractionMatrix\", 16);\r\n        ubo.addUniform(\"vRefractionInfos\", 4);\r\n        ubo.addUniform(\"vRefractionPosition\", 3);\r\n        ubo.addUniform(\"vRefractionSize\", 3);\r\n        ubo.addUniform(\"vSpecularColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"vDiffuseColor\", 4);\r\n        ubo.addUniform(\"vAmbientColor\", 3);\r\n\r\n        super.buildUniformLayout();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <StandardMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Binding unconditionally\r\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n        const ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            this.bindViewProjection(effect);\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {\r\n                if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\r\n                    // Fresnel\r\n                    if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\r\n                        ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\r\n                            \"opacityParts\",\r\n                            new Color3(\r\n                                this.opacityFresnelParameters.leftColor.toLuminance(),\r\n                                this.opacityFresnelParameters.rightColor.toLuminance(),\r\n                                this.opacityFresnelParameters.bias\r\n                            ),\r\n                            this.opacityFresnelParameters.power\r\n                        );\r\n                    }\r\n\r\n                    if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\r\n                        ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\r\n                        ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\r\n                        ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\r\n                    }\r\n                }\r\n\r\n                // Textures\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\r\n                    }\r\n\r\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\r\n                        BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n\r\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n\r\n                    if (this._hasAlphaChannel()) {\r\n                        ubo.updateFloat(\"alphaCutOff\", this.alphaCutOff);\r\n                    }\r\n\r\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                        ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\r\n                        ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\r\n\r\n                        if ((<any>this._reflectionTexture).boundingBoxSize) {\r\n                            const cubeTexture = <CubeTexture>this._reflectionTexture;\r\n\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n\r\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n\r\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n\r\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                        ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\r\n                        BindTextureMatrix(this._specularTexture, ubo, \"specular\");\r\n                    }\r\n\r\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\r\n                        BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n\r\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                        let depth = 1.0;\r\n                        if (!this._refractionTexture.isCube) {\r\n                            ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\r\n\r\n                            if ((<any>this._refractionTexture).depth) {\r\n                                depth = (<any>this._refractionTexture).depth;\r\n                            }\r\n                        }\r\n                        ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n                        if ((<any>this._refractionTexture).boundingBoxSize) {\r\n                            const cubeTexture = <CubeTexture>this._refractionTexture;\r\n\r\n                            ubo.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                if (defines.SPECULARTERM) {\r\n                    ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n                }\r\n\r\n                ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);\r\n                ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\r\n\r\n                scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\r\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n            }\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    effect.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    effect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (this._reflectionTexture.isCube) {\r\n                        effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\r\n                    } else {\r\n                        effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\r\n                    }\r\n                }\r\n\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    effect.setTexture(\"specularSampler\", this._specularTexture);\r\n                }\r\n\r\n                if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                    effect.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (this._refractionTexture.isCube) {\r\n                        effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\r\n                    } else {\r\n                        effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OIT with depth peeling\r\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\r\n                this.getScene().depthPeelingRenderer!.bind(effect);\r\n            }\r\n\r\n            this._eventInfo.subMesh = subMesh;\r\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Colors\r\n            this.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            if (\r\n                (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) ||\r\n                this._reflectionTexture ||\r\n                this._refractionTexture ||\r\n                mesh.receiveShadows ||\r\n                defines.PREPASS\r\n            ) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            BindFogParameters(scene, mesh, effect);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                BindMorphTargetParameters(mesh, effect);\r\n            }\r\n\r\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this.useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            // image processing\r\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = super.getAnimatables();\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\r\n            results.push(this._specularTexture);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            results.push(this._refractionTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._specularTexture) {\r\n            activeTextures.push(this._specularTexture);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._specularTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._diffuseTexture?.dispose();\r\n            this._ambientTexture?.dispose();\r\n            this._opacityTexture?.dispose();\r\n            this._reflectionTexture?.dispose();\r\n            this._emissiveTexture?.dispose();\r\n            this._specularTexture?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._lightmapTexture?.dispose();\r\n            this._refractionTexture?.dispose();\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string, cloneTexturesOnlyOnce: boolean = true, rootUrl = \"\"): StandardMaterial {\r\n        const result = SerializationHelper.Clone(() => new StandardMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        this._clonePlugins(result, rootUrl);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a standard material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new standard material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardMaterial {\r\n        const material = SerializationHelper.Parse(() => new StandardMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        Material._ParsePlugins(source, material, scene, rootUrl);\r\n\r\n        return material;\r\n    }\r\n\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return MaterialFlags.DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        MaterialFlags.DiffuseTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return MaterialFlags.DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        MaterialFlags.DetailTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return MaterialFlags.AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        MaterialFlags.AmbientTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return MaterialFlags.OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        MaterialFlags.OpacityTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return MaterialFlags.ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        MaterialFlags.ReflectionTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return MaterialFlags.EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        MaterialFlags.EmissiveTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return MaterialFlags.SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        MaterialFlags.SpecularTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return MaterialFlags.BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        MaterialFlags.BumpTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return MaterialFlags.LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        MaterialFlags.LightmapTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return MaterialFlags.RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        MaterialFlags.RefractionTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return MaterialFlags.ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        MaterialFlags.ColorGradingTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return MaterialFlags.FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        MaterialFlags.FresnelEnabled = value;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.StandardMaterial\", StandardMaterial);\r\n\r\nScene.DefaultMaterialFactory = (scene: Scene) => {\r\n    return new StandardMaterial(\"default material\", scene);\r\n};\r\n", "import type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { IMotionControllerProfile, IMotionControllerMeshMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Axis, Space } from \"../../Maths/math.axis\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\n/**\r\n * A profiled motion controller has its profile loaded from an online repository.\r\n * The class is responsible of loading the model, mapping the keys and enabling model-animations\r\n */\r\nexport class WebXRProfiledMotionController extends WebXRAbstractMotionController {\r\n    private _buttonMeshMapping: {\r\n        [buttonName: string]: {\r\n            mainMesh?: AbstractMesh;\r\n            states: {\r\n                [state: string]: IMotionControllerMeshMap;\r\n            };\r\n        };\r\n    } = {};\r\n    private _touchDots: { [visKey: string]: AbstractMesh } = {};\r\n\r\n    /**\r\n     * The profile ID of this controller. Will be populated when the controller initializes.\r\n     */\r\n    public profileId: string;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        xrInput: XRInputSource,\r\n        _profile: IMotionControllerProfile,\r\n        private _repositoryUrl: string,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        private controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        super(scene, _profile.layouts[xrInput.handedness || \"none\"], xrInput.gamepad as any, xrInput.handedness, undefined, controllerCache);\r\n        this.profileId = _profile.profileId;\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        if (!this.controllerCache) {\r\n            Object.keys(this._touchDots).forEach((visResKey) => {\r\n                this._touchDots[visResKey].dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: this.layout.assetPath,\r\n            path: `${this._repositoryUrl}/profiles/${this.profileId}/`,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(\".glb\");\r\n        if (!glbLoaded) {\r\n            Logger.Warn(\"glTF / glb loader was not registered, using generic controller instead\");\r\n        }\r\n        return glbLoaded;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        this.getComponentIds().forEach((type) => {\r\n            const componentInLayout = this.layout.components[type];\r\n            this._buttonMeshMapping[type] = {\r\n                mainMesh: this._getChildByName(this.rootMesh!, componentInLayout.rootNodeName),\r\n                states: {},\r\n            };\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, visResponse.valueNodeName!),\r\n                        minMesh: this._getChildByName(this.rootMesh!, visResponse.minNodeName!),\r\n                        maxMesh: this._getChildByName(this.rootMesh!, visResponse.maxNodeName!),\r\n                    };\r\n                } else {\r\n                    // visibility, usually for touchpads\r\n                    const nameOfMesh =\r\n                        componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName\r\n                            ? componentInLayout.touchPointNodeName\r\n                            : visResponse.valueNodeName!;\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, nameOfMesh),\r\n                    };\r\n                    if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {\r\n                        const dot = CreateSphere(\r\n                            visualResponseKey + \"dot\",\r\n                            {\r\n                                diameter: 0.0015,\r\n                                segments: 8,\r\n                            },\r\n                            this.scene\r\n                        );\r\n                        dot.material = new StandardMaterial(visualResponseKey + \"mat\", this.scene);\r\n                        (<StandardMaterial>dot.material).diffuseColor = Color3.Red();\r\n                        dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;\r\n                        dot.isVisible = false;\r\n                        this._touchDots[visualResponseKey] = dot;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \"-\" + this.handedness, this.scene);\r\n        this.rootMesh.isPickable = false;\r\n        let rootMesh;\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            mesh.isPickable = false;\r\n\r\n            if (!mesh.parent) {\r\n                // Handle root node, attach to the new parentMesh\r\n                rootMesh = mesh;\r\n            }\r\n        }\r\n\r\n        if (rootMesh) {\r\n            rootMesh.setParent(this.rootMesh);\r\n        }\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);\r\n        }\r\n    }\r\n\r\n    protected _updateModel(_xrFrame: XRFrame): void {\r\n        if (this.disableAnimation) {\r\n            return;\r\n        }\r\n        this.getComponentIds().forEach((id) => {\r\n            const component = this.getComponent(id);\r\n            if (!component.hasChanges) {\r\n                return;\r\n            }\r\n            const meshes = this._buttonMeshMapping[id];\r\n            const componentInLayout = this.layout.components[id];\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                let value = component.value;\r\n                if (visResponse.componentProperty === \"xAxis\") {\r\n                    value = component.axes.x;\r\n                } else if (visResponse.componentProperty === \"yAxis\") {\r\n                    value = component.axes.y;\r\n                }\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== \"button\");\r\n                } else {\r\n                    // visibility\r\n                    const valueMesh = meshes.states[visualResponseKey].valueMesh;\r\n                    if (valueMesh) {\r\n                        valueMesh.isVisible = component.touched || component.pressed;\r\n                    }\r\n                    if (this._touchDots[visualResponseKey]) {\r\n                        this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n", "import type { WebXRAbstractMotionController, IMotionControllerProfile } from \"./webXRAbstractMotionController\";\r\nimport { WebXRGenericTriggerMotionController } from \"./webXRGenericMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { WebXRProfiledMotionController } from \"./webXRProfiledMotionController\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\n\r\n/**\r\n * A construction function type to create a new controller based on an xrInput object\r\n */\r\nexport type MotionControllerConstructor = (xrInput: XRInputSource, scene: Scene) => WebXRAbstractMotionController;\r\n\r\n/**\r\n * The MotionController Manager manages all registered motion controllers and loads the right one when needed.\r\n *\r\n * When this repository is complete: https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets\r\n * it should be replaced with auto-loaded controllers.\r\n *\r\n * When using a model try to stay as generic as possible. Eventually there will be no need in any of the controller classes\r\n */\r\n\r\nconst controllerCache: Array<{\r\n    filename: string;\r\n    path: string;\r\n    meshes: AbstractMesh[];\r\n}> = [];\r\n\r\n/**\r\n * Motion controller manager is managing the different webxr profiles and makes sure the right\r\n * controller is being loaded.\r\n */\r\nexport class WebXRMotionControllerManager {\r\n    private static _AvailableControllers: { [type: string]: MotionControllerConstructor } = {};\r\n    private static _Fallbacks: { [profileId: string]: string[] } = {};\r\n    // cache for loading\r\n    private static _ProfileLoadingPromises: { [profileName: string]: Promise<IMotionControllerProfile> } = {};\r\n    private static _ProfilesList: Nullable<Promise<{ [profile: string]: string }>>;\r\n\r\n    /**\r\n     * The base URL of the online controller repository. Can be changed at any time.\r\n     */\r\n    public static BaseRepositoryUrl = \"https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist\";\r\n    /**\r\n     * Which repository gets priority - local or online\r\n     */\r\n    public static PrioritizeOnlineRepository: boolean = true;\r\n    /**\r\n     * Use the online repository, or use only locally-defined controllers\r\n     */\r\n    public static UseOnlineRepository: boolean = true;\r\n\r\n    /**\r\n     * Disable the controller cache and load the models each time a new WebXRProfileMotionController is loaded.\r\n     * Defaults to true.\r\n     */\r\n    public static DisableControllerCache: boolean = true;\r\n\r\n    /**\r\n     * Clear the cache used for profile loading and reload when requested again\r\n     */\r\n    public static ClearProfilesCache() {\r\n        this._ProfilesList = null;\r\n        this._ProfileLoadingPromises = {};\r\n    }\r\n\r\n    /**\r\n     * Register the default fallbacks.\r\n     * This function is called automatically when this file is imported.\r\n     */\r\n    public static DefaultFallbacks() {\r\n        this.RegisterFallbacksForProfileId(\"google-daydream\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive-focus\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"magicleap-one\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"windows-mixed-reality\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"microsoft-mixed-reality\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-go\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch-v2\", [\"oculus-touch\", \"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch\", [\"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-gearvr\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-odyssey\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"valve-index\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"generic-hand-select\", [\"generic-trigger\"]);\r\n    }\r\n\r\n    /**\r\n     * Find a fallback profile if the profile was not found. There are a few predefined generic profiles.\r\n     * @param profileId the profile to which a fallback needs to be found\r\n     * @returns an array with corresponding fallback profiles\r\n     */\r\n    public static FindFallbackWithProfileId(profileId: string): string[] {\r\n        const returnArray = this._Fallbacks[profileId] || [];\r\n\r\n        returnArray.unshift(profileId);\r\n        return returnArray;\r\n    }\r\n\r\n    /**\r\n     * When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.\r\n     * The order of search:\r\n     *\r\n     * 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller\r\n     * 2) (If not found) search in the gamepad id and try using it (legacy versions only)\r\n     * 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)\r\n     * 4) return the generic trigger controller if none were found\r\n     *\r\n     * @param xrInput the xrInput to which a new controller is initialized\r\n     * @param scene the scene to which the model will be added\r\n     * @param forceProfile force a certain profile for this controller\r\n     * @returns A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found\r\n     */\r\n    public static GetMotionControllerWithXRInput(xrInput: XRInputSource, scene: Scene, forceProfile?: string): Promise<WebXRAbstractMotionController> {\r\n        const profileArray: string[] = [];\r\n        if (forceProfile) {\r\n            profileArray.push(forceProfile);\r\n        }\r\n        profileArray.push(...(xrInput.profiles || []));\r\n\r\n        // emulator support\r\n        if (profileArray.length && !profileArray[0]) {\r\n            // remove the first \"undefined\" that the emulator is adding\r\n            profileArray.pop();\r\n        }\r\n\r\n        // legacy support - try using the gamepad id\r\n        if (xrInput.gamepad && xrInput.gamepad.id) {\r\n            switch (xrInput.gamepad.id) {\r\n                case xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : undefined:\r\n                    // oculus in gamepad id\r\n                    profileArray.push(\"oculus-touch-v2\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // make sure microsoft/windows mixed reality works correctly\r\n        const windowsMRIdx = profileArray.indexOf(\"windows-mixed-reality\");\r\n        if (windowsMRIdx !== -1) {\r\n            profileArray.splice(windowsMRIdx, 0, \"microsoft-mixed-reality\");\r\n        }\r\n\r\n        if (!profileArray.length) {\r\n            profileArray.push(\"generic-trigger\");\r\n        }\r\n\r\n        if (this.UseOnlineRepository) {\r\n            const firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepository : this._LoadProfilesFromAvailableControllers;\r\n            const secondFunction = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllers : this._LoadProfileFromRepository;\r\n\r\n            return firstFunction.call(this, profileArray, xrInput, scene).catch(() => {\r\n                return secondFunction.call(this, profileArray, xrInput, scene);\r\n            });\r\n        } else {\r\n            // use only available functions\r\n            return this._LoadProfilesFromAvailableControllers(profileArray, xrInput, scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a new controller based on its profile. This function will be called by the controller classes themselves.\r\n     *\r\n     * If you are missing a profile, make sure it is imported in your source, otherwise it will not register.\r\n     *\r\n     * @param type the profile type to register\r\n     * @param constructFunction the function to be called when loading this profile\r\n     */\r\n    public static RegisterController(type: string, constructFunction: MotionControllerConstructor) {\r\n        this._AvailableControllers[type] = constructFunction;\r\n    }\r\n\r\n    /**\r\n     * Register a fallback to a specific profile.\r\n     * @param profileId the profileId that will receive the fallbacks\r\n     * @param fallbacks A list of fallback profiles\r\n     */\r\n    public static RegisterFallbacksForProfileId(profileId: string, fallbacks: string[]): void {\r\n        if (this._Fallbacks[profileId]) {\r\n            this._Fallbacks[profileId].push(...fallbacks);\r\n        } else {\r\n            this._Fallbacks[profileId] = fallbacks;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will update the list of profiles available in the repository\r\n     * @returns a promise that resolves to a map of profiles available online\r\n     */\r\n    public static UpdateProfilesList() {\r\n        this._ProfilesList = Tools.LoadFileAsync(this.BaseRepositoryUrl + \"/profiles/profilesList.json\", false).then((data) => {\r\n            return JSON.parse(data);\r\n        });\r\n        return this._ProfilesList;\r\n    }\r\n\r\n    /**\r\n     * Clear the controller's cache (usually happens at the end of a session)\r\n     */\r\n    public static ClearControllerCache() {\r\n        controllerCache.forEach((cacheItem) => {\r\n            cacheItem.meshes.forEach((mesh) => {\r\n                mesh.dispose(false, true);\r\n            });\r\n        });\r\n        controllerCache.length = 0;\r\n    }\r\n\r\n    private static _LoadProfileFromRepository(profileArray: string[], xrInput: XRInputSource, scene: Scene): Promise<WebXRAbstractMotionController> {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n                if (!this._ProfilesList) {\r\n                    return this.UpdateProfilesList();\r\n                } else {\r\n                    return this._ProfilesList;\r\n                }\r\n            })\r\n            .then((profilesList: { [profile: string]: string }) => {\r\n                // load the right profile\r\n                for (let i = 0; i < profileArray.length; ++i) {\r\n                    // defensive\r\n                    if (!profileArray[i]) {\r\n                        continue;\r\n                    }\r\n                    if (profilesList[profileArray[i]]) {\r\n                        return profileArray[i];\r\n                    }\r\n                }\r\n\r\n                throw new Error(`neither controller ${profileArray[0]} nor all fallbacks were found in the repository,`);\r\n            })\r\n            .then((profileToLoad: string) => {\r\n                // load the profile\r\n                if (!this._ProfileLoadingPromises[profileToLoad]) {\r\n                    this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${profileToLoad}/profile.json`, false).then(\r\n                        (data) => <IMotionControllerProfile>JSON.parse(data)\r\n                    );\r\n                }\r\n                return this._ProfileLoadingPromises[profileToLoad];\r\n            })\r\n            .then((profile: IMotionControllerProfile) => {\r\n                return new WebXRProfiledMotionController(scene, xrInput, profile, this.BaseRepositoryUrl, this.DisableControllerCache ? undefined : controllerCache);\r\n            });\r\n    }\r\n\r\n    private static _LoadProfilesFromAvailableControllers(profileArray: string[], xrInput: XRInputSource, scene: Scene) {\r\n        // check fallbacks\r\n        for (let i = 0; i < profileArray.length; ++i) {\r\n            // defensive\r\n            if (!profileArray[i]) {\r\n                continue;\r\n            }\r\n            const fallbacks = this.FindFallbackWithProfileId(profileArray[i]);\r\n            for (let j = 0; j < fallbacks.length; ++j) {\r\n                const constructionFunction = this._AvailableControllers[fallbacks[j]];\r\n                if (constructionFunction) {\r\n                    return Promise.resolve(constructionFunction(xrInput, scene));\r\n                }\r\n            }\r\n        }\r\n\r\n        throw new Error(`no controller requested was found in the available controllers list`);\r\n    }\r\n}\r\n\r\n// register the generic profile(s) here so we will at least have them\r\nWebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRGenericTriggerMotionController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// register fallbacks\r\nWebXRMotionControllerManager.DefaultFallbacks();\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { WebXRAbstractMotionController } from \"./motionController/webXRAbstractMotionController\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\nlet idCount = 0;\r\n\r\n/**\r\n * Configuration options for the WebXR controller creation\r\n */\r\nexport interface IWebXRControllerOptions {\r\n    /**\r\n     * Should the controller mesh be animated when a user interacts with it\r\n     * The pressed buttons / thumbstick and touchpad animations will be disabled\r\n     */\r\n    disableMotionControllerAnimation?: boolean;\r\n    /**\r\n     * Do not load the controller mesh, in case a different mesh needs to be loaded.\r\n     */\r\n    doNotLoadControllerMesh?: boolean;\r\n    /**\r\n     * Force a specific controller type for this controller.\r\n     * This can be used when creating your own profile or when testing different controllers\r\n     */\r\n    forceControllerProfile?: string;\r\n    /**\r\n     * Defines a rendering group ID for meshes that will be loaded.\r\n     * This is for the default controllers only.\r\n     */\r\n    renderingGroupId?: number;\r\n}\r\n\r\n/**\r\n * Represents an XR controller\r\n */\r\nexport class WebXRInputSource {\r\n    private _tmpVector = new Vector3();\r\n    private _uniqueId: string;\r\n    private _disposed = false;\r\n\r\n    /**\r\n     * Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if that's the case only the pointer from the head will be available\r\n     */\r\n    public grip?: AbstractMesh;\r\n    /**\r\n     * If available, this is the gamepad object related to this controller.\r\n     * Using this object it is possible to get click events and trackpad changes of the\r\n     * webxr controller that is currently being used.\r\n     */\r\n    public motionController?: WebXRAbstractMotionController;\r\n    /**\r\n     * Event that fires when the controller is removed/disposed.\r\n     * The object provided as event data is this controller, after associated assets were disposed.\r\n     * uniqueId is still available.\r\n     */\r\n    public onDisposeObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Will be triggered when the mesh associated with the motion controller is done loading.\r\n     * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh\r\n     * A shortened version of controller -> motion controller -> on mesh loaded.\r\n     */\r\n    public onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n    /**\r\n     * Observers registered here will trigger when a motion controller profile was assigned to this xr controller\r\n     */\r\n    public onMotionControllerInitObservable = new Observable<WebXRAbstractMotionController>();\r\n    /**\r\n     * Pointer which can be used to select objects or attach a visible laser to\r\n     */\r\n    public pointer: AbstractMesh;\r\n\r\n    /**\r\n     * The last XRPose the was calculated on the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRPose?: XRPose;\r\n\r\n    /**\r\n     * Creates the input source object\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRInputControllerSupport\r\n     * @param _scene the scene which the controller should be associated to\r\n     * @param inputSource the underlying input source for the controller\r\n     * @param _options options for this controller creation\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        /** The underlying input source for the controller  */\r\n        public inputSource: XRInputSource,\r\n        private _options: IWebXRControllerOptions = {}\r\n    ) {\r\n        this._uniqueId = `controller-${idCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;\r\n\r\n        this.pointer = new AbstractMesh(`${this._uniqueId}-pointer`, _scene);\r\n        this.pointer.rotationQuaternion = new Quaternion();\r\n\r\n        if (this.inputSource.gripSpace) {\r\n            this.grip = new AbstractMesh(`${this._uniqueId}-grip`, this._scene);\r\n            this.grip.rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n\r\n        // for now only load motion controllers if gamepad object available\r\n        if (this.inputSource.gamepad && this.inputSource.targetRayMode === \"tracked-pointer\") {\r\n            WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(\r\n                (motionController) => {\r\n                    this.motionController = motionController;\r\n                    this.onMotionControllerInitObservable.notifyObservers(motionController);\r\n                    // should the model be loaded?\r\n                    if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {\r\n                        this.motionController.loadModel().then((success) => {\r\n                            if (success && this.motionController && this.motionController.rootMesh) {\r\n                                if (this._options.renderingGroupId) {\r\n                                    // anything other than 0?\r\n                                    this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;\r\n                                    this.motionController.rootMesh.getChildMeshes(false).forEach((mesh) => (mesh.renderingGroupId = this._options.renderingGroupId!));\r\n                                }\r\n                                this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);\r\n                                this.motionController.rootMesh.parent = this.grip || this.pointer;\r\n                                this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;\r\n                            }\r\n                            // make sure to dispose is the controller is already disposed\r\n                            if (this._disposed) {\r\n                                this.motionController?.dispose();\r\n                            }\r\n                        });\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Warn(`Could not find a matching motion controller for the registered input source`);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get this controllers unique id\r\n     */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        if (this.grip) {\r\n            this.grip.dispose(true);\r\n        }\r\n        if (this.motionController) {\r\n            this.motionController.dispose();\r\n        }\r\n        this.pointer.dispose(true);\r\n        this.onMotionControllerInitObservable.clear();\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this._disposed = true;\r\n    }\r\n\r\n    /**\r\n     * Gets a world space ray coming from the pointer or grip\r\n     * @param result the resulting ray\r\n     * @param gripIfAvailable use the grip mesh instead of the pointer, if available\r\n     */\r\n    public getWorldPointerRayToRef(result: Ray, gripIfAvailable: boolean = false) {\r\n        const object = gripIfAvailable && this.grip ? this.grip : this.pointer;\r\n        Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);\r\n        result.direction.normalize();\r\n        result.origin.copyFrom(object.absolutePosition);\r\n        result.length = 1000;\r\n    }\r\n\r\n    /**\r\n     * Updates the controller pose based on the given XRFrame\r\n     * @param xrFrame xr frame to update the pose with\r\n     * @param referenceSpace reference space to use\r\n     * @param xrCamera the xr camera, used for parenting\r\n     * @param xrSessionManager the session manager used to get the world reference system\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, xrCamera: WebXRCamera, xrSessionManager: WebXRSessionManager) {\r\n        const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);\r\n        this._lastXRPose = pose;\r\n\r\n        // Update the pointer mesh\r\n        if (pose) {\r\n            const pos = pose.transform.position;\r\n            this.pointer.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\r\n            const orientation = pose.transform.orientation;\r\n            this.pointer.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this.pointer.position.z *= -1;\r\n                this.pointer.rotationQuaternion!.z *= -1;\r\n                this.pointer.rotationQuaternion!.w *= -1;\r\n            }\r\n            this.pointer.parent = xrCamera.parent;\r\n            this.pointer.scaling.setAll(xrSessionManager.worldScalingFactor);\r\n        }\r\n\r\n        // Update the grip mesh if it exists\r\n        if (this.inputSource.gripSpace && this.grip) {\r\n            const pose = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);\r\n            if (pose) {\r\n                const pos = pose.transform.position;\r\n                const orientation = pose.transform.orientation;\r\n                this.grip.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\r\n                this.grip.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n                if (!this._scene.useRightHandedSystem) {\r\n                    this.grip.position.z *= -1;\r\n                    this.grip.rotationQuaternion!.z *= -1;\r\n                    this.grip.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n            this.grip.parent = xrCamera.parent;\r\n            this.grip.scaling.setAll(xrSessionManager.worldScalingFactor);\r\n        }\r\n        if (this.motionController) {\r\n            // either update buttons only or also position, if in gamepad mode\r\n            this.motionController.updateFromXRFrame(xrFrame);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IWebXRControllerOptions } from \"./webXRInputSource\";\r\nimport { WebXRInputSource } from \"./webXRInputSource\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\n\r\n/**\r\n * The schema for initialization options of the XR Input class\r\n */\r\nexport interface IWebXRInputOptions {\r\n    /**\r\n     * If set to true no model will be automatically loaded\r\n     */\r\n    doNotLoadControllerMeshes?: boolean;\r\n\r\n    /**\r\n     * If set, this profile will be used for all controllers loaded (for example \"microsoft-mixed-reality\")\r\n     * If not found, the xr input profile data will be used.\r\n     * Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/\r\n     */\r\n    forceInputProfile?: string;\r\n\r\n    /**\r\n     * Do not send a request to the controller repository to load the profile.\r\n     *\r\n     * Instead, use the controllers available in babylon itself.\r\n     */\r\n    disableOnlineControllerRepository?: boolean;\r\n\r\n    /**\r\n     * A custom URL for the controllers repository\r\n     */\r\n    customControllersRepositoryURL?: string;\r\n\r\n    /**\r\n     * Should the controller model's components not move according to the user input\r\n     */\r\n    disableControllerAnimation?: boolean;\r\n\r\n    /**\r\n     * Optional options to pass to the controller. Will be overridden by the Input options where applicable\r\n     */\r\n    controllerOptions?: IWebXRControllerOptions;\r\n}\r\n/**\r\n * XR input used to track XR inputs such as controllers/rays\r\n */\r\nexport class WebXRInput implements IDisposable {\r\n    /**\r\n     * XR controllers being tracked\r\n     */\r\n    public controllers: Array<WebXRInputSource> = [];\r\n    private _frameObserver: Nullable<Observer<any>>;\r\n    private _sessionEndedObserver: Nullable<Observer<any>>;\r\n    private _sessionInitObserver: Nullable<Observer<any>>;\r\n    /**\r\n     * Event when a controller has been connected/added\r\n     */\r\n    public onControllerAddedObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Event when a controller has been removed/disconnected\r\n     */\r\n    public onControllerRemovedObservable = new Observable<WebXRInputSource>();\r\n\r\n    /**\r\n     * Initializes the WebXRInput\r\n     * @param xrSessionManager the xr session manager for this session\r\n     * @param xrCamera the WebXR camera for this session. Mainly used for teleportation\r\n     * @param _options = initialization options for this xr input\r\n     */\r\n    public constructor(\r\n        /**\r\n         * the xr session manager for this session\r\n         */\r\n        public xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * the WebXR camera for this session. Mainly used for teleportation\r\n         */\r\n        public xrCamera: WebXRCamera,\r\n        private readonly _options: IWebXRInputOptions = {}\r\n    ) {\r\n        // Remove controllers when exiting XR\r\n        this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._addAndRemoveControllers(\r\n                [],\r\n                this.controllers.map((c) => {\r\n                    return c.inputSource;\r\n                })\r\n            );\r\n        });\r\n\r\n        this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {\r\n            session.addEventListener(\"inputsourceschange\", this._onInputSourcesChange);\r\n        });\r\n\r\n        this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {\r\n            // Update controller pose info\r\n            this.controllers.forEach((controller) => {\r\n                controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace, this.xrCamera, this.xrSessionManager);\r\n            });\r\n        });\r\n\r\n        if (this._options.customControllersRepositoryURL) {\r\n            WebXRMotionControllerManager.BaseRepositoryUrl = this._options.customControllersRepositoryURL;\r\n        }\r\n\r\n        WebXRMotionControllerManager.UseOnlineRepository = !this._options.disableOnlineControllerRepository;\r\n        if (WebXRMotionControllerManager.UseOnlineRepository) {\r\n            // pre-load the profiles list to load the controllers quicker afterwards\r\n            try {\r\n                WebXRMotionControllerManager.UpdateProfilesList().catch(() => {\r\n                    WebXRMotionControllerManager.UseOnlineRepository = false;\r\n                });\r\n            } catch (e) {\r\n                WebXRMotionControllerManager.UseOnlineRepository = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onInputSourcesChange = (event: XRInputSourceChangeEvent) => {\r\n        this._addAndRemoveControllers(event.added, event.removed);\r\n    };\r\n\r\n    private _addAndRemoveControllers(addInputs: readonly XRInputSource[], removeInputs: readonly XRInputSource[]) {\r\n        // Add controllers if they don't already exist\r\n        const sources = this.controllers.map((c) => {\r\n            return c.inputSource;\r\n        });\r\n        for (const input of addInputs) {\r\n            if (sources.indexOf(input) === -1) {\r\n                const controller = new WebXRInputSource(this.xrSessionManager.scene, input, {\r\n                    ...(this._options.controllerOptions || {}),\r\n                    forceControllerProfile: this._options.forceInputProfile,\r\n                    doNotLoadControllerMesh: this._options.doNotLoadControllerMeshes,\r\n                    disableMotionControllerAnimation: this._options.disableControllerAnimation,\r\n                });\r\n                this.controllers.push(controller);\r\n                this.onControllerAddedObservable.notifyObservers(controller);\r\n            }\r\n        }\r\n\r\n        // Remove and dispose of controllers to be disposed\r\n        const keepControllers: Array<WebXRInputSource> = [];\r\n        const removedControllers: Array<WebXRInputSource> = [];\r\n        this.controllers.forEach((c) => {\r\n            if (removeInputs.indexOf(c.inputSource) === -1) {\r\n                keepControllers.push(c);\r\n            } else {\r\n                removedControllers.push(c);\r\n            }\r\n        });\r\n        this.controllers = keepControllers;\r\n        removedControllers.forEach((c) => {\r\n            this.onControllerRemovedObservable.notifyObservers(c);\r\n            c.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this.controllers.forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);\r\n        this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);\r\n        this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);\r\n        this.onControllerAddedObservable.clear();\r\n        this.onControllerRemovedObservable.clear();\r\n\r\n        // clear the controller cache\r\n        WebXRMotionControllerManager.ClearControllerCache();\r\n    }\r\n}\r\n", "import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = (options.tessellation || 24) | 0;\r\n    const subdivisions: number = (options.subdivisions || 1) | 0;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\nMesh.CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a torus\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * diameter the diameter of the torus, optional default 1\r\n * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the torus\r\n */\r\nexport function CreateTorusVertexData(options: { diameter?: number; thickness?: number; tessellation?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }) {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const diameter = options.diameter || 1;\r\n    const thickness = options.thickness || 0.5;\r\n    const tessellation = (options.tessellation || 16) | 0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const stride = tessellation + 1;\r\n\r\n    for (let i = 0; i <= tessellation; i++) {\r\n        const u = i / tessellation;\r\n\r\n        const outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\r\n\r\n        const transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\r\n\r\n        for (let j = 0; j <= tessellation; j++) {\r\n            const v = 1 - j / tessellation;\r\n\r\n            const innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\r\n            const dx = Math.cos(innerAngle);\r\n            const dy = Math.sin(innerAngle);\r\n\r\n            // Create a vertex.\r\n            let normal = new Vector3(dx, dy, 0);\r\n            let position = normal.scale(thickness / 2);\r\n            const textureCoordinate = new Vector2(u, v);\r\n\r\n            position = Vector3.TransformCoordinates(position, transform);\r\n            normal = Vector3.TransformNormal(normal, transform);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\r\n\r\n            // And create indices for two triangles.\r\n            const nextI = (i + 1) % stride;\r\n            const nextJ = (j + 1) % stride;\r\n\r\n            indices.push(i * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus\r\n */\r\nexport function CreateTorus(\r\n    name: string,\r\n    options: { diameter?: number; thickness?: number; tessellation?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torus = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torus._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusVertexData(options);\r\n\r\n    vertexData.applyToMesh(torus, options.updatable);\r\n\r\n    return torus;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorus instead\r\n */\r\nexport const TorusBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorus,\r\n};\r\n\r\nVertexData.CreateTorus = CreateTorusVertexData;\r\n\r\nMesh.CreateTorus = (name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        diameter,\r\n        thickness,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorus(name, options, scene);\r\n};\r\n", "import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE,\r\n        /** The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\r\n        public epsilon: number = Epsilon\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(\r\n        mesh: DeepImmutable<AbstractMesh>,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        return Ray.CreateFromToToRef(origin, end, result, world);\r\n    }\r\n\r\n    /**\r\n     * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param result the object to store the result\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the ref ray\r\n     */\r\n    public static CreateFromToToRef(origin: Vector3, end: Vector3, result: Ray, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        result.origin.copyFrom(origin);\r\n        const direction = end.subtractToRef(origin, result.direction);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        result.length = length;\r\n        result.direction.normalize();\r\n\r\n        return Ray.TransformToRef(result, world, result);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     * @returns the updated result ray\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): Ray {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n        result.epsilon = ray.epsilon;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @internal */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @internal */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @internal */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): PickingInfo;\r\n\r\n        /** @internal */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @internal */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera && !(camera = this.activeCamera!)) {\r\n        return this;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera && !(camera = this.activeCamera!)) {\r\n        throw new Error(\"Active camera not set\");\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n    result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos: PickingInfo[] = [];\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\r\n    get: () => true,\r\n    enumerable: false,\r\n    configurable: false,\r\n});\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (origin) {\r\n        refRay.origin.copyFrom(origin);\r\n    } else {\r\n        refRay.origin.copyFrom(this.position);\r\n    }\r\n    const forward = TmpVectors.Vector3[2];\r\n    forward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    const worldForward = TmpVectors.Vector3[3];\r\n    Vector3.TransformNormalToRef(forward, transform, worldForward);\r\n    Vector3.NormalizeToRef(worldForward, refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n", "import { serialize, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(_faceIndex?: number): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param _viewMatrix The view transform matrix of the light (optional).\r\n     * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(_viewMatrix?: Matrix, _renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = [] as AbstractMesh[];\r\n        this.excludedMeshes = [] as AbstractMesh[];\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * @returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n", "import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n", "import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n\r\n    /**\r\n     * Use the grip space instead of the pointer space for selection, if available.\r\n     */\r\n    forceGripIfAvailable?: boolean;\r\n\r\n    /**\r\n     * If set to true, the hand rays will be disabled and the user will be able to look and pick objects.\r\n     * This requires system support (like in the vision OS) and will not work in all systems.\r\n     * @experimental - this is an experimental feature and might change int he future\r\n     */\r\n    lookAndPickMode?: boolean;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(this._options.forceGripIfAvailable && xrController.grip ? xrController.grip : xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n            case \"transient-pointer\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRControllerPointerSelectionOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n\r\n        // force look and pick mode if using WebXR on safari, assuming it is vision OS\r\n        // Only if not explicitly set. If set to false, it will not be forced\r\n        if (this._options.lookAndPickMode === undefined && (this._scene.getEngine()._badDesktopOS || this._scene.getEngine()._badOS)) {\r\n            this._options.lookAndPickMode = true;\r\n        }\r\n\r\n        // look and pick mode extra state changes\r\n        if (this._options.lookAndPickMode) {\r\n            this._options.enablePointerSelectionOnAllControllers = true;\r\n            this.displayLaserPointer = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController, true);\r\n        this._addNewAttachObserver(\r\n            this._options.xrInput.onControllerRemovedObservable,\r\n            (controller) => {\r\n                // REMOVE the controller\r\n                this._detachController(controller.uniqueId);\r\n            },\r\n            true\r\n        );\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // look and pick mode\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if (this._options.lookAndPickMode && controllerData.xrController?.inputSource.targetRayMode !== \"transient-pointer\") {\r\n                return;\r\n            }\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition =\r\n                    this._options.forceGripIfAvailable && controllerData.xrController.grip\r\n                        ? controllerData.xrController.grip.position\r\n                        : controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay, this._options.forceGripIfAvailable);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth() / camera.rigCameras.length, scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, camera.getTransformationMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y) &&\r\n                        this._screenCoordinatesRef.x !== Infinity &&\r\n                        this._screenCoordinatesRef.y !== Infinity\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n                controllerData.pick.originMesh = controllerData.xrController.pointer;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                // force a pointer up if switching controllers\r\n                                // get the controller that was attached before\r\n                                const prevController = this._controllers[this._attachedController];\r\n                                if (prevController && prevController.pointerDownTriggered && !prevController.finalPointerUpTriggered) {\r\n                                    this._augmentPointerInit(pointerEventInit, prevController.id, prevController.screenCoordinates);\r\n                                    this._scene.simulatePointerUp(new PickingInfo(), {\r\n                                        pointerId: prevController.id,\r\n                                        pointerType: \"xr\",\r\n                                    });\r\n                                    prevController.finalPointerUpTriggered = true;\r\n                                }\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._xrSessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                    if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        controllerData.pointerDownTriggered = true;\r\n                        (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                        (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                    }\r\n                });\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._xrSessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                    if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                        this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                        (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                    }\r\n                });\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    // For future reference - this is an issue in the WebXR typings.\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\r\n                controllerData.finalPointerUpTriggered = true;\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n", "import type { IEasingFunction } from \"./easing\";\r\n\r\n/**\r\n * Defines an interface which represents an animation key frame\r\n */\r\nexport interface IAnimationKey {\r\n    /**\r\n     * Frame of the key frame\r\n     */\r\n    frame: number;\r\n    /**\r\n     * Value at the specifies key frame\r\n     */\r\n    value: any;\r\n    /**\r\n     * The input tangent for the cubic hermite spline\r\n     */\r\n    inTangent?: any;\r\n    /**\r\n     * The output tangent for the cubic hermite spline\r\n     */\r\n    outTangent?: any;\r\n    /**\r\n     * The animation interpolation type\r\n     */\r\n    interpolation?: AnimationKeyInterpolation;\r\n    /**\r\n     * Property defined by UI tools to link (or not ) the tangents\r\n     */\r\n    lockedTangent?: boolean;\r\n    /**\r\n     * The easing function associated with the key frame (optional). If not defined, the easing function defined at the animation level (if any) will be used instead\r\n     */\r\n    easingFunction?: IEasingFunction;\r\n}\r\n\r\n/**\r\n * Enum for the animation key frame interpolation type\r\n */\r\nexport enum AnimationKeyInterpolation {\r\n    /**\r\n     * Use tangents to interpolate between start and end values.\r\n     */\r\n    NONE = 0,\r\n    /**\r\n     * Do not interpolate between keys and use the start key value only. Tangents are ignored\r\n     */\r\n    STEP = 1,\r\n}\r\n", "/**\r\n * Represents the range of an animation\r\n */\r\nexport class AnimationRange {\r\n    /**\r\n     * Initializes the range of an animation\r\n     * @param name The name of the animation range\r\n     * @param from The starting frame of the animation\r\n     * @param to The ending frame of the animation\r\n     */\r\n    constructor(\r\n        /**The name of the animation range**/\r\n        public name: string,\r\n        /**The starting frame of the animation */\r\n        public from: number,\r\n        /**The ending frame of the animation*/\r\n        public to: number\r\n    ) {}\r\n\r\n    /**\r\n     * Makes a copy of the animation range\r\n     * @returns A copy of the animation range\r\n     */\r\n    public clone(): AnimationRange {\r\n        return new AnimationRange(this.name, this.from, this.to);\r\n    }\r\n}\r\n", "import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport type { DeepImmutable, Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nexport const _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nexport const _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nexport const _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nexport const _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nexport const _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n// Color4\r\nexport const _staticOffsetValueColor4: DeepImmutable<Color4> = Object.freeze(new Color4(0, 0, 0, 0));\r\n\r\n/**\r\n * Options to be used when creating an additive animation\r\n */\r\nexport interface IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * The frame that the animation should be relative to (if not provided, 0 will be used)\r\n     */\r\n    referenceFrame?: number;\r\n    /**\r\n     * The name of the animation range to convert to additive. If not provided, fromFrame / toFrame will be used\r\n     * If fromFrame / toFrame are not provided either, the whole animation will be converted to additive\r\n     */\r\n    range?: string;\r\n    /**\r\n     * If true, the original animation will be cloned and converted to additive. If false, the original animation will be converted to additive (default is false)\r\n     */\r\n    cloneOriginalAnimation?: boolean;\r\n    /**\r\n     * The name of the cloned animation if cloneOriginalAnimation is true. If not provided, use the original animation name\r\n     */\r\n    clonedAnimationName?: string;\r\n    /**\r\n     * Together with toFrame, defines the range of the animation to convert to additive. Will only be used if range is not provided\r\n     * If range and fromFrame / toFrame are not provided, the whole animation will be converted to additive\r\n     */\r\n    fromFrame?: number;\r\n    /**\r\n     * Together with fromFrame, defines the range of the animation to convert to additive.\r\n     */\r\n    toFrame?: number;\r\n    /**\r\n     * If true, the key frames will be clipped to the range specified by range or fromFrame / toFrame (default is false)\r\n     */\r\n    clipKeys?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\nconst evaluateAnimationState: _IAnimationState = {\r\n    key: 0,\r\n    repeatCount: 0,\r\n    loopMode: 2 /*Animation.ANIMATIONLOOPMODE_CONSTANT*/,\r\n};\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @internal Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame?: number, range?: string, cloneOriginal?: boolean, clonedName?: string): Animation;\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param options defines the options to use when converting ey keyframes\r\n     * @returns a new Animation if options.cloneOriginalAnimation is true or the original Animation if options.cloneOriginalAnimation is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, options?: IMakeAnimationAdditiveOptions): Animation;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimation: Animation,\r\n        referenceFrameOrOptions?: number | IMakeAnimationAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): Animation {\r\n        let options: IMakeAnimationAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions ?? 0,\r\n                range: range,\r\n                cloneOriginalAnimation: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animation = sourceAnimation;\r\n\r\n        if (options.cloneOriginalAnimation) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = options.clonedAnimationName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (options.range) {\r\n            const rangeValue = animation.getRange(options.range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        } else {\r\n            from = options.fromFrame ?? from;\r\n            to = options.toFrame ?? to;\r\n        }\r\n\r\n        if (from !== firstKey.frame) {\r\n            startIndex = animation.createKeyForFrame(from);\r\n        }\r\n\r\n        if (to !== lastKey.frame) {\r\n            endIndex = animation.createKeyForFrame(to);\r\n        }\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Interpolate the reference value from the animation\r\n        else {\r\n            evaluateAnimationState.key = 0;\r\n            const value = animation._interpolate(referenceFrame, evaluateAnimationState);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        let startFrame = Number.MAX_VALUE;\r\n        const clippedKeys: Nullable<IAnimationKey[]> = options.clipKeys ? [] : null;\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            let key = animation._keys[index];\r\n\r\n            if (clippedKeys) {\r\n                key = {\r\n                    frame: key.frame,\r\n                    value: key.value.clone ? key.value.clone() : key.value,\r\n                    inTangent: key.inTangent,\r\n                    outTangent: key.outTangent,\r\n                    interpolation: key.interpolation,\r\n                    lockedTangent: key.lockedTangent,\r\n                };\r\n                if (startFrame === Number.MAX_VALUE) {\r\n                    startFrame = key.frame;\r\n                }\r\n                key.frame -= startFrame;\r\n                clippedKeys.push(key);\r\n            }\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        if (clippedKeys) {\r\n            animation.setKeys(clippedKeys, true);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        evaluateAnimationState.key = 0;\r\n        return this._interpolate(currentFrame, evaluateAnimationState);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState, searchClosestKeyOnly = false): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        const keysLength = keys.length;\r\n\r\n        let key = state.key;\r\n\r\n        while (key >= 0 && currentFrame < keys[key].frame) {\r\n            --key;\r\n        }\r\n\r\n        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\r\n            ++key;\r\n        }\r\n\r\n        state.key = key;\r\n\r\n        if (key < 0) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[0].value);\r\n        } else if (key + 1 > keysLength - 1) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[keysLength - 1].value);\r\n        }\r\n\r\n        const startKey = keys[key];\r\n        const endKey = keys[key + 1];\r\n\r\n        if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {\r\n            return undefined;\r\n        }\r\n\r\n        const startValue = this._getKeyValue(startKey.value);\r\n        const endValue = this._getKeyValue(endKey.value);\r\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n            if (endKey.frame > currentFrame) {\r\n                return startValue;\r\n            } else {\r\n                return endValue;\r\n            }\r\n        }\r\n\r\n        const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n        const frameDelta = endKey.frame - startKey.frame;\r\n\r\n        // gradient : percent of currentFrame between the frame inf and the frame sup\r\n        let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n        // check for easingFunction and correction of gradient\r\n        const easingFunction = startKey.easingFunction || this.getEasingFunction();\r\n        if (easingFunction !== null) {\r\n            gradient = easingFunction.ease(gradient);\r\n        }\r\n\r\n        switch (this.dataType) {\r\n            // Float\r\n            case Animation.ANIMATIONTYPE_FLOAT: {\r\n                const floatValue = useTangent\r\n                    ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                    : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return floatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return (state.offsetValue ?? 0) * state.repeatCount + floatValue;\r\n                }\r\n                break;\r\n            }\r\n            // Quaternion\r\n            case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                const quatValue = useTangent\r\n                    ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return quatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return quatValue.addInPlace((state.offsetValue || _staticOffsetValueQuaternion).scale(state.repeatCount));\r\n                }\r\n\r\n                return quatValue;\r\n            }\r\n            // Vector3\r\n            case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                const vec3Value = useTangent\r\n                    ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return vec3Value.add((state.offsetValue || _staticOffsetValueVector3).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Vector2\r\n            case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                const vec2Value = useTangent\r\n                    ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec2Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return vec2Value.add((state.offsetValue || _staticOffsetValueVector2).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Size\r\n            case Animation.ANIMATIONTYPE_SIZE: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient).add((state.offsetValue || _staticOffsetValueSize).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color3\r\n            case Animation.ANIMATIONTYPE_COLOR3: {\r\n                const color3Value = useTangent\r\n                    ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return color3Value.add((state.offsetValue || _staticOffsetValueColor3).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color4\r\n            case Animation.ANIMATIONTYPE_COLOR4: {\r\n                const color4Value = useTangent\r\n                    ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color4Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return color4Value.add((state.offsetValue || _staticOffsetValueColor4).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Matrix\r\n            case Animation.ANIMATIONTYPE_MATRIX: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO: {\r\n                        if (Animation.AllowMatricesInterpolation) {\r\n                            return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                        }\r\n                        return startValue;\r\n                    }\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT: {\r\n                        return startValue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>, dontClone = false): void {\r\n        this._keys = !dontClone ? values.slice(0) : values;\r\n    }\r\n\r\n    /**\r\n     * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame\r\n     * @param frame Frame number\r\n     * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key\r\n     */\r\n    public createKeyForFrame(frame: number) {\r\n        // Find the key corresponding to frame\r\n        evaluateAnimationState.key = 0;\r\n        const value = this._interpolate(frame, evaluateAnimationState, true);\r\n\r\n        if (!value) {\r\n            // A key corresponding to this frame already exists\r\n            return this._keys[evaluateAnimationState.key].frame === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;\r\n        }\r\n\r\n        // The frame is between two keys, so create a new key\r\n        const newKey: IAnimationKey = {\r\n            frame,\r\n            value: value.clone ? value.clone() : value,\r\n        };\r\n\r\n        this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);\r\n\r\n        return evaluateAnimationState.key + 1;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n    /**\r\n     * Yoyo Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_YOYO = 4;\r\n    /**\r\n     * Relative Loop Mode (add to current value of animated object, unlike ANIMATIONLOOPMODE_RELATIVE)\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output: Animation[] = [];\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs: Animation[] = [];\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n", "import { BezierCurve } from \"../Maths/math.path\";\r\n\r\n/**\r\n * This represents the main contract an easing function should follow.\r\n * Easing functions are used throughout the animation system.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport interface IEasingFunction {\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * The link below provides some of the most common examples of easing functions.\r\n     * @see https://easings.net/\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    ease(gradient: number): number;\r\n}\r\n\r\n/**\r\n * Base class used for every default easing function.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Interpolation follows the mathematical formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEIN = 0;\r\n\r\n    /**\r\n     * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEOUT = 1;\r\n\r\n    /**\r\n     * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.\r\n     */\r\n    public static readonly EASINGMODE_EASEINOUT = 2;\r\n\r\n    private _easingMode = EasingFunction.EASINGMODE_EASEIN;\r\n\r\n    /**\r\n     * Sets the easing mode of the current function.\r\n     * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)\r\n     */\r\n    public setEasingMode(easingMode: number) {\r\n        const n = Math.min(Math.max(easingMode, 0), 2);\r\n        this._easingMode = n;\r\n    }\r\n    /**\r\n     * Gets the current easing mode.\r\n     * @returns the easing mode\r\n     */\r\n    public getEasingMode(): number {\r\n        return this._easingMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public easeInCore(gradient: number): number {\r\n        throw new Error(\"You must implement this method\");\r\n    }\r\n\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    public ease(gradient: number): number {\r\n        switch (this._easingMode) {\r\n            case EasingFunction.EASINGMODE_EASEIN:\r\n                return this.easeInCore(gradient);\r\n            case EasingFunction.EASINGMODE_EASEOUT:\r\n                return 1 - this.easeInCore(1 - gradient);\r\n        }\r\n\r\n        if (gradient >= 0.5) {\r\n            return (1 - this.easeInCore((1 - gradient) * 2)) * 0.5 + 0.5;\r\n        }\r\n\r\n        return this.easeInCore(gradient * 2) * 0.5;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a circle shape (see link below).\r\n * @see https://easings.net/#easeInCirc\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class CircleEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        gradient = Math.max(0, Math.min(1, gradient));\r\n        return 1.0 - Math.sqrt(1.0 - gradient * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a ease back shape (see link below).\r\n * @see https://easings.net/#easeInBack\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BackEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a back ease easing\r\n     * @see https://easings.net/#easeInBack\r\n     * @param amplitude Defines the amplitude of the function\r\n     */\r\n    constructor(\r\n        /** Defines the amplitude of the function */\r\n        public amplitude: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const num = Math.max(0, this.amplitude);\r\n        return Math.pow(gradient, 3.0) - gradient * num * Math.sin(3.1415926535897931 * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bouncing shape (see link below).\r\n * @see https://easings.net/#easeInBounce\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BounceEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bounce easing\r\n     * @see https://easings.net/#easeInBounce\r\n     * @param bounces Defines the number of bounces\r\n     * @param bounciness Defines the amplitude of the bounce\r\n     */\r\n    constructor(\r\n        /** Defines the number of bounces */\r\n        public bounces: number = 3,\r\n        /** Defines the amplitude of the bounce */\r\n        public bounciness: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.bounces);\r\n        let bounciness = this.bounciness;\r\n        if (bounciness <= 1.0) {\r\n            bounciness = 1.001;\r\n        }\r\n        const num9 = Math.pow(bounciness, y);\r\n        const num5 = 1.0 - bounciness;\r\n        const num4 = (1.0 - num9) / num5 + num9 * 0.5;\r\n        const num15 = gradient * num4;\r\n        const num65 = Math.log(-num15 * (1.0 - bounciness) + 1.0) / Math.log(bounciness);\r\n        const num3 = Math.floor(num65);\r\n        const num13 = num3 + 1.0;\r\n        const num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);\r\n        const num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);\r\n        const num7 = (num8 + num12) * 0.5;\r\n        const num6 = gradient - num7;\r\n        const num2 = num7 - num8;\r\n        return (-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2) * (num6 + num2);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 3 shape (see link below).\r\n * @see https://easings.net/#easeInCubic\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class CubicEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an elastic shape (see link below).\r\n * @see https://easings.net/#easeInElastic\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class ElasticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an elastic easing function\r\n     * @see https://easings.net/#easeInElastic\r\n     * @param oscillations Defines the number of oscillations\r\n     * @param springiness Defines the amplitude of the oscillations\r\n     */\r\n    constructor(\r\n        /** Defines the number of oscillations*/\r\n        public oscillations: number = 3,\r\n        /** Defines the amplitude of the oscillations*/\r\n        public springiness: number = 3\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        let num2;\r\n        const num3 = Math.max(0.0, this.oscillations);\r\n        const num = Math.max(0.0, this.springiness);\r\n\r\n        if (num == 0) {\r\n            num2 = gradient;\r\n        } else {\r\n            num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);\r\n        }\r\n        return num2 * Math.sin((6.2831853071795862 * num3 + 1.5707963267948966) * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an exponential shape (see link below).\r\n * @see https://easings.net/#easeInExpo\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class ExponentialEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an exponential easing function\r\n     * @see https://easings.net/#easeInExpo\r\n     * @param exponent Defines the exponent of the function\r\n     */\r\n    constructor(\r\n        /** Defines the exponent of the function */\r\n        public exponent: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        if (this.exponent <= 0) {\r\n            return gradient;\r\n        }\r\n\r\n        return (Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class PowerEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an power base easing function\r\n     * @see https://easings.net/#easeInQuad\r\n     * @param power Defines the power of the function\r\n     */\r\n    constructor(\r\n        /** Defines the power of the function */\r\n        public power: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.power);\r\n        return Math.pow(gradient, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 2 shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuadraticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 4 shape (see link below).\r\n * @see https://easings.net/#easeInQuart\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuarticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 5 shape (see link below).\r\n * @see https://easings.net/#easeInQuint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuinticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a sin shape (see link below).\r\n * @see https://easings.net/#easeInSine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class SineEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return 1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient));\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bezier shape (see link below).\r\n * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BezierCurveEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bezier function\r\n     * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n     * @param x1 Defines the x component of the start tangent in the bezier curve\r\n     * @param y1 Defines the y component of the start tangent in the bezier curve\r\n     * @param x2 Defines the x component of the end tangent in the bezier curve\r\n     * @param y2 Defines the y component of the end tangent in the bezier curve\r\n     */\r\n    constructor(\r\n        /** Defines the x component of the start tangent in the bezier curve */\r\n        public x1: number = 0,\r\n        /** Defines the y component of the start tangent in the bezier curve */\r\n        public y1: number = 0,\r\n        /** Defines the x component of the end tangent in the bezier curve */\r\n        public x2: number = 1,\r\n        /** Defines the y component of the end tangent in the bezier curve */\r\n        public y2: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IndicesArray } from \"../types\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\ndeclare module \"./subMesh\" {\r\n    export interface SubMesh {\r\n        /** @internal */\r\n        _projectOnTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number;\r\n        /** @internal */\r\n        _projectOnUnIndexedTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n        /**\r\n         * Projects a point on this submesh and stores the result in \"ref\"\r\n         *\r\n         * @param vector point to project\r\n         * @param positions defines mesh's positions array\r\n         * @param indices defines mesh's indices array\r\n         * @param ref vector that will store the result\r\n         * @returns distance from the point and the submesh, or -1 if the mesh rendering mode doesn't support projections\r\n         */\r\n        projectToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n        const indexA = indices[index];\r\n        const indexB = indices[index + 1];\r\n        const indexC = indices[index + 2];\r\n\r\n        if (checkStopper && indexC === 0xffffffff) {\r\n            index += 2;\r\n            continue;\r\n        }\r\n\r\n        const p0 = positions[indexA];\r\n        const p1 = positions[indexB];\r\n        const p2 = positions[indexC];\r\n\r\n        // stay defensive and don't check against undefined positions.\r\n        if (!p0 || !p1 || !p2) {\r\n            continue;\r\n        }\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n        const p0 = positions[index];\r\n        const p1 = positions[index + 1];\r\n        const p2 = positions[index + 2];\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\nSubMesh.prototype.projectToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    const material = this.getMaterial();\r\n    if (!material) {\r\n        return -1;\r\n    }\r\n    let step = 3;\r\n    let checkStopper = false;\r\n\r\n    switch (material.fillMode) {\r\n        case Constants.MATERIAL_PointListDrawMode:\r\n        case Constants.MATERIAL_LineLoopDrawMode:\r\n        case Constants.MATERIAL_LineStripDrawMode:\r\n        case Constants.MATERIAL_TriangleFanDrawMode:\r\n            return -1;\r\n        case Constants.MATERIAL_TriangleStripDrawMode:\r\n            step = 1;\r\n            checkStopper = true;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // LineMesh first as it's also a Mesh...\r\n    if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n        return -1;\r\n    } else {\r\n        // Check if mesh is unindexed\r\n        if (!indices.length && (this as any)._mesh._unIndexed) {\r\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\r\n        }\r\n\r\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\r\n    }\r\n};\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRControllerPointerSelection } from \"./WebXRControllerPointerSelection\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { IndicesArray, Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport { BoundingSphere } from \"../../Culling/boundingSphere\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing\";\r\n// side effects\r\nimport \"../../Meshes/subMesh.project\";\r\n\r\ntype ControllerData = {\r\n    xrController?: WebXRInputSource;\r\n    squeezeComponent?: WebXRControllerComponent;\r\n    selectionComponent?: WebXRControllerComponent;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onSqueezeButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n    meshUnderPointer: Nullable<AbstractMesh>;\r\n    nearInteractionTargetMesh: Nullable<AbstractMesh>;\r\n    pick: Nullable<PickingInfo>;\r\n    stalePick: Nullable<PickingInfo>;\r\n    id: number;\r\n    touchCollisionMesh: AbstractMesh;\r\n    touchCollisionMeshFunction: (isTouch: boolean) => void;\r\n    hydrateCollisionMeshFunction: (isHydration: boolean) => void;\r\n    currentAnimationState: ControllerOrbAnimationState;\r\n    grabRay: Ray;\r\n    nearInteraction: boolean;\r\n    hoverInteraction: boolean;\r\n    grabInteraction: boolean;\r\n    downTriggered: boolean;\r\n    // event support\r\n    eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n    pickedPointVisualCue: AbstractMesh;\r\n    _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>>;\r\n};\r\n\r\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\r\nenum ControllerOrbAnimationState {\r\n    /**\r\n     * Orb is invisible\r\n     */\r\n    DEHYDRATED,\r\n    /**\r\n     * Orb is visible and inside the hover range\r\n     */\r\n    HOVER,\r\n    /**\r\n     * Orb is visible and touching a near interaction target\r\n     */\r\n    TOUCH,\r\n}\r\n\r\n/**\r\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\r\n */\r\nexport enum WebXRNearControllerMode {\r\n    /**\r\n     * Motion controllers will not support near interaction\r\n     */\r\n    DISABLED = 0,\r\n    /**\r\n     * The interaction point for motion controllers will be inside of them\r\n     */\r\n    CENTERED_ON_CONTROLLER = 1,\r\n    /**\r\n     * The interaction point for motion controllers will be in front of the controller\r\n     */\r\n    CENTERED_IN_FRONT = 2,\r\n}\r\n\r\n/**\r\n * Options interface for the near interaction module\r\n */\r\nexport interface IWebXRNearInteractionOptions {\r\n    /**\r\n     * If provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * The xr input to use with this near interaction\r\n     */\r\n    xrInput: WebXRInput;\r\n    /**\r\n     * Enable near interaction on all controllers instead of switching between them\r\n     */\r\n    enableNearInteractionOnAllControllers?: boolean;\r\n    /**\r\n     * The preferred hand to give the near interaction to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n    /**\r\n     * Disable switching the near interaction from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * Far interaction feature to toggle when near interaction takes precedence\r\n     */\r\n    farInteractionFeature?: WebXRControllerPointerSelection;\r\n\r\n    /**\r\n     * Near interaction mode for motion controllers\r\n     */\r\n    nearInteractionControllerMode?: WebXRNearControllerMode;\r\n\r\n    /**\r\n     * Optional material for the motion controller orb, if enabled\r\n     */\r\n    motionControllerOrbMaterial?: Material;\r\n}\r\n\r\n/**\r\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\r\n */\r\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _tmpRay: Ray = new Ray(new Vector3(), new Vector3());\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        // get two new meshes\r\n        const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n        const selectionMesh = this._generateVisualCue();\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            meshUnderPointer: null,\r\n            nearInteractionTargetMesh: null,\r\n            pick: null,\r\n            stalePick: null,\r\n            touchCollisionMesh,\r\n            touchCollisionMeshFunction: touchCollisionMeshFunction,\r\n            hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\r\n            currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\r\n            grabRay: new Ray(new Vector3(), new Vector3()),\r\n            hoverInteraction: false,\r\n            nearInteraction: false,\r\n            grabInteraction: false,\r\n            downTriggered: false,\r\n            id: WebXRNearInteraction._IdCounter++,\r\n            pickedPointVisualCue: selectionMesh,\r\n        };\r\n\r\n        this._controllers[xrController.uniqueId]._worldScaleObserver =\r\n            this._controllers[xrController.uniqueId]._worldScaleObserver ||\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {\r\n                if (values.newScaleFactor !== values.previousScaleFactor) {\r\n                    this._controllers[xrController.uniqueId].touchCollisionMesh.dispose();\r\n                    this._controllers[xrController.uniqueId].pickedPointVisualCue.dispose();\r\n\r\n                    const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n                    this._controllers[xrController.uniqueId].touchCollisionMesh = touchCollisionMesh;\r\n                    this._controllers[xrController.uniqueId].touchCollisionMeshFunction = touchCollisionMeshFunction;\r\n                    this._controllers[xrController.uniqueId].hydrateCollisionMeshFunction = hydrateCollisionMeshFunction;\r\n                    this._controllers[xrController.uniqueId].pickedPointVisualCue = this._generateVisualCue();\r\n                }\r\n            });\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enableNearInteractionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enableNearInteractionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachNearInteractionMode(xrController);\r\n            case \"gaze\":\r\n                return null;\r\n            case \"screen\":\r\n                return null;\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: ControllerData;\r\n    } = {};\r\n    private _scene: Scene;\r\n\r\n    private _attachedController: string;\r\n\r\n    private _farInteractionFeature: Nullable<WebXRControllerPointerSelection> = null;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.NEAR_INTERACTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRNearInteractionOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n        if (this._options.nearInteractionControllerMode === undefined) {\r\n            this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\r\n        }\r\n\r\n        if (this._options.farInteractionFeature) {\r\n            this._farInteractionFeature = this._options.farInteractionFeature;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function sets webXRControllerPointerSelection feature that will be disabled when\r\n     * the hover range is reached for a mesh and will be reattached when not in hover range.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\r\n     */\r\n    public setFarInteractionFeature(farInteractionFeature: Nullable<WebXRControllerPointerSelection>) {\r\n        this._farInteractionFeature = farInteractionFeature;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction pick and hover\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearPickPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction grab\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearGrabPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for any near interaction\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearInteractionPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\r\n    }\r\n\r\n    private _controllerAvailablePredicate(mesh: AbstractMesh, controllerId: string): boolean {\r\n        let parent: TransformNode = mesh;\r\n\r\n        while (parent) {\r\n            if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\r\n                return false;\r\n            }\r\n            parent = parent.parent as TransformNode;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _handleTransitionAnimation(controllerData: ControllerData, newState: ControllerOrbAnimationState) {\r\n        if (\r\n            controllerData.currentAnimationState === newState ||\r\n            this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT ||\r\n            !!controllerData.xrController?.inputSource.hand\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\r\n        if (newState > controllerData.currentAnimationState) {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.DEHYDRATED: {\r\n                    controllerData.hydrateCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.touchCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.TOUCH) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.TOUCH: {\r\n                    controllerData.touchCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.hydrateCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.DEHYDRATED) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        controllerData.currentAnimationState = newState;\r\n    }\r\n\r\n    private readonly _hoverRadius = 0.1;\r\n    private readonly _pickRadius = 0.02;\r\n    private readonly _controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\r\n    private readonly _nearGrabLengthScale = 5;\r\n\r\n    private _processTouchPoint(id: string, position: Vector3, orientation: Quaternion) {\r\n        const controllerData = this._controllers[id];\r\n\r\n        // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\r\n        controllerData.grabRay.origin.copyFrom(position);\r\n        orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\r\n        controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\r\n\r\n        if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !controllerData.xrController?.inputSource.hand) {\r\n            // offset the touch point in the direction the transform is facing\r\n            controllerData.xrController!.getWorldPointerRayToRef(this._tmpRay);\r\n            controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\r\n        }\r\n\r\n        controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius * this._xrSessionManager.worldScalingFactor;\r\n        controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            const handData = controllerData.xrController?.inputSource.hand;\r\n            // If near interaction is not enabled/available for this controller, return early\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n            controllerData.hoverInteraction = false;\r\n            controllerData.nearInteraction = false;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                if (handData) {\r\n                    const xrIndexTip = handData.get(\"index-finger-tip\");\r\n                    if (xrIndexTip) {\r\n                        const indexTipPose = _xrFrame.getJointPose!(xrIndexTip, this._xrSessionManager.referenceSpace);\r\n                        if (indexTipPose && indexTipPose.transform) {\r\n                            const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\r\n                            TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\r\n                            TmpVectors.Quaternion[0].set(\r\n                                indexTipPose.transform.orientation.x,\r\n                                indexTipPose.transform.orientation.y,\r\n                                indexTipPose.transform.orientation.z * axisRHSMultiplier,\r\n                                indexTipPose.transform.orientation.w * axisRHSMultiplier\r\n                            );\r\n\r\n                            this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\r\n                        }\r\n                    }\r\n                } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\r\n                    let controllerPose = controllerData.xrController.pointer;\r\n                    if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\r\n                        controllerPose = controllerData.xrController.grip;\r\n                    }\r\n\r\n                    this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion!);\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const accuratePickInfo = (originalScenePick: Nullable<PickingInfo>, utilityScenePick: Nullable<PickingInfo>): Nullable<PickingInfo> => {\r\n                let pick = null;\r\n                if (!utilityScenePick || !utilityScenePick.hit) {\r\n                    // No hit in utility scene\r\n                    pick = originalScenePick;\r\n                } else if (!originalScenePick || !originalScenePick.hit) {\r\n                    // No hit in original scene\r\n                    pick = utilityScenePick;\r\n                } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                    // Hit is closer in utility scene\r\n                    pick = utilityScenePick;\r\n                } else {\r\n                    // Hit is closer in original scene\r\n                    pick = originalScenePick;\r\n                }\r\n                return pick;\r\n            };\r\n            const populateNearInteractionInfo = (nearInteractionInfo: Nullable<PickingInfo>): PickingInfo => {\r\n                let result = new PickingInfo();\r\n\r\n                let nearInteractionAtOrigin = false;\r\n                const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\r\n                if (nearInteractionInfo?.pickedPoint) {\r\n                    nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\r\n                }\r\n                if (nearInteraction && !nearInteractionAtOrigin) {\r\n                    result = nearInteractionInfo!;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\r\n            // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\r\n            // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\r\n            if (!controllerData.grabInteraction) {\r\n                let pick = null;\r\n\r\n                // near interaction hover\r\n                let utilitySceneHoverPick = null;\r\n                if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                    utilitySceneHoverPick = this._pickWithSphere(\r\n                        controllerData,\r\n                        this._hoverRadius * this._xrSessionManager.worldScalingFactor,\r\n                        this._utilityLayerScene,\r\n                        (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh)\r\n                    );\r\n                }\r\n                const originalSceneHoverPick = this._pickWithSphere(\r\n                    controllerData,\r\n                    this._hoverRadius * this._xrSessionManager.worldScalingFactor,\r\n                    this._scene,\r\n                    (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh)\r\n                );\r\n\r\n                const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\r\n                if (hoverPickInfo && hoverPickInfo.hit) {\r\n                    pick = populateNearInteractionInfo(hoverPickInfo);\r\n                    if (pick.hit) {\r\n                        controllerData.hoverInteraction = true;\r\n                    }\r\n                }\r\n\r\n                // near interaction pick\r\n                if (controllerData.hoverInteraction) {\r\n                    let utilitySceneNearPick = null;\r\n                    const radius = (handData ? this._pickRadius : this._controllerPickRadius) * this._xrSessionManager.worldScalingFactor;\r\n                    if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                        utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    }\r\n                    const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\r\n                    const nearPick = populateNearInteractionInfo(pickInfo);\r\n                    if (nearPick.hit) {\r\n                        // Near pick takes precedence over hover interaction\r\n                        pick = nearPick;\r\n                        controllerData.nearInteraction = true;\r\n                    }\r\n                }\r\n\r\n                controllerData.stalePick = controllerData.pick;\r\n                controllerData.pick = pick;\r\n\r\n                // Update mesh under pointer\r\n                if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\r\n                    controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\r\n                    controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\r\n                    }\r\n                } else {\r\n                    controllerData.meshUnderPointer = null;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update the interaction animation. Only updates if the visible touch mesh is active\r\n            let state = ControllerOrbAnimationState.DEHYDRATED;\r\n            if (controllerData.grabInteraction || controllerData.nearInteraction) {\r\n                state = ControllerOrbAnimationState.TOUCH;\r\n            } else if (controllerData.hoverInteraction) {\r\n                state = ControllerOrbAnimationState.HOVER;\r\n            }\r\n            this._handleTransitionAnimation(controllerData, state);\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _generateVisualCue() {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const selectionMesh = CreateSphere(\r\n            \"nearInteraction\",\r\n            {\r\n                diameter: 0.0035 * 3 * this._xrSessionManager.worldScalingFactor,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        selectionMesh.rotationQuaternion = Quaternion.Identity();\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        return selectionMesh;\r\n    }\r\n\r\n    private _isControllerReadyForNearInteraction(id: number) {\r\n        if (this._farInteractionFeature) {\r\n            return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _attachNearInteractionMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr-near\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                return;\r\n            }\r\n            if (controllerData.pick) {\r\n                controllerData.pick.ray = controllerData.grabRay;\r\n            }\r\n\r\n            if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n\r\n            // Near pick pointer event\r\n            if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\r\n                if (!controllerData.nearInteractionTargetMesh) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\r\n                    controllerData.downTriggered = true;\r\n                }\r\n            } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\r\n                this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\r\n                controllerData.downTriggered = false;\r\n                controllerData.nearInteractionTargetMesh = null;\r\n            }\r\n        });\r\n\r\n        const grabCheck = (pressed: boolean) => {\r\n            if (\r\n                this._options.enableNearInteractionOnAllControllers ||\r\n                (xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id))\r\n            ) {\r\n                if (controllerData.pick) {\r\n                    controllerData.pick.ray = controllerData.grabRay;\r\n                }\r\n                if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = true;\r\n                } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = false;\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                }\r\n            } else {\r\n                if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                    this._attachedController = xrController.uniqueId;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\r\n                if (controllerData.squeezeComponent) {\r\n                    controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                } else {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                    controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id) &&\r\n                    controllerData.meshUnderPointer &&\r\n                    this._nearGrabPredicate(controllerData.meshUnderPointer)\r\n                ) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = true;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id)\r\n                ) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                    controllerData.downTriggered = false;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.squeezeComponent) {\r\n            if (controllerData.onSqueezeButtonChangedObserver) {\r\n                controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n        controllerData.touchCollisionMesh.dispose();\r\n        controllerData.pickedPointVisualCue.dispose();\r\n\r\n        this._xrSessionManager.runInXRFrame(() => {\r\n            if (!controllerData.downTriggered) {\r\n                return;\r\n            }\r\n            // Fire a pointerup in case controller was detached before a pointerup event was fired\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr-near\",\r\n            };\r\n            this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\r\n        });\r\n\r\n        // remove world scale observer\r\n        if (controllerData._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(controllerData._worldScaleObserver);\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n        if (this._attachedController === xrControllerUniqueId) {\r\n            // check for other controllers\r\n            const keys = Object.keys(this._controllers);\r\n            if (keys.length) {\r\n                this._attachedController = keys[0];\r\n            } else {\r\n                this._attachedController = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateNewTouchPointMesh() {\r\n        const worldScale = this._xrSessionManager.worldScalingFactor;\r\n        // populate information for near hover, pick and pinch\r\n        const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n\r\n        const touchCollisionMesh = CreateSphere(\"PickSphere\", { diameter: 1 * worldScale }, meshCreationScene);\r\n        touchCollisionMesh.isVisible = false;\r\n\r\n        // Generate the material for the touch mesh visuals\r\n        if (this._options.motionControllerOrbMaterial) {\r\n            touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\r\n        } else {\r\n            NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then((nodeMaterial) => {\r\n                touchCollisionMesh.material = nodeMaterial;\r\n            });\r\n        }\r\n\r\n        const easingFunction = new QuadraticEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n\r\n        // Adjust the visual size based off of the size of the touch collision orb.\r\n        // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\r\n        // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\r\n        const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius).scaleInPlace(worldScale);\r\n        const touchSize = this._controllerPickRadius * (4 / 3);\r\n        const touchSizeVec = new Vector3(touchSize, touchSize, touchSize).scaleInPlace(worldScale);\r\n        const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\r\n        const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize).scaleInPlace(worldScale);\r\n        const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\r\n        const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize).scaleInPlace(worldScale);\r\n        const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\r\n        const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize).scaleInPlace(worldScale);\r\n\r\n        const touchKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: hoverTouchTransitionSizeVec },\r\n            { frame: 18, value: touchSizeVec },\r\n        ];\r\n        const releaseKeys = [\r\n            { frame: 0, value: touchSizeVec },\r\n            { frame: 10, value: touchHoverTransitionSizeVec },\r\n            { frame: 18, value: hoverSizeVec },\r\n        ];\r\n        const hydrateKeys = [\r\n            { frame: 0, value: Vector3.ZeroReadOnly },\r\n            { frame: 12, value: hydrateTransitionSizeVec },\r\n            { frame: 15, value: hoverSizeVec },\r\n        ];\r\n        const dehydrateKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: Vector3.ZeroReadOnly },\r\n            { frame: 15, value: Vector3.ZeroReadOnly },\r\n        ];\r\n\r\n        const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        touchAction.setEasingFunction(easingFunction);\r\n        releaseAction.setEasingFunction(easingFunction);\r\n        hydrateAction.setEasingFunction(easingFunction);\r\n        dehydrateAction.setEasingFunction(easingFunction);\r\n\r\n        touchAction.setKeys(touchKeys);\r\n        releaseAction.setKeys(releaseKeys);\r\n        hydrateAction.setKeys(hydrateKeys);\r\n        dehydrateAction.setKeys(dehydrateKeys);\r\n\r\n        const touchCollisionMeshFunction = (isTouch: boolean) => {\r\n            const action = isTouch ? touchAction : releaseAction;\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\r\n        };\r\n\r\n        const hydrateCollisionMeshFunction = (isHydration: boolean) => {\r\n            const action = isHydration ? hydrateAction : dehydrateAction;\r\n            if (isHydration) {\r\n                touchCollisionMesh.isVisible = true;\r\n            }\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\r\n                if (!isHydration) {\r\n                    touchCollisionMesh.isVisible = false;\r\n                }\r\n            });\r\n        };\r\n\r\n        return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };\r\n    }\r\n\r\n    private _pickWithSphere(controllerData: ControllerData, radius: number, sceneToUse: Scene, predicate: (mesh: AbstractMesh) => boolean): Nullable<PickingInfo> {\r\n        const pickingInfo = new PickingInfo();\r\n        pickingInfo.distance = +Infinity;\r\n\r\n        if (controllerData.touchCollisionMesh && controllerData.xrController) {\r\n            const position = controllerData.touchCollisionMesh.position;\r\n            const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\r\n\r\n            for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\r\n                const mesh = sceneToUse.meshes[meshIndex];\r\n                if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\r\n                    continue;\r\n                }\r\n                const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\r\n\r\n                if (result && result.hit && result.distance < pickingInfo.distance) {\r\n                    pickingInfo.hit = result.hit;\r\n                    pickingInfo.pickedMesh = mesh;\r\n                    pickingInfo.pickedPoint = result.pickedPoint;\r\n                    pickingInfo.aimTransform = controllerData.xrController.pointer;\r\n                    pickingInfo.gripTransform = controllerData.xrController.grip || null;\r\n                    pickingInfo.originMesh = controllerData.touchCollisionMesh;\r\n                    pickingInfo.distance = result.distance;\r\n                    pickingInfo.bu = result.bu;\r\n                    pickingInfo.bv = result.bv;\r\n                    pickingInfo.faceId = result.faceId;\r\n                    pickingInfo.subMeshId = result.subMeshId;\r\n                }\r\n            }\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Picks a mesh with a sphere\r\n     * @param mesh the mesh to pick\r\n     * @param sphere picking sphere in world coordinates\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public static PickMeshWithSphere(mesh: AbstractMesh, sphere: BoundingSphere, skipBoundingInfo = false): PickingInfo {\r\n        const subMeshes = mesh.subMeshes;\r\n        const pi = new PickingInfo();\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (!mesh._generatePointsArray()) {\r\n            return pi;\r\n        }\r\n\r\n        if (!mesh.subMeshes || !boundingInfo) {\r\n            return pi;\r\n        }\r\n\r\n        if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\r\n            return pi;\r\n        }\r\n\r\n        const result = TmpVectors.Vector3[0];\r\n        const tmpVec = TmpVectors.Vector3[1];\r\n        const tmpRay = new Ray(Vector3.Zero(), Vector3.Zero(), 1);\r\n\r\n        let distance = +Infinity;\r\n        let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter, intersectionInfo;\r\n        const center = TmpVectors.Vector3[2];\r\n        const worldToMesh = TmpVectors.Matrix[0];\r\n        worldToMesh.copyFrom(mesh.getWorldMatrix());\r\n        worldToMesh.invert();\r\n        Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\r\n\r\n        for (let index = 0; index < subMeshes.length; index++) {\r\n            const subMesh = subMeshes[index];\r\n\r\n            subMesh.projectToRef(center, <Vector3[]>mesh._positions, <IndicesArray>mesh.getIndices(), tmpVec);\r\n\r\n            Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\r\n            tmp = Vector3.Distance(tmpVec, sphere.center);\r\n\r\n            // Check for finger inside of mesh\r\n            tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\r\n            tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\r\n            if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\r\n                tmp = 0;\r\n                tmpVec.copyFrom(sphere.center);\r\n            }\r\n\r\n            if (tmp !== -1 && tmp < distance) {\r\n                distance = tmp;\r\n\r\n                // ray between the sphere center and the point on the mesh\r\n                Ray.CreateFromToToRef(sphere.center, tmpVec, tmpRay);\r\n                tmpRay.length = distance * 2;\r\n                intersectionInfo = tmpRay.intersectsMesh(mesh);\r\n\r\n                result.copyFrom(tmpVec);\r\n            }\r\n        }\r\n\r\n        if (distance < sphere.radius) {\r\n            pi.hit = true;\r\n            pi.distance = distance;\r\n            pi.pickedMesh = mesh;\r\n            pi.pickedPoint = result.clone();\r\n            if (intersectionInfo && intersectionInfo.bu !== null && intersectionInfo.bv !== null) {\r\n                pi.faceId = intersectionInfo.faceId;\r\n                pi.subMeshId = intersectionInfo.subMeshId;\r\n                pi.bu = intersectionInfo.bu;\r\n                pi.bv = intersectionInfo.bv;\r\n            }\r\n        }\r\n\r\n        return pi;\r\n    }\r\n}\r\n\r\n//Register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRNearInteraction.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRNearInteraction(xrSessionManager, options);\r\n    },\r\n    WebXRNearInteraction.Version,\r\n    true\r\n);\r\n", "import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Button which can be used to enter a different mode of XR\r\n */\r\nexport class WebXREnterExitUIButton {\r\n    /**\r\n     * Creates a WebXREnterExitUIButton\r\n     * @param element button element\r\n     * @param sessionMode XR initialization session mode\r\n     * @param referenceSpaceType the type of reference space to be used\r\n     */\r\n    constructor(\r\n        /** button element */\r\n        public element: HTMLElement,\r\n        /** XR initialization options for the button */\r\n        public sessionMode: XRSessionMode,\r\n        /** Reference space type */\r\n        public referenceSpaceType: XRReferenceSpaceType\r\n    ) {}\r\n\r\n    /**\r\n     * Extendable function which can be used to update the button's visuals when the state changes\r\n     * @param activeButton the current active button in the UI\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public update(activeButton: Nullable<WebXREnterExitUIButton>) {}\r\n}\r\n\r\n/**\r\n * Options to create the webXR UI\r\n */\r\nexport class WebXREnterExitUIOptions {\r\n    /**\r\n     * User provided buttons to enable/disable WebXR. The system will provide default if not set\r\n     */\r\n    customButtons?: Array<WebXREnterExitUIButton>;\r\n    /**\r\n     * A reference space type to use when creating the default button.\r\n     * Default is local-floor\r\n     */\r\n    referenceSpaceType?: XRReferenceSpaceType;\r\n    /**\r\n     * Context to enter xr with\r\n     */\r\n    renderTarget?: Nullable<WebXRRenderTarget>;\r\n    /**\r\n     * A session mode to use when creating the default button.\r\n     * Default is immersive-vr\r\n     */\r\n    sessionMode?: XRSessionMode;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     */\r\n    optionalFeatures?: string[];\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     */\r\n    requiredFeatures?: string[];\r\n\r\n    /**\r\n     * If set, the `sessiongranted` event will not be registered. `sessiongranted` is used to move seamlessly between WebXR experiences.\r\n     * If set to true the user will be forced to press the \"enter XR\" button even if sessiongranted event was triggered.\r\n     * If not set and a sessiongranted event was triggered, the XR session will start automatically.\r\n     */\r\n    ignoreSessionGrantedEvent?: boolean;\r\n\r\n    /**\r\n     * If defined, this function will be executed if the UI encounters an error when entering XR\r\n     */\r\n    onError?: (error: any) => void;\r\n}\r\n/**\r\n * UI to allow the user to enter/exit XR mode\r\n */\r\nexport class WebXREnterExitUI implements IDisposable {\r\n    private _activeButton: Nullable<WebXREnterExitUIButton> = null;\r\n    private _buttons: Array<WebXREnterExitUIButton> = [];\r\n    private _helper: WebXRExperienceHelper;\r\n    private _renderTarget?: WebXRRenderTarget;\r\n    /**\r\n     * The HTML Div Element to which buttons are added.\r\n     */\r\n    public readonly overlay: HTMLDivElement;\r\n\r\n    /**\r\n     * Fired every time the active button is changed.\r\n     *\r\n     * When xr is entered via a button that launches xr that button will be the callback parameter\r\n     *\r\n     * When exiting xr the callback parameter will be null)\r\n     */\r\n    public activeButtonChangedObservable = new Observable<Nullable<WebXREnterExitUIButton>>();\r\n\r\n    /**\r\n     * Construct a new EnterExit UI class\r\n     *\r\n     * @param _scene babylon scene object to use\r\n     * @param options (read-only) version of the options passed to this UI\r\n     */\r\n    public constructor(\r\n        private _scene: Scene,\r\n        /** version of the options passed to this UI */\r\n        public options: WebXREnterExitUIOptions\r\n    ) {\r\n        this.overlay = document.createElement(\"div\");\r\n        this.overlay.classList.add(\"xr-button-overlay\");\r\n\r\n        // prepare for session granted event\r\n        if (!options.ignoreSessionGrantedEvent && (navigator as any).xr) {\r\n            (navigator as any).xr.addEventListener(\"sessiongranted\", this._onSessionGranted);\r\n        }\r\n\r\n        // if served over HTTP, warn people.\r\n        // Hopefully the browsers will catch up\r\n        if (typeof window !== \"undefined\") {\r\n            if (window.location && window.location.protocol === \"http:\" && window.location.hostname !== \"localhost\") {\r\n                Tools.Warn(\"WebXR can only be served over HTTPS\");\r\n                throw new Error(\"WebXR can only be served over HTTPS\");\r\n            }\r\n        }\r\n\r\n        if (options.customButtons) {\r\n            this._buttons = options.customButtons;\r\n        } else {\r\n            this.overlay.style.cssText = \"z-index:11;position: absolute; right: 20px;bottom: 50px;\";\r\n            const sessionMode = options.sessionMode || \"immersive-vr\";\r\n            const referenceSpaceType = options.referenceSpaceType || \"local-floor\";\r\n            const url =\r\n                typeof SVGSVGElement === \"undefined\"\r\n                    ? \"https://cdn.babylonjs.com/Assets/vrButton.png\"\r\n                    : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\r\n            let css =\r\n                \".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n                url +\r\n                \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\r\n            css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: \"EXIT\"} .xr-error::after { content: \"ERROR\"}';\r\n\r\n            const style = document.createElement(\"style\");\r\n            style.appendChild(document.createTextNode(css));\r\n            document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n            const hmdBtn = document.createElement(\"button\");\r\n            hmdBtn.className = \"babylonVRicon\";\r\n            hmdBtn.title = `${sessionMode} - ${referenceSpaceType}`;\r\n            this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));\r\n            this._buttons[this._buttons.length - 1].update = function (activeButton: WebXREnterExitUIButton) {\r\n                this.element.style.display = activeButton === null || activeButton === this ? \"\" : \"none\";\r\n                hmdBtn.className = \"babylonVRicon\" + (activeButton === this ? \" vrdisplaypresenting\" : \"\");\r\n            };\r\n            this._updateButtons(null);\r\n        }\r\n\r\n        const renderCanvas = _scene.getEngine().getInputElement();\r\n        if (renderCanvas && renderCanvas.parentNode) {\r\n            renderCanvas.parentNode.appendChild(this.overlay);\r\n            _scene.onDisposeObservable.addOnce(() => {\r\n                this.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the helper to be used with this UI component.\r\n     * The UI is bound to an experience helper. If not provided the UI can still be used but the events should be registered by the developer.\r\n     *\r\n     * @param helper the experience helper to attach\r\n     * @param renderTarget an optional render target (in case it is created outside of the helper scope)\r\n     * @returns a promise that resolves when the ui is ready\r\n     */\r\n    public async setHelperAsync(helper: WebXRExperienceHelper, renderTarget?: WebXRRenderTarget): Promise<void> {\r\n        this._helper = helper;\r\n        this._renderTarget = renderTarget;\r\n        const supportedPromises = this._buttons.map((btn) => {\r\n            return helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);\r\n        });\r\n        helper.onStateChangedObservable.add((state) => {\r\n            if (state == WebXRState.NOT_IN_XR) {\r\n                this._updateButtons(null);\r\n            }\r\n        });\r\n        const results = await Promise.all(supportedPromises);\r\n        results.forEach((supported, i) => {\r\n            if (supported) {\r\n                this.overlay.appendChild(this._buttons[i].element);\r\n                this._buttons[i].element.onclick = this._enterXRWithButtonIndex.bind(this, i);\r\n            } else {\r\n                Tools.Warn(`Session mode \"${this._buttons[i].sessionMode}\" not supported in browser`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates UI to allow the user to enter/exit XR mode\r\n     * @param scene the scene to add the ui to\r\n     * @param helper the xr experience helper to enter/exit xr with\r\n     * @param options options to configure the UI\r\n     * @returns the created ui\r\n     */\r\n    public static async CreateAsync(scene: Scene, helper: WebXRExperienceHelper, options: WebXREnterExitUIOptions): Promise<WebXREnterExitUI> {\r\n        const ui = new WebXREnterExitUI(scene, options);\r\n        await ui.setHelperAsync(helper, options.renderTarget || undefined);\r\n        return ui;\r\n    }\r\n\r\n    private async _enterXRWithButtonIndex(idx: number = 0) {\r\n        if (this._helper.state == WebXRState.IN_XR) {\r\n            await this._helper.exitXRAsync();\r\n            this._updateButtons(null);\r\n        } else if (this._helper.state == WebXRState.NOT_IN_XR) {\r\n            try {\r\n                await this._helper.enterXRAsync(this._buttons[idx].sessionMode, this._buttons[idx].referenceSpaceType, this._renderTarget, {\r\n                    optionalFeatures: this.options.optionalFeatures,\r\n                    requiredFeatures: this.options.requiredFeatures,\r\n                });\r\n                this._updateButtons(this._buttons[idx]);\r\n            } catch (e) {\r\n                // make sure button is visible\r\n                this._updateButtons(null);\r\n                const element = this._buttons[idx].element;\r\n                const prevTitle = element.title;\r\n                element.title = \"Error entering XR session : \" + prevTitle;\r\n                element.classList.add(\"xr-error\");\r\n                if (this.options.onError) {\r\n                    this.options.onError(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the XR UI component\r\n     */\r\n    public dispose() {\r\n        const renderCanvas = this._scene.getEngine().getInputElement();\r\n        if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {\r\n            renderCanvas.parentNode.removeChild(this.overlay);\r\n        }\r\n        this.activeButtonChangedObservable.clear();\r\n        (navigator as any).xr.removeEventListener(\"sessiongranted\", this._onSessionGranted);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _onSessionGranted = (evt: { session: XRSession }) => {\r\n        // This section is for future reference.\r\n        // As per specs, evt.session.mode should have the supported session mode, but no browser supports it for now.\r\n\r\n        // // check if the session granted is the same as the one requested\r\n        // const grantedMode = (evt.session as any).mode;\r\n        // if (grantedMode) {\r\n        //     this._buttons.some((btn, idx) => {\r\n        //         if (btn.sessionMode === grantedMode) {\r\n        //             this._enterXRWithButtonIndex(idx);\r\n        //             return true;\r\n        //         }\r\n        //         return false;\r\n        //     });\r\n        // } else\r\n\r\n        if (this._helper) {\r\n            this._enterXRWithButtonIndex(0);\r\n        }\r\n    };\r\n\r\n    private _updateButtons(activeButton: Nullable<WebXREnterExitUIButton>) {\r\n        this._activeButton = activeButton;\r\n        this._buttons.forEach((b) => {\r\n            b.update(this._activeButton);\r\n        });\r\n        this.activeButtonChangedObservable.notifyObservers(this._activeButton);\r\n    }\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ImageSource, Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageSource | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageSource,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    if (format) {\r\n        texture.format = format;\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _ownCanvas: boolean;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._ownCanvas = false;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n            this._ownCanvas = true;\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     * @param clearColor Defines the clear color to use\r\n     */\r\n    public clear(clearColor?: string): void {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n        }\r\n        this._context.clearRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        fillColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (fillColor) {\r\n            this._context.fillStyle = fillColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the dynamic texture.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._ownCanvas) {\r\n            this._canvas?.remove?.();\r\n        }\r\n        (this._canvas as any) = null;\r\n        (this._context as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "import type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the ground\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @internal */\r\n    public _subdivisionsX: number;\r\n    /** @internal */\r\n    public _subdivisionsY: number;\r\n    /** @internal */\r\n    public _width: number;\r\n    /** @internal */\r\n    public _height: number;\r\n    /** @internal */\r\n    public _minX: number;\r\n    /** @internal */\r\n    public _maxX: number;\r\n    /** @internal */\r\n    public _minZ: number;\r\n    /** @internal */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\r\n     * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\r\n     * to get performance improvements when using an octree.\r\n     * @param chunksCount the number of submeshes the mesh will be divided into\r\n     * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the World system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        const normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        const world = this.getWorldMatrix();\r\n        const tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n     * if the ground has been updated.\r\n     * This can be used in the render loop.\r\n     * @returns the GroundMesh.\r\n     */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        const col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\r\n        const row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\r\n        const quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        let facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                const quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        const v1 = TmpVectors.Vector3[3];\r\n        const v2 = TmpVectors.Vector3[2];\r\n        const v3 = TmpVectors.Vector3[1];\r\n        const v4 = TmpVectors.Vector3[0];\r\n        const v1v2 = TmpVectors.Vector3[4];\r\n        const v1v3 = TmpVectors.Vector3[5];\r\n        const v1v4 = TmpVectors.Vector3[6];\r\n        const norm1 = TmpVectors.Vector3[7];\r\n        const norm2 = TmpVectors.Vector3[8];\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        let cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        let h = 0;\r\n        let d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        let d2 = 0;\r\n\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                const quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        const result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ground\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n * @param options.width the width (x direction) of the ground, optional, default 1\r\n * @param options.height the height (z direction) of the ground, optional, default 1\r\n * @param options.subdivisions the number of subdivisions per side, optional, default 1\r\n * @param options.subdivisionsX the number of subdivisions in the x direction, overrides options.subdivisions, optional, default undefined\r\n * @param options.subdivisionsY the number of subdivisions in the y direction, overrides options.subdivisions, optional, default undefined\r\n * @returns the VertexData of the Ground\r\n */\r\nexport function CreateGroundVertexData(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row: number, col: number;\r\n\r\n    const width: number = options.width || 1;\r\n    const height: number = options.height || 1;\r\n    const subdivisionsX: number = (options.subdivisionsX || options.subdivisions || 1) | 0;\r\n    const subdivisionsY: number = (options.subdivisionsY || options.subdivisions || 1) | 0;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\r\n            const normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n * @param options an object used to set the following optional parameters for the Ground\r\n * @param options.xmin ground minimum X coordinate, default -1\r\n * @param options.zmin ground minimum Z coordinate, default -1\r\n * @param options.xmax ground maximum X coordinate, default 1\r\n * @param options.zmax ground maximum Z coordinate, default 1\r\n * @param options.subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n * @param options.subdivisions.w positive integer, default 6\r\n * @param options.subdivisions.h positive integer, default 6\r\n * @param options.precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n * @param options.precision.w positive integer, default 2\r\n * @param options.precision.h positive integer, default 2\r\n * @returns the VertexData of the TiledGround\r\n */\r\nexport function CreateTiledGroundVertexData(options: {\r\n    xmin: number;\r\n    zmin: number;\r\n    xmax: number;\r\n    zmax: number;\r\n    subdivisions?: { w: number; h: number };\r\n    precision?: { w: number; h: number };\r\n}): VertexData {\r\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\r\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\r\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\r\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\r\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    const precision = options.precision || { w: 1, h: 1 };\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    let row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\r\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\r\n    precision.w = precision.w < 1 ? 1 : precision.w;\r\n    precision.h = precision.h < 1 ? 1 : precision.h;\r\n\r\n    const tileSize = {\r\n        w: (xmax - xmin) / subdivisions.w,\r\n        h: (zmax - zmin) / subdivisions.h,\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        const base = positions.length / 3;\r\n        const rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        const position = Vector3.Zero();\r\n        const normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData of the Ground designed from a heightmap\r\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n * @param options.width the width (x direction) of the ground\r\n * @param options.height the height (z direction) of the ground\r\n * @param options.subdivisions the number of subdivisions per side\r\n * @param options.minHeight the minimum altitude on the ground, optional, default 0\r\n * @param options.maxHeight the maximum altitude on the ground, optional default 1\r\n * @param options.colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n * @param options.buffer the array holding the image color data\r\n * @param options.bufferWidth the width of image\r\n * @param options.bufferHeight the height of image\r\n * @param options.alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.heightBuffer a array of floats where the height data can be saved, if its length is greater than zero.\r\n * @returns the VertexData of the Ground designed from a heightmap\r\n */\r\nexport function CreateGroundFromHeightMapVertexData(options: {\r\n    width: number;\r\n    height: number;\r\n    subdivisions: number;\r\n    minHeight: number;\r\n    maxHeight: number;\r\n    colorFilter: Color3;\r\n    buffer: Uint8Array;\r\n    bufferWidth: number;\r\n    bufferHeight: number;\r\n    alphaFilter: number;\r\n    heightBuffer?: Float32Array;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row, col;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    let invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        const temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            const position = new Vector3(\r\n                (col * options.width) / options.subdivisions - options.width / 2.0,\r\n                0,\r\n                ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0\r\n            );\r\n\r\n            // Compute height\r\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            let r = options.buffer[pos] / 255.0;\r\n            let g = options.buffer[pos + 1] / 255.0;\r\n            let b = options.buffer[pos + 2] / 255.0;\r\n            const a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            } else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n            if (options.heightBuffer) {\r\n                // set the height buffer information in row major order.\r\n                options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\r\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\r\n            const idx3 = col + row * (options.subdivisions + 1);\r\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.width set the width size (float, default 1)\r\n * @param options.height set the height size (float, default 1)\r\n * @param options.subdivisions sets the number of subdivision per side (default 1)\r\n * @param options.subdivisionsX sets the number of subdivision on the X axis (overrides subdivisions)\r\n * @param options.subdivisionsY sets the number of subdivision on the Y axis (overrides subdivisions)\r\n * @param options.updatable defines if the mesh must be flagged as updatable (default false)\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\r\n */\r\nexport function CreateGround(\r\n    name: string,\r\n    options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number; updatable?: boolean } = {},\r\n    scene?: Scene\r\n): GroundMesh {\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._setReady(false);\r\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    ground._width = options.width || 1;\r\n    ground._height = options.height || 1;\r\n    ground._maxX = ground._width / 2;\r\n    ground._maxZ = ground._height / 2;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    const vertexData = CreateGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(ground, options.updatable);\r\n\r\n    ground._setReady(true);\r\n\r\n    return ground;\r\n}\r\n\r\n/**\r\n * Creates a tiled ground mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.xmin ground minimum X coordinate (float, default -1)\r\n * @param options.zmin ground minimum Z coordinate (float, default -1)\r\n * @param options.xmax ground maximum X coordinate (float, default 1)\r\n * @param options.zmax ground maximum Z coordinate (float, default 1)\r\n * @param options.subdivisions a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n * @param options.subdivisions.w positive integer, default 6\r\n * @param options.subdivisions.h positive integer, default 6\r\n * @param options.precision a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n * @param options.precision.w positive integer, default 2\r\n * @param options.precision.h positive integer, default 2\r\n * @param options.updatable boolean, default false, true if the mesh must be flagged as updatable\r\n * @param scene defines the hosting scene\r\n * @returns the tiled ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\r\n */\r\nexport function CreateTiledGround(\r\n    name: string,\r\n    options: { xmin: number; zmin: number; xmax: number; zmax: number; subdivisions?: { w: number; h: number }; precision?: { w: number; h: number }; updatable?: boolean },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const tiledGround = new Mesh(name, scene);\r\n\r\n    const vertexData = CreateTiledGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n    return tiledGround;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh from a height map. The height map download can take some frames,\r\n * so the mesh is not immediately ready. To wait for the mesh to be completely built,\r\n * you should use the `onReady` callback option.\r\n * @param name defines the name of the mesh\r\n * @param url sets the URL of the height map image resource.\r\n * @param options defines the options used to create the mesh\r\n * @param options.width sets the ground width size (positive float, default 10)\r\n * @param options.height sets the ground height size (positive float, default 10)\r\n * @param options.subdivisions sets the number of subdivision per side (positive integer, default 1)\r\n * @param options.minHeight is the minimum altitude on the ground (float, default 0)\r\n * @param options.maxHeight is the maximum altitude on the ground (float, default 1)\r\n * @param options.colorFilter is the filter to apply to the image pixel colors to compute the height (optional Color3, default (0.3, 0.59, 0.11) )\r\n * @param options.alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.updatable defines if the mesh must be flagged as updatable\r\n * @param options.onReady is a javascript callback function that will be called once the mesh is just built (the height map download can last some time)\r\n * @param options.onError is a javascript callback function that will be called if there is an error\r\n * @param options.passHeightBufferInCallback a boolean that indicates if the calculated height data will be passed in the onReady callback. Useful if you need the height data for physics, for example.\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\r\n */\r\nexport function CreateGroundFromHeightMap(\r\n    name: string,\r\n    url: string | { data: Uint8Array; width: number; height: number },\r\n    options: {\r\n        width?: number;\r\n        height?: number;\r\n        subdivisions?: number;\r\n        minHeight?: number;\r\n        maxHeight?: number;\r\n        colorFilter?: Color3;\r\n        alphaFilter?: number;\r\n        updatable?: boolean;\r\n        onReady?: (mesh: GroundMesh, heightBuffer?: Float32Array) => void;\r\n        onError?: (message?: string, exception?: any) => void;\r\n        passHeightBufferInCallback?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): GroundMesh {\r\n    const width = options.width || 10.0;\r\n    const height = options.height || 10.0;\r\n    const subdivisions = options.subdivisions || 1 | 0;\r\n    const minHeight = options.minHeight || 0.0;\r\n    const maxHeight = options.maxHeight || 1.0;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    const updatable = options.updatable;\r\n    const onReady = options.onReady;\r\n\r\n    scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._subdivisionsX = subdivisions;\r\n    ground._subdivisionsY = subdivisions;\r\n    ground._width = width;\r\n    ground._height = height;\r\n    ground._maxX = ground._width / 2.0;\r\n    ground._maxZ = ground._height / 2.0;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    ground._setReady(false);\r\n\r\n    let heightBuffer: Float32Array;\r\n    if (options.passHeightBufferInCallback) {\r\n        heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));\r\n    }\r\n\r\n    const onBufferLoaded = (buffer: Uint8Array, bufferWidth: number, bufferHeight: number) => {\r\n        const vertexData = CreateGroundFromHeightMapVertexData({\r\n            width: width,\r\n            height: height,\r\n            subdivisions: subdivisions,\r\n            minHeight: minHeight,\r\n            maxHeight: maxHeight,\r\n            colorFilter: filter,\r\n            buffer: buffer,\r\n            bufferWidth: bufferWidth,\r\n            bufferHeight: bufferHeight,\r\n            alphaFilter: alphaFilter,\r\n            heightBuffer,\r\n        });\r\n\r\n        vertexData.applyToMesh(ground, updatable);\r\n\r\n        //execute ready callback, if set\r\n        if (onReady) {\r\n            onReady(ground, heightBuffer);\r\n        }\r\n\r\n        ground._setReady(true);\r\n    };\r\n\r\n    if (typeof url === \"string\") {\r\n        const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            const bufferWidth = img.width;\r\n            const bufferHeight = img.height;\r\n\r\n            if (scene!.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            const buffer = <Uint8Array>scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\r\n\r\n            onBufferLoaded(buffer, bufferWidth, bufferHeight);\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, options.onError ? options.onError : () => {}, scene.offlineProvider);\r\n    } else {\r\n        onBufferLoaded(url.data, url.width, url.height);\r\n    }\r\n\r\n    return ground;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const GroundBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGround,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGroundFromHeightMap,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledGround,\r\n};\r\n\r\nVertexData.CreateGround = CreateGroundVertexData;\r\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\r\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\r\n\r\nMesh.CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        updatable,\r\n    };\r\n\r\n    return CreateGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateTiledGround = (\r\n    name: string,\r\n    xmin: number,\r\n    zmin: number,\r\n    xmax: number,\r\n    zmax: number,\r\n    subdivisions: { w: number; h: number },\r\n    precision: { w: number; h: number },\r\n    scene: Scene,\r\n    updatable?: boolean\r\n): Mesh => {\r\n    const options = {\r\n        xmin,\r\n        zmin,\r\n        xmax,\r\n        zmax,\r\n        subdivisions,\r\n        precision,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTiledGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateGroundFromHeightMap = (\r\n    name: string,\r\n    url: string,\r\n    width: number,\r\n    height: number,\r\n    subdivisions: number,\r\n    minHeight: number,\r\n    maxHeight: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    onReady?: (mesh: GroundMesh) => void,\r\n    alphaFilter?: number\r\n): GroundMesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        minHeight,\r\n        maxHeight,\r\n        updatable,\r\n        onReady,\r\n        alphaFilter,\r\n    };\r\n\r\n    return CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n", "import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * @returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (false as default)\r\n     * @param stride defines the vertex stride (optional)\r\n     * @returns the current mesh\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)\r\n     * @returns the source mesh\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices the source data\r\n     * @param totalVertices defines the total number of vertices referenced by indices (could be null)\r\n     * @returns source mesh\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns true if data kind is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * @returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera defines the camera to use to pick the LOD level\r\n     * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n    }\r\n\r\n    if (!this._userInstancedBuffersStorage) {\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n", "import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\nimport type { ExternalTexture } from \"./Textures/externalTexture\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindSceneUniformBuffer,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PushAttributesForInstances,\r\n} from \"./materialHelper.functions\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _materialHelperNeedsPreviousMatrices = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * is multiview set to true?\r\n     */\r\n    public get isMultiview(): boolean {\r\n        return this._multiview;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds, removes, or replaces the specified shader define and value.\r\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\r\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\r\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\r\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\r\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\r\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setDefine(define: string, value: boolean | string): ShaderMaterial {\r\n        // First remove any existing define with this name.\r\n        const defineName = define.trimEnd() + \" \";\r\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\r\n        if (existingDefineIdx >= 0) {\r\n            this.options.defines.splice(existingDefineIdx, 1);\r\n        }\r\n\r\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\r\n        if (typeof value !== \"boolean\" || value) {\r\n            this.options.defines.push(defineName + value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (uniforms.indexOf(\"viewProjection\") !== -1 && uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (uniforms.indexOf(\"mBones\") === -1) {\r\n                    uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetCount\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        // Fog\r\n        if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            defines.push(\"#define FOG\");\r\n            if (uniforms.indexOf(\"view\") === -1) {\r\n                uniforms.push(\"view\");\r\n            }\r\n            if (uniforms.indexOf(\"vFogInfos\") === -1) {\r\n                uniforms.push(\"vFogInfos\");\r\n            }\r\n            if (uniforms.indexOf(\"vFogColor\") === -1) {\r\n                uniforms.push(\"vFogColor\");\r\n            }\r\n        }\r\n\r\n        // Misc\r\n        if (this._useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n            if (uniforms.indexOf(\"logarithmicDepthConstant\") === -1) {\r\n                uniforms.push(\"logarithmicDepthConstant\");\r\n            }\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(undefined, true) : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        drawWrapper!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        drawWrapper!._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"view\") !== -1) {\r\n            effect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\r\n                        scene.finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", scene.getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", scene._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (scene.activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", scene.activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Misc\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);\r\n            }\r\n\r\n            // Fog\r\n            if (mesh) {\r\n                BindFogParameters(scene, mesh, effect);\r\n            }\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.floatsArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.floatsArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray: Texture[] = [];\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#include<fogFragment>(color,gl_FragColor)\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform mat4 view;\n#endif\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            const { x, y, z } = points[index];\r\n            positions.push(x, y, z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                const { r, g, b, a } = color[index];\r\n                vertexColors.push(r, g, b, a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * Construction options for a timer\r\n */\r\nexport interface ITimerOptions<T> {\r\n    /**\r\n     * Time-to-end\r\n     */\r\n    timeout: number;\r\n    /**\r\n     * The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.\r\n     * Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if\r\n     * you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time\r\n     */\r\n    contextObservable: Observable<T>;\r\n    /**\r\n     * Optional parameters when adding an observer to the observable\r\n     */\r\n    observableParameters?: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    /**\r\n     * An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!\r\n     */\r\n    breakCondition?: (data?: ITimerData<T>) => boolean;\r\n    /**\r\n     * Will be triggered when the time condition has met\r\n     */\r\n    onEnded?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Will be triggered when the break condition has met (prematurely ended)\r\n     */\r\n    onAborted?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Optional function to execute on each tick (or count)\r\n     */\r\n    onTick?: (data: ITimerData<any>) => void;\r\n}\r\n\r\n/**\r\n * An interface defining the data sent by the timer\r\n */\r\nexport interface ITimerData<T> {\r\n    /**\r\n     * When did it start\r\n     */\r\n    startTime: number;\r\n    /**\r\n     * Time now\r\n     */\r\n    currentTime: number;\r\n    /**\r\n     * Time passed since started\r\n     */\r\n    deltaTime: number;\r\n    /**\r\n     * How much is completed, in [0.0...1.0].\r\n     * Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls\r\n     */\r\n    completeRate: number;\r\n    /**\r\n     * What the registered observable sent in the last count\r\n     */\r\n    payload: T;\r\n}\r\n\r\n/**\r\n * The current state of the timer\r\n */\r\nexport enum TimerState {\r\n    /**\r\n     * Timer initialized, not yet started\r\n     */\r\n    INIT,\r\n    /**\r\n     * Timer started and counting\r\n     */\r\n    STARTED,\r\n    /**\r\n     * Timer ended (whether aborted or time reached)\r\n     */\r\n    ENDED,\r\n}\r\n\r\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n * @returns an observer that can be used to stop the timer\r\n */\r\nexport function setAndStartTimer<T = any>(options: ITimerOptions<T>): Nullable<Observer<T>> {\r\n    let timer = 0;\r\n    const startTime = Date.now();\r\n    options.observableParameters = options.observableParameters ?? {};\r\n    const observer = options.contextObservable.add(\r\n        (payload: any) => {\r\n            const now = Date.now();\r\n            timer = now - startTime;\r\n            const data: ITimerData<any> = {\r\n                startTime,\r\n                currentTime: now,\r\n                deltaTime: timer,\r\n                completeRate: timer / options.timeout,\r\n                payload,\r\n            };\r\n            options.onTick && options.onTick(data);\r\n            if (options.breakCondition && options.breakCondition()) {\r\n                options.contextObservable.remove(observer);\r\n                options.onAborted && options.onAborted(data);\r\n            }\r\n            if (timer >= options.timeout) {\r\n                options.contextObservable.remove(observer);\r\n                options.onEnded && options.onEnded(data);\r\n            }\r\n        },\r\n        options.observableParameters.mask,\r\n        options.observableParameters.insertFirst,\r\n        options.observableParameters.scope\r\n    );\r\n    return observer;\r\n}\r\n\r\n/**\r\n * An advanced implementation of a timer class\r\n */\r\nexport class AdvancedTimer<T = any> implements IDisposable {\r\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\r\n    public onEachCountObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\r\n    public onTimerAbortedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\r\n    public onTimerEndedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\r\n    public onStateChangedObservable: Observable<TimerState> = new Observable();\r\n\r\n    private _observer: Nullable<Observer<T>> = null;\r\n    private _contextObservable: Observable<T>;\r\n    private _observableParameters: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    private _startTime: number;\r\n    private _timer: number;\r\n    private _state: TimerState;\r\n    private _breakCondition: (data: ITimerData<T>) => boolean;\r\n    private _timeToEnd: number;\r\n    private _breakOnNextTick: boolean = false;\r\n\r\n    /**\r\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n     * @param options construction options for this advanced timer\r\n     */\r\n    constructor(options: ITimerOptions<T>) {\r\n        this._setState(TimerState.INIT);\r\n        this._contextObservable = options.contextObservable;\r\n        this._observableParameters = options.observableParameters ?? {};\r\n        this._breakCondition = options.breakCondition ?? (() => false);\r\n        this._timeToEnd = options.timeout;\r\n        if (options.onEnded) {\r\n            this.onTimerEndedObservable.add(options.onEnded);\r\n        }\r\n        if (options.onTick) {\r\n            this.onEachCountObservable.add(options.onTick);\r\n        }\r\n        if (options.onAborted) {\r\n            this.onTimerAbortedObservable.add(options.onAborted);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\r\n    public set breakCondition(predicate: (data: ITimerData<T>) => boolean) {\r\n        this._breakCondition = predicate;\r\n    }\r\n\r\n    /**\r\n     * Reset ALL associated observables in this advanced timer\r\n     */\r\n    public clearObservables() {\r\n        this.onEachCountObservable.clear();\r\n        this.onTimerAbortedObservable.clear();\r\n        this.onTimerEndedObservable.clear();\r\n        this.onStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n     *\r\n     * @param timeToEnd how much time to measure until timer ended\r\n     */\r\n    public start(timeToEnd: number = this._timeToEnd) {\r\n        if (this._state === TimerState.STARTED) {\r\n            throw new Error(\"Timer already started. Please stop it before starting again\");\r\n        }\r\n        this._timeToEnd = timeToEnd;\r\n        this._startTime = Date.now();\r\n        this._timer = 0;\r\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\r\n        this._setState(TimerState.STARTED);\r\n    }\r\n\r\n    /**\r\n     * Will force a stop on the next tick.\r\n     */\r\n    public stop() {\r\n        if (this._state !== TimerState.STARTED) {\r\n            return;\r\n        }\r\n        this._breakOnNextTick = true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this timer, clearing all resources\r\n     */\r\n    public dispose() {\r\n        if (this._observer) {\r\n            this._contextObservable.remove(this._observer);\r\n        }\r\n        this.clearObservables();\r\n    }\r\n\r\n    private _setState(newState: TimerState) {\r\n        this._state = newState;\r\n        this.onStateChangedObservable.notifyObservers(this._state);\r\n    }\r\n\r\n    private _tick = (payload: T) => {\r\n        const now = Date.now();\r\n        this._timer = now - this._startTime;\r\n        const data: ITimerData<T> = {\r\n            startTime: this._startTime,\r\n            currentTime: now,\r\n            deltaTime: this._timer,\r\n            completeRate: this._timer / this._timeToEnd,\r\n            payload,\r\n        };\r\n        const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\r\n        if (shouldBreak || this._timer >= this._timeToEnd) {\r\n            this._stop(data, shouldBreak);\r\n        } else {\r\n            this.onEachCountObservable.notifyObservers(data);\r\n        }\r\n    };\r\n\r\n    private _stop(data: ITimerData<T>, aborted: boolean = false) {\r\n        this._contextObservable.remove(this._observer);\r\n        this._setState(TimerState.ENDED);\r\n        if (aborted) {\r\n            this.onTimerAbortedObservable.notifyObservers(data);\r\n        } else {\r\n            this.onTimerEndedObservable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n", "import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n        /**\r\n         * Override the default material of the Landing Zone\r\n         */\r\n        teleportationCircleMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long in milliseconds should the \"long press\" take before teleport. Defaults to 3 seconds\r\n     */\r\n    timeToTeleport?: number;\r\n\r\n    /**\r\n     * If the main component is used, how long in milliseconds should the \"long press\" take before teleport starts. Defaults to 0\r\n     */\r\n    timeToTeleportStart?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * define an optional predicate to select which meshes should block the teleportation ray\r\n     */\r\n    blockerMeshesPredicate?: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Should the teleportation ray be blocked by all of the scene's pickable meshes?\r\n     * Defaults to false\r\n     */\r\n    blockAllPickableMeshes?: boolean;\r\n\r\n    /**\r\n     * Color of the teleportation ray when it is blocked by a mesh in the pickBlockerMeshes array\r\n     * Defaults to red.\r\n     */\r\n    blockedRayColor?: Color4;\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n                blocked: boolean;\r\n                initialHit: boolean;\r\n                mainComponentUsed: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _blockedRayColor: Color4;\r\n    private _cachedColor4White = new Color4(1, 1, 1, 1);\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>> = null;\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Observable raised before camera rotation\r\n     */\r\n    public onBeforeCameraTeleportRotation = new Observable<Number>();\r\n\r\n    /**\r\n     *  Observable raised after camera rotation\r\n     */\r\n    public onAfterCameraTeleportRotation = new Observable<Quaternion>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport: Observable<Vector3>;\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport: Observable<Vector3>;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: IWebXRTeleportationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n        this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\r\n\r\n        this._setTargetMeshVisibility(false);\r\n\r\n        // set the observables\r\n        this.onBeforeCameraTeleport = _options.xrInput.xrCamera.onBeforeCameraTeleport;\r\n        this.onAfterCameraTeleport = _options.xrInput.xrCamera.onAfterCameraTeleport;\r\n\r\n        this.parabolicCheckRadius *= this._xrSessionManager.worldScalingFactor;\r\n        this._worldScaleObserver = _xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {\r\n            this.parabolicCheckRadius = (this.parabolicCheckRadius / values.previousScaleFactor) * values.newScaleFactor;\r\n            this._options.teleportationTargetMesh?.scaling.scaleInPlace(values.newScaleFactor / values.previousScaleFactor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n        if (this._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                const controlSelectionFeature = controllerData.xrController.inputSource.targetRayMode !== \"transient-pointer\";\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\r\n                            return true;\r\n                        }\r\n                        if (this._options.blockAllPickableMeshes && o.isPickable) {\r\n                            return true;\r\n                        }\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\r\n                    if (pick && pick.pickedMesh && !floorMeshPicked) {\r\n                        if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\r\n                            controllerData.teleportationState.forward = false;\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.initialHit = true;\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\r\n                            return true;\r\n                        }\r\n                        if (this._options.blockAllPickableMeshes && o.isPickable) {\r\n                            return true;\r\n                        }\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\r\n                    if (pick && pick.pickedMesh && !floorMeshPicked) {\r\n                        if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\r\n                            controllerData.teleportationState.forward = false;\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.initialHit = true;\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible, false, controlSelectionFeature);\r\n            } else {\r\n                this._setTargetMeshVisibility(false, false, true);\r\n            }\r\n        } else {\r\n            this._disposeBezierCurve();\r\n            this._setTargetMeshVisibility(false, false, true);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n                blocked: false,\r\n                initialHit: false,\r\n                mainComponentUsed: false,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.mainComponentUsed = true;\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n\r\n                            const teleportLocal = () => {\r\n                                // simulate \"forward\" thumbstick push\r\n                                controllerData.teleportationState.forward = true;\r\n                                controllerData.teleportationState.initialHit = false;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                controllerData.teleportationState.currentRotation = 0;\r\n                                const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                setAndStartTimer({\r\n                                    timeout: timeToSelect,\r\n                                    contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                    breakCondition: () => !mainComponent.pressed,\r\n                                    onEnded: () => {\r\n                                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                            this._teleportForward(xrController.uniqueId);\r\n                                        }\r\n                                    },\r\n                                });\r\n                            };\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // delay if the start time is defined\r\n                                    if (this._options.timeToTeleportStart) {\r\n                                        setAndStartTimer({\r\n                                            timeout: this._options.timeToTeleportStart,\r\n                                            contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                            onEnded: () => {\r\n                                                // check if still pressed\r\n                                                if (mainComponent.pressed) {\r\n                                                    teleportLocal();\r\n                                                }\r\n                                            },\r\n                                        });\r\n                                    } else {\r\n                                        teleportLocal();\r\n                                    }\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        this.onBeforeCameraTeleportRotation.notifyObservers(rotation);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                        this.onAfterCameraTeleportRotation.notifyObservers(this._options.xrInput.xrCamera.rotationQuaternion);\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.blocked) {\r\n                                    controllerData.teleportationState.blocked = false;\r\n                                    this._setTargetMeshVisibility(false);\r\n                                }\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            controllerData.teleportationState.mainComponentUsed = true;\r\n            let breakObserver = false;\r\n            const teleportLocal = () => {\r\n                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                controllerData.teleportationState.forward = true;\r\n                controllerData.teleportationState.initialHit = false;\r\n                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                controllerData.teleportationState.currentRotation = 0;\r\n                const timeToSelect = this._options.timeToTeleport || 3000;\r\n                setAndStartTimer({\r\n                    timeout: timeToSelect,\r\n                    contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                    onEnded: () => {\r\n                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                            this._teleportForward(xrController.uniqueId);\r\n                        }\r\n                    },\r\n                });\r\n            };\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    breakObserver = false;\r\n                    // check if start time is defined\r\n                    if (this._options.timeToTeleportStart) {\r\n                        setAndStartTimer({\r\n                            timeout: this._options.timeToTeleportStart,\r\n                            contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                            onEnded: () => {\r\n                                // make sure pointer up was not triggered during this time\r\n                                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                    teleportLocal();\r\n                                }\r\n                            },\r\n                            breakCondition: () => {\r\n                                if (breakObserver) {\r\n                                    breakObserver = false;\r\n                                    return true;\r\n                                }\r\n                                return false;\r\n                            },\r\n                        });\r\n                    } else {\r\n                        teleportLocal();\r\n                    }\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    breakObserver = true;\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n\r\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\r\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\r\n        } else {\r\n            const length = 512;\r\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n            dynamicTexture.hasAlpha = true;\r\n            const context = dynamicTexture.getContext();\r\n            const centerX = length / 2;\r\n            const centerY = length / 2;\r\n            const radius = 200;\r\n            context.beginPath();\r\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n            context.fill();\r\n            context.lineWidth = 10;\r\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n            context.stroke();\r\n            context.closePath();\r\n            dynamicTexture.update();\r\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n            teleportationTarget.material = teleportationCircleMaterial;\r\n        }\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys: { frame: number; value: number }[] = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n        this._options.teleportationTargetMesh.scaling.setAll(this._xrSessionManager.worldScalingFactor);\r\n        // hide the teleportation target mesh right after creating it.\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean, force?: boolean, controlSelectionFeature?: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature && controlSelectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature && controlSelectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disposeBezierCurve() {\r\n        if (this._quadraticBezierCurve) {\r\n            this._quadraticBezierCurve.dispose();\r\n            this._quadraticBezierCurve = null;\r\n        }\r\n    }\r\n\r\n    private _colorArray: Color4[] = Array(24).fill(this._cachedColor4White);\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\r\n        const colorsArray = this._colorArray.fill(color || this._cachedColor4White);\r\n        // take out the first 2 points, to not start directly from the controller\r\n        const points = quadraticBezierVectors.getPoints();\r\n        points.shift();\r\n        points.shift();\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: points, instance: this._quadraticBezierCurve as LinesMesh, updatable: true, colors: colorsArray },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n", "import { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IWebXRInputOptions } from \"./webXRInput\";\r\nimport { WebXRInput } from \"./webXRInput\";\r\nimport type { IWebXRControllerPointerSelectionOptions } from \"./features/WebXRControllerPointerSelection\";\r\nimport { WebXRControllerPointerSelection } from \"./features/WebXRControllerPointerSelection\";\r\nimport type { IWebXRNearInteractionOptions } from \"./features/WebXRNearInteraction\";\r\nimport { WebXRNearInteraction } from \"./features/WebXRNearInteraction\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXREnterExitUIOptions } from \"./webXREnterExitUI\";\r\nimport { WebXREnterExitUI } from \"./webXREnterExitUI\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { IWebXRTeleportationOptions } from \"./features/WebXRControllerTeleportation\";\r\nimport { WebXRHandTracking, type IWebXRHandTrackingOptions } from \"./features/WebXRHandTracking\";\r\nimport { WebXRMotionControllerTeleportation } from \"./features/WebXRControllerTeleportation\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Options for the default xr helper\r\n */\r\nexport class WebXRDefaultExperienceOptions {\r\n    /**\r\n     * Enable or disable default UI to enter XR\r\n     */\r\n    public disableDefaultUI?: boolean;\r\n    /**\r\n     * Should pointer selection not initialize.\r\n     * Note that disabling pointer selection also disables teleportation.\r\n     * Defaults to false.\r\n     */\r\n    public disablePointerSelection?: boolean;\r\n    /**\r\n     * Should teleportation not initialize. Defaults to false.\r\n     */\r\n    public disableTeleportation?: boolean;\r\n    /**\r\n     * Should nearInteraction not initialize. Defaults to false.\r\n     */\r\n    public disableNearInteraction?: boolean;\r\n\r\n    /**\r\n     * Should hand tracking be disabled. Defaults to false.\r\n     */\r\n    public disableHandTracking?: boolean;\r\n    /**\r\n     * Floor meshes that will be used for teleport\r\n     */\r\n    public floorMeshes?: Array<AbstractMesh>;\r\n    /**\r\n     * If set to true, the first frame will not be used to reset position\r\n     * The first frame is mainly used when copying transformation from the old camera\r\n     * Mainly used in AR\r\n     */\r\n    public ignoreNativeCameraTransformation?: boolean;\r\n    /**\r\n     * Optional configuration for the XR input object\r\n     */\r\n    public inputOptions?: Partial<IWebXRInputOptions>;\r\n    /**\r\n     * optional configuration for pointer selection\r\n     */\r\n    public pointerSelectionOptions?: Partial<IWebXRControllerPointerSelectionOptions>;\r\n    /**\r\n     * optional configuration for near interaction\r\n     */\r\n    public nearInteractionOptions?: Partial<IWebXRNearInteractionOptions>;\r\n\r\n    /**\r\n     * optional configuration for hand tracking\r\n     */\r\n    public handSupportOptions?: Partial<IWebXRHandTrackingOptions>;\r\n    /**\r\n     * optional configuration for teleportation\r\n     */\r\n    public teleportationOptions?: Partial<IWebXRTeleportationOptions>;\r\n    /**\r\n     * optional configuration for the output canvas\r\n     */\r\n    public outputCanvasOptions?: WebXRManagedOutputCanvasOptions;\r\n    /**\r\n     * optional UI options. This can be used among other to change session mode and reference space type\r\n     */\r\n    public uiOptions?: Partial<WebXREnterExitUIOptions>;\r\n    /**\r\n     * When loading teleportation and pointer select, use stable versions instead of latest.\r\n     */\r\n    public useStablePlugins?: boolean;\r\n\r\n    /**\r\n     * An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes\r\n     */\r\n    public renderingGroupId?: number;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     * If set to true, all features we support will be added\r\n     */\r\n    public optionalFeatures?: boolean | string[];\r\n}\r\n\r\n/**\r\n * Default experience for webxr\r\n */\r\nexport class WebXRDefaultExperience {\r\n    /**\r\n     * Base experience\r\n     */\r\n    public baseExperience: WebXRExperienceHelper;\r\n    /**\r\n     * Enables ui for entering/exiting xr\r\n     */\r\n    public enterExitUI: WebXREnterExitUI;\r\n    /**\r\n     * Input experience extension\r\n     */\r\n    public input: WebXRInput;\r\n    /**\r\n     * Enables laser pointer and selection\r\n     */\r\n    public pointerSelection: WebXRControllerPointerSelection;\r\n    /**\r\n     * Default target xr should render to\r\n     */\r\n    public renderTarget: WebXRRenderTarget;\r\n    /**\r\n     * Enables teleportation\r\n     */\r\n    public teleportation: WebXRMotionControllerTeleportation;\r\n\r\n    /**\r\n     * Enables near interaction for hands/controllers\r\n     */\r\n    public nearInteraction: WebXRNearInteraction;\r\n\r\n    private constructor() {}\r\n\r\n    /**\r\n     * Creates the default xr experience\r\n     * @param scene scene\r\n     * @param options options for basic configuration\r\n     * @returns resulting WebXRDefaultExperience\r\n     */\r\n    public static CreateAsync(scene: Scene, options: WebXRDefaultExperienceOptions = {}) {\r\n        const result = new WebXRDefaultExperience();\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            result.dispose();\r\n        });\r\n        // init the UI right after construction\r\n        if (!options.disableDefaultUI) {\r\n            const uiOptions: WebXREnterExitUIOptions = {\r\n                renderTarget: result.renderTarget,\r\n                ...(options.uiOptions || {}),\r\n            };\r\n            if (options.optionalFeatures) {\r\n                if (typeof options.optionalFeatures === \"boolean\") {\r\n                    uiOptions.optionalFeatures = [\"hit-test\", \"anchors\", \"plane-detection\", \"hand-tracking\"];\r\n                } else {\r\n                    uiOptions.optionalFeatures = options.optionalFeatures;\r\n                }\r\n            }\r\n            result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);\r\n        }\r\n\r\n        // Create base experience\r\n        return WebXRExperienceHelper.CreateAsync(scene)\r\n            .then((xrHelper) => {\r\n                result.baseExperience = xrHelper;\r\n\r\n                if (options.ignoreNativeCameraTransformation) {\r\n                    result.baseExperience.camera.compensateOnFirstFrame = false;\r\n                }\r\n\r\n                // Add controller support\r\n                result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {\r\n                    controllerOptions: {\r\n                        renderingGroupId: options.renderingGroupId,\r\n                    },\r\n                    ...(options.inputOptions || {}),\r\n                });\r\n\r\n                if (!options.disablePointerSelection) {\r\n                    // Add default pointer selection\r\n                    const pointerSelectionOptions = {\r\n                        ...options.pointerSelectionOptions,\r\n                        xrInput: result.input,\r\n                        renderingGroupId: options.renderingGroupId,\r\n                    };\r\n\r\n                    result.pointerSelection = <WebXRControllerPointerSelection>(\r\n                        result.baseExperience.featuresManager.enableFeature(\r\n                            WebXRControllerPointerSelection.Name,\r\n                            options.useStablePlugins ? \"stable\" : \"latest\",\r\n                            <IWebXRControllerPointerSelectionOptions>pointerSelectionOptions\r\n                        )\r\n                    );\r\n\r\n                    if (!options.disableTeleportation) {\r\n                        // Add default teleportation, including rotation\r\n                        result.teleportation = <WebXRMotionControllerTeleportation>result.baseExperience.featuresManager.enableFeature(\r\n                            WebXRMotionControllerTeleportation.Name,\r\n                            options.useStablePlugins ? \"stable\" : \"latest\",\r\n                            <IWebXRTeleportationOptions>{\r\n                                floorMeshes: options.floorMeshes,\r\n                                xrInput: result.input,\r\n                                renderingGroupId: options.renderingGroupId,\r\n                                ...options.teleportationOptions,\r\n                            }\r\n                        );\r\n                        result.teleportation.setSelectionFeature(result.pointerSelection);\r\n                    }\r\n                }\r\n\r\n                if (!options.disableNearInteraction) {\r\n                    // Add default pointer selection\r\n                    result.nearInteraction = <WebXRNearInteraction>result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRNearInteraction.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRNearInteractionOptions>{\r\n                            xrInput: result.input,\r\n                            farInteractionFeature: result.pointerSelection,\r\n                            renderingGroupId: options.renderingGroupId,\r\n                            useUtilityLayer: true,\r\n                            enableNearInteractionOnAllControllers: true,\r\n                            ...options.nearInteractionOptions,\r\n                        }\r\n                    );\r\n                }\r\n\r\n                if (!options.disableHandTracking) {\r\n                    // Add default hand tracking\r\n                    result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRHandTracking.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRHandTrackingOptions>{\r\n                            xrInput: result.input,\r\n                            ...options.handSupportOptions,\r\n                        },\r\n                        undefined,\r\n                        false\r\n                    );\r\n                }\r\n\r\n                // Create the WebXR output target\r\n                result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);\r\n\r\n                if (!options.disableDefaultUI) {\r\n                    // Create ui for entering/exiting xr\r\n                    return result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);\r\n                } else {\r\n                    return;\r\n                }\r\n            })\r\n            .then(() => {\r\n                return result;\r\n            })\r\n            .catch((error) => {\r\n                Logger.Error(\"Error initializing XR\");\r\n                Logger.Error(error);\r\n                return result;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        if (this.baseExperience) {\r\n            this.baseExperience.dispose();\r\n        }\r\n        if (this.input) {\r\n            this.input.dispose();\r\n        }\r\n        if (this.enterExitUI) {\r\n            this.enterExitUI.dispose();\r\n        }\r\n        if (this.renderTarget) {\r\n            this.renderTarget.dispose();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a", "rejectionReason", "name", "_CameraProperty", "name", "WebXRState", "WebXRTrackingState", "name", "i", "name", "Xbox360Button", "Xbox360Dpad", "DualShockButton", "DualShockDpad", "observer", "name", "name", "name", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "factory", "name", "plugin", "code", "name", "name", "controllerCache", "pose", "radius", "angle", "i", "v", "name", "name", "result", "name", "name", "pointerEvent", "AnimationKeyInterpolation", "name", "name", "ControllerOrbAnimationState", "WebXRNearControllerMode", "touchCollisionMesh", "touchCollisionMeshFunction", "hydrateCollisionMeshFunction", "name", "name", "name", "name", "onCreatedEffectParameters", "name", "drawWrapper", "name", "shader", "name", "shader", "shader", "name", "name", "dashSize", "gapSize", "observer", "TimerState", "name"]
}
