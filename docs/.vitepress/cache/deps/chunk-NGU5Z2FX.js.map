{
  "version": 3,
  "sources": ["../../../dev/core/src/XR/features/WebXRHitTestLegacy.ts", "../../../dev/core/src/XR/features/WebXRAnchorSystem.ts", "../../../dev/core/src/XR/features/WebXRPlaneDetector.ts", "../../../dev/core/src/XR/features/WebXRBackgroundRemover.ts", "../../../dev/core/src/XR/features/WebXRControllerPhysics.ts", "../../../dev/core/src/XR/features/WebXRHitTest.ts", "../../../dev/core/src/XR/features/WebXRFeaturePointSystem.ts", "../../../dev/core/src/XR/features/WebXRMeshDetector.ts", "../../../dev/core/src/XR/features/WebXRImageTracking.ts", "../../../dev/core/src/XR/features/WebXRDOMOverlay.ts", "../../../dev/core/src/XR/features/WebXRControllerMovement.ts", "../../../dev/core/src/Lights/shadowLight.ts", "../../../dev/core/src/Lights/directionalLight.ts", "../../../dev/core/src/Maths/sphericalPolynomial.ts", "../../../dev/core/src/Shaders/hdrFiltering.vertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/importanceSampling.ts", "../../../dev/core/src/Shaders/ShadersInclude/pbrBRDFFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/hdrFilteringFunctions.ts", "../../../dev/core/src/Shaders/hdrFiltering.fragment.ts", "../../../dev/core/src/Materials/Textures/Filtering/hdrFiltering.ts", "../../../dev/core/src/XR/features/WebXRLightEstimation.ts", "../../../dev/core/src/XR/features/WebXREyeTracking.ts", "../../../dev/core/src/XR/features/WebXRWalkingLocomotion.ts", "../../../dev/core/src/XR/features/Layers/WebXRCompositionLayer.ts", "../../../dev/core/src/XR/features/Layers/WebXRProjectionLayer.ts", "../../../dev/core/src/XR/features/WebXRLayers.ts", "../../../dev/core/src/Engines/Extensions/engine.rawTexture.ts", "../../../dev/core/src/Materials/Textures/rawTexture.ts", "../../../dev/core/src/XR/features/WebXRDepthSensing.ts", "../../../dev/core/src/Shaders/velocity.fragment.ts", "../../../dev/core/src/Shaders/velocity.vertex.ts", "../../../dev/core/src/XR/features/WebXRSpaceWarp.ts", "../../../dev/core/src/XR/features/WebXRRawCameraAccess.ts", "../../../dev/core/src/XR/motionController/webXRGenericHandController.ts", "../../../dev/core/src/XR/motionController/webXRMicrosoftMixedRealityController.ts", "../../../dev/core/src/XR/motionController/webXROculusTouchMotionController.ts", "../../../dev/core/src/XR/motionController/webXRHTCViveMotionController.ts", "../../../dev/core/src/Shaders/rgbdDecode.fragment.ts", "../../../dev/core/src/Shaders/passCube.fragment.ts", "../../../dev/core/src/PostProcesses/passPostProcess.ts", "../../../dev/core/src/Misc/textureTools.ts", "../../../dev/core/src/Misc/rgbdTextureTools.ts", "../../../dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts", "../../../dev/core/src/Materials/Textures/baseTexture.polynomial.ts", "../../../dev/core/src/Shaders/rgbdEncode.fragment.ts", "../../../dev/core/src/Misc/environmentTextureTools.ts", "../../../dev/core/src/Misc/codeStringParsingTools.ts", "../../../dev/core/src/Engines/Processors/shaderCodeInliner.ts", "../../../dev/core/src/Engines/Native/nativeDataStream.ts", "../../../dev/core/src/Engines/Native/nativePipelineContext.ts", "../../../dev/core/src/Engines/Native/nativeRenderTargetWrapper.ts", "../../../dev/core/src/Engines/Native/nativeHardwareTexture.ts", "../../../dev/core/src/Engines/Native/nativeHelpers.ts", "../../../dev/core/src/Engines/nativeEngine.ts", "../../../dev/core/src/XR/native/nativeXRFrame.ts"],
  "sourcesContent": ["import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n// the plugin is registered at the end of the file\r\n\r\n/**\r\n * An interface for all Hit test features\r\n */\r\nexport interface IWebXRHitTestFeature<T extends IWebXRLegacyHitResult> extends IWebXRFeature {\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     */\r\n    onHitTestResultObservable: Observable<T[]>;\r\n}\r\n\r\n/**\r\n * Options used for hit testing\r\n */\r\nexport interface IWebXRLegacyHitTestOptions {\r\n    /**\r\n     * Only test when user interacted with the scene. Default - hit test every frame\r\n     */\r\n    testOnPointerDownOnly?: boolean;\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n}\r\n\r\n/**\r\n * Interface defining the babylon result of raycasting/hit-test\r\n */\r\nexport interface IWebXRLegacyHitResult {\r\n    /**\r\n     * Transformation matrix that can be applied to a node that will put it in the hit point location\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native hit test result\r\n     */\r\n    xrHitResult: XRHitResult | XRHitTestResult;\r\n}\r\n\r\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n */\r\nexport class WebXRHitTestLegacy extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRLegacyHitResult> {\r\n    // in XR space z-forward is negative\r\n    private _direction = new Vector3(0, 0, -1);\r\n    private _mat = new Matrix();\r\n    private _onSelectEnabled = false;\r\n    private _origin = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HIT_TEST;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Populated with the last native XR Hit Results\r\n     */\r\n    public lastNativeXRHitResults: XRHitResult[] = [];\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     */\r\n    public onHitTestResultObservable: Observable<IWebXRLegacyHitResult[]> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the (legacy version) hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRLegacyHitTestOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hit-test\";\r\n        Tools.Warn(\"A newer version of this plugin is available\");\r\n    }\r\n\r\n    /**\r\n     * execute a hit test with an XR Ray\r\n     *\r\n     * @param xrSession a native xrSession that will execute this hit test\r\n     * @param xrRay the ray (position and direction) to use for ray-casting\r\n     * @param referenceSpace native XR reference space to use for the hit-test\r\n     * @param filter filter function that will filter the results\r\n     * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\r\n     */\r\n    public static XRHitTestWithRay(xrSession: XRSession, xrRay: XRRay, referenceSpace: XRReferenceSpace, filter?: (result: XRHitResult) => boolean): Promise<XRHitResult[]> {\r\n        return xrSession.requestHitTest!(xrRay, referenceSpace).then((results) => {\r\n            const filterFunction = filter || ((result) => !!result.hitMatrix);\r\n            return results.filter(filterFunction);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Execute a hit test on the current running session using a select event returned from a transient input (such as touch)\r\n     * @param event the (select) event to use to select with\r\n     * @param referenceSpace the reference space to use for this hit test\r\n     * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\r\n     */\r\n    public static XRHitTestWithSelectEvent(event: XRInputSourceEvent, referenceSpace: XRReferenceSpace): Promise<XRHitResult[]> {\r\n        const targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);\r\n        if (!targetRayPose) {\r\n            return Promise.resolve([]);\r\n        }\r\n        const targetRay = new XRRay(targetRayPose.transform);\r\n\r\n        return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n        if (this.options.testOnPointerDownOnly) {\r\n            this._xrSessionManager.session.addEventListener(\"select\", this._onSelect, false);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        // disable select\r\n        this._onSelectEnabled = false;\r\n        this._xrSessionManager.session.removeEventListener(\"select\", this._onSelect);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHitTestResultObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // make sure we do nothing if (async) not attached\r\n        if (!this.attached || this.options.testOnPointerDownOnly) {\r\n            return;\r\n        }\r\n        const pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);\r\n        this._direction.subtractInPlace(this._origin);\r\n        this._direction.normalize();\r\n        const ray = new XRRay(\r\n            <DOMPointReadOnly>{ x: this._origin.x, y: this._origin.y, z: this._origin.z, w: 0 },\r\n            <DOMPointReadOnly>{ x: this._direction.x, y: this._direction.y, z: this._direction.z, w: 0 }\r\n        );\r\n        WebXRHitTestLegacy.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);\r\n    }\r\n\r\n    private _onHitTestResults = (xrResults: XRHitResult[]) => {\r\n        const mats = xrResults.map((result) => {\r\n            const mat = Matrix.FromArray(result.hitMatrix);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            // if (this.options.coordinatesSpace === Space.WORLD) {\r\n            if (this.options.worldParentNode) {\r\n                mat.multiplyToRef(this.options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n            return {\r\n                xrHitResult: result,\r\n                transformationMatrix: mat,\r\n            };\r\n        });\r\n\r\n        this.lastNativeXRHitResults = xrResults;\r\n        this.onHitTestResultObservable.notifyObservers(mats);\r\n    };\r\n\r\n    // can be done using pointerdown event, and xrSessionManager.currentFrame\r\n    private _onSelect = (event: XRInputSourceEvent) => {\r\n        if (!this._onSelectEnabled) {\r\n            return;\r\n        }\r\n        WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, this._xrSessionManager.referenceSpace);\r\n    };\r\n}\r\n\r\n//register the plugin versions\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHitTestLegacy.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHitTestLegacy(xrSessionManager, options);\r\n    },\r\n    WebXRHitTestLegacy.Version,\r\n    false\r\n);\r\n", "import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRHitResult } from \"./WebXRHitTest\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Configuration options of the anchor system\r\n */\r\nexport interface IWebXRAnchorSystemOptions {\r\n    /**\r\n     * a node that will be used to convert local to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n\r\n    /**\r\n     * If set to true a reference of the created anchors will be kept until the next session starts\r\n     * If not defined, anchors will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveAnchorsOnSessionEnded?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon container for an XR Anchor\r\n */\r\nexport interface IWebXRAnchor {\r\n    /**\r\n     * A babylon-assigned ID for this anchor\r\n     */\r\n    id: number;\r\n    /**\r\n     * Transformation matrix to apply to an object attached to this anchor\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native anchor object\r\n     */\r\n    xrAnchor: XRAnchor;\r\n\r\n    /**\r\n     * if defined, this object will be constantly updated by the anchor's position and rotation\r\n     */\r\n    attachedNode?: TransformNode;\r\n\r\n    /**\r\n     * Remove this anchor from the scene\r\n     */\r\n    remove(): void;\r\n}\r\n\r\n/**\r\n * An internal interface for a future (promise based) anchor\r\n */\r\ninterface IWebXRFutureAnchor {\r\n    /**\r\n     * The native anchor\r\n     */\r\n    nativeAnchor?: XRAnchor;\r\n    /**\r\n     * Was this request submitted to the xr frame?\r\n     */\r\n    submitted: boolean;\r\n    /**\r\n     * Was this promise resolved already?\r\n     */\r\n    resolved: boolean;\r\n    /**\r\n     * A resolve function\r\n     */\r\n    resolve: (xrAnchor: IWebXRAnchor) => void;\r\n    /**\r\n     * A reject function\r\n     */\r\n    reject: (msg?: string) => void;\r\n    /**\r\n     * The XR Transformation of the future anchor\r\n     */\r\n    xrTransformation: XRRigidTransform;\r\n}\r\n\r\nlet anchorIdProvider = 0;\r\n\r\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\r\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\r\n    private _lastFrameDetected: XRAnchorSet = new Set();\r\n\r\n    private _trackedAnchors: Array<IWebXRAnchor> = [];\r\n\r\n    private _referenceSpaceForFrameAnchors: XRReferenceSpace;\r\n\r\n    private _futureAnchors: IWebXRFutureAnchor[] = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.ANCHOR_SYSTEM;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\r\n    public onAnchorAddedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\r\n    public onAnchorRemovedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\r\n    public onAnchorUpdatedObservable: Observable<IWebXRAnchor> = new Observable();\r\n\r\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\r\n    public set referenceSpaceForFrameAnchors(referenceSpace: XRReferenceSpace) {\r\n        this._referenceSpaceForFrameAnchors = referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: IWebXRAnchorSystemOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"anchors\";\r\n    }\r\n\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    private _populateTmpTransformation(position: Vector3, rotationQuaternion: Quaternion) {\r\n        this._tmpVector.copyFrom(position);\r\n        this._tmpQuaternion.copyFrom(rotationQuaternion);\r\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n            this._tmpVector.z *= -1;\r\n            this._tmpQuaternion.z *= -1;\r\n            this._tmpQuaternion.w *= -1;\r\n        }\r\n        return {\r\n            position: this._tmpVector,\r\n            rotationQuaternion: this._tmpQuaternion,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a new anchor point using a hit test result at a specific point in the scene\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param hitTestResult The hit test result to use for this anchor creation\r\n     * @param position an optional position offset for this anchor\r\n     * @param rotationQuaternion an optional rotation offset for this anchor\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorPointUsingHitTestResultAsync(\r\n        hitTestResult: IWebXRHitResult,\r\n        position: Vector3 = new Vector3(),\r\n        rotationQuaternion: Quaternion = new Quaternion()\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const m = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        if (!hitTestResult.xrHitResult.createAnchor) {\r\n            this.detach();\r\n            throw new Error(\"Anchors not enabled in this environment/browser\");\r\n        } else {\r\n            try {\r\n                const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\r\n                return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n                    this._futureAnchors.push({\r\n                        nativeAnchor,\r\n                        resolved: false,\r\n                        submitted: true,\r\n                        xrTransformation: m,\r\n                        resolve,\r\n                        reject,\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new anchor at a specific position and rotation\r\n     * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n     * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param position the position in which to add an anchor\r\n     * @param rotationQuaternion an optional rotation for the anchor transformation\r\n     * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorAtPositionAndRotationAsync(\r\n        position: Vector3,\r\n        rotationQuaternion: Quaternion = new Quaternion(),\r\n        forceCreateInCurrentFrame = false\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const xrTransformation = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        const xrAnchor =\r\n            forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame\r\n                ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)\r\n                : undefined;\r\n        // add the transformation to the future anchors list\r\n        return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n            this._futureAnchors.push({\r\n                nativeAnchor: xrAnchor,\r\n                resolved: false,\r\n                submitted: false,\r\n                xrTransformation,\r\n                resolve,\r\n                reject,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\r\n    public get anchors(): IWebXRAnchor[] {\r\n        return this._trackedAnchors;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\r\n            while (this._trackedAnchors.length) {\r\n                const toRemove = this._trackedAnchors.pop();\r\n                if (toRemove) {\r\n                    try {\r\n                        // try to natively remove it as well\r\n                        toRemove.remove();\r\n                    } catch (e) {\r\n                        // no-op\r\n                    }\r\n                    // as the xr frame loop is removed, we need to notify manually\r\n                    this.onAnchorRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._futureAnchors.length = 0;\r\n        super.dispose();\r\n        this.onAnchorAddedObservable.clear();\r\n        this.onAnchorRemovedObservable.clear();\r\n        this.onAnchorUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        const trackedAnchors = frame.trackedAnchors;\r\n        if (trackedAnchors) {\r\n            const toRemove = this._trackedAnchors\r\n                .filter((anchor) => !trackedAnchors.has(anchor.xrAnchor))\r\n                .map((anchor) => {\r\n                    const index = this._trackedAnchors.indexOf(anchor);\r\n                    return index;\r\n                });\r\n            let idxTracker = 0;\r\n            toRemove.forEach((index) => {\r\n                const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\r\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\r\n                idxTracker++;\r\n            });\r\n            // now check for new ones\r\n            trackedAnchors.forEach((xrAnchor) => {\r\n                if (!this._lastFrameDetected.has(xrAnchor)) {\r\n                    const newAnchor: Partial<IWebXRAnchor> = {\r\n                        id: anchorIdProvider++,\r\n                        xrAnchor: xrAnchor,\r\n                        remove: () => xrAnchor.delete(),\r\n                    };\r\n                    const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\r\n                    this._trackedAnchors.push(anchor);\r\n                    this.onAnchorAddedObservable.notifyObservers(anchor);\r\n                    // search for the future anchor promise that matches this\r\n                    const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);\r\n                    const result = results[0];\r\n                    if (result) {\r\n                        result.resolve(anchor);\r\n                        result.resolved = true;\r\n                    }\r\n                } else {\r\n                    const index = this._findIndexInAnchorArray(xrAnchor);\r\n                    const anchor = this._trackedAnchors[index];\r\n                    try {\r\n                        // anchors update every frame\r\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\r\n                        if (anchor.attachedNode) {\r\n                            anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\r\n                            anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\r\n                        }\r\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\r\n                    } catch (e) {\r\n                        Tools.Warn(`Anchor could not be updated`);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = trackedAnchors;\r\n        }\r\n\r\n        // process future anchors\r\n        this._futureAnchors.forEach((futureAnchor) => {\r\n            if (!futureAnchor.resolved && !futureAnchor.submitted) {\r\n                this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(\r\n                    (nativeAnchor) => {\r\n                        futureAnchor.nativeAnchor = nativeAnchor;\r\n                    },\r\n                    (error) => {\r\n                        futureAnchor.resolved = true;\r\n                        futureAnchor.reject(error);\r\n                    }\r\n                );\r\n                futureAnchor.submitted = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrAnchor the plane to find in the array\r\n     * @returns the index of the anchor in the array or -1 if not found\r\n     */\r\n    private _findIndexInAnchorArray(xrAnchor: XRAnchor) {\r\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\r\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private _updateAnchorWithXRFrame(xrAnchor: XRAnchor, anchor: Partial<IWebXRAnchor>, xrFrame: XRFrame): IWebXRAnchor {\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = anchor.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            anchor.transformationMatrix = mat;\r\n            if (!this._options.worldParentNode) {\r\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\r\n            } else {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRAnchor>anchor;\r\n    }\r\n\r\n    private async _createAnchorAtTransformation(xrTransformation: XRRigidTransform, xrFrame: XRFrame) {\r\n        if (xrFrame.createAnchor) {\r\n            try {\r\n                return xrFrame.createAnchor(xrTransformation, this._referenceSpaceForFrameAnchors ?? this._xrSessionManager.referenceSpace);\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        } else {\r\n            this.detach();\r\n            throw new Error(\"Anchors are not enabled in your browser\");\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRAnchorSystem.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRAnchorSystem(xrSessionManager, options);\r\n    },\r\n    WebXRAnchorSystem.Version\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\ndeclare const XRPlane: XRPlane;\r\n\r\n/**\r\n * Options used in the plane detector module\r\n */\r\nexport interface IWebXRPlaneDetectorOptions {\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * If set to true a reference of the created planes will be kept until the next session starts\r\n     * If not defined, planes will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemovePlanesOnSessionEnded?: boolean;\r\n    /**\r\n     * Preferred detector configuration, not all preferred options will be supported by all platforms.\r\n     */\r\n    preferredDetectorOptions?: XRGeometryDetectorOptions;\r\n}\r\n\r\n/**\r\n * A babylon interface for a WebXR plane.\r\n * A Plane is actually a polygon, built from N points in space\r\n *\r\n * Supported in chrome 79, not supported in canary 81 ATM\r\n */\r\nexport interface IWebXRPlane {\r\n    /**\r\n     * a babylon-assigned ID for this polygon\r\n     */\r\n    id: number;\r\n    /**\r\n     * an array of vector3 points in babylon space. right/left hand system is taken into account.\r\n     */\r\n    polygonDefinition: Array<Vector3>;\r\n    /**\r\n     * A transformation matrix to apply on the mesh that will be built using the polygonDefinition\r\n     * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * the native xr-plane object\r\n     */\r\n    xrPlane: XRPlane;\r\n}\r\n\r\nlet planeIdProvider = 0;\r\n\r\n/**\r\n * The plane detector is used to detect planes in the real world when in AR\r\n * For more information see https://github.com/immersive-web/real-world-geometry/\r\n */\r\nexport class WebXRPlaneDetector extends WebXRAbstractFeature {\r\n    private _detectedPlanes: Array<IWebXRPlane> = [];\r\n    private _enabled: boolean = false;\r\n    private _lastFrameDetected: XRPlaneSet = new Set();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PLANE_DETECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new plane was added to the session\r\n     */\r\n    public onPlaneAddedObservable: Observable<IWebXRPlane> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when a plane is no longer detected in the session\r\n     */\r\n    public onPlaneRemovedObservable: Observable<IWebXRPlane> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\r\n     * This can execute N times every frame\r\n     */\r\n    public onPlaneUpdatedObservable: Observable<IWebXRPlane> = new Observable();\r\n\r\n    /**\r\n     * construct a new Plane Detector\r\n     * @param _xrSessionManager an instance of xr Session manager\r\n     * @param _options configuration to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: IWebXRPlaneDetectorOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"plane-detection\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemovePlanesOnSessionEnded) {\r\n            while (this._detectedPlanes.length) {\r\n                const toRemove = this._detectedPlanes.pop();\r\n                if (toRemove) {\r\n                    this.onPlaneRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onPlaneAddedObservable.clear();\r\n        this.onPlaneRemovedObservable.clear();\r\n        this.onPlaneUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     * @returns true if the initial compatibility test passed\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRPlane !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Enable room capture mode.\r\n     * When enabled and supported by the system,\r\n     * the detectedPlanes array will be populated with the detected room boundaries\r\n     * @see https://immersive-web.github.io/real-world-geometry/plane-detection.html#dom-xrsession-initiateroomcapture\r\n     * @returns true if plane detection is enabled and supported. Will reject if not supported.\r\n     */\r\n    public async initiateRoomCapture(): Promise<void> {\r\n        if (this._xrSessionManager.session.initiateRoomCapture) {\r\n            return this._xrSessionManager.session.initiateRoomCapture();\r\n        }\r\n        return Promise.reject(\"initiateRoomCapture is not supported on this session\");\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !this._enabled || !frame) {\r\n            return;\r\n        }\r\n\r\n        const detectedPlanes = frame.detectedPlanes || frame.worldInformation?.detectedPlanes;\r\n        if (detectedPlanes) {\r\n            // remove all planes that are not currently detected in the frame\r\n            for (let planeIdx = 0; planeIdx < this._detectedPlanes.length; planeIdx++) {\r\n                const plane = this._detectedPlanes[planeIdx];\r\n                if (!detectedPlanes.has(plane.xrPlane)) {\r\n                    this._detectedPlanes.splice(planeIdx--, 1);\r\n                    this.onPlaneRemovedObservable.notifyObservers(plane);\r\n                }\r\n            }\r\n\r\n            // now check for new ones\r\n            detectedPlanes.forEach((xrPlane) => {\r\n                if (!this._lastFrameDetected.has(xrPlane)) {\r\n                    const newPlane: Partial<IWebXRPlane> = {\r\n                        id: planeIdProvider++,\r\n                        xrPlane: xrPlane,\r\n                        polygonDefinition: [],\r\n                    };\r\n                    const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\r\n                    this._detectedPlanes.push(plane);\r\n                    this.onPlaneAddedObservable.notifyObservers(plane);\r\n                } else {\r\n                    // updated?\r\n                    if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                        const index = this._findIndexInPlaneArray(xrPlane);\r\n                        const plane = this._detectedPlanes[index];\r\n                        this._updatePlaneWithXRPlane(xrPlane, plane, frame);\r\n                        this.onPlaneUpdatedObservable.notifyObservers(plane);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = detectedPlanes;\r\n        }\r\n    }\r\n\r\n    private _init() {\r\n        const internalInit = () => {\r\n            this._enabled = true;\r\n            if (this._detectedPlanes.length) {\r\n                this._detectedPlanes.length = 0;\r\n            }\r\n        };\r\n\r\n        // Only supported by BabylonNative\r\n        if (!!this._xrSessionManager.isNative && !!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions) {\r\n            this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions);\r\n        }\r\n\r\n        if (!this._xrSessionManager.session.updateWorldTrackingState) {\r\n            internalInit();\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });\r\n        internalInit();\r\n    }\r\n\r\n    private _updatePlaneWithXRPlane(xrPlane: XRPlane, plane: Partial<IWebXRPlane>, xrFrame: XRFrame): IWebXRPlane {\r\n        plane.polygonDefinition = xrPlane.polygon.map((xrPoint) => {\r\n            const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\r\n            return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\r\n        });\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = plane.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            plane.transformationMatrix = mat;\r\n            if (this._options.worldParentNode) {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRPlane>plane;\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrPlane the plane to find in the array\r\n     * @returns the index of the plane in the array or -1 if not found\r\n     */\r\n    private _findIndexInPlaneArray(xrPlane: XRPlane) {\r\n        for (let i = 0; i < this._detectedPlanes.length; ++i) {\r\n            if (this._detectedPlanes[i].xrPlane === xrPlane) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRPlaneDetector.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRPlaneDetector(xrSessionManager, options);\r\n    },\r\n    WebXRPlaneDetector.Version\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\n/**\r\n * Options interface for the background remover plugin\r\n */\r\nexport interface IWebXRBackgroundRemoverOptions {\r\n    /**\r\n     * Further background meshes to disable when entering AR\r\n     */\r\n    backgroundMeshes?: AbstractMesh[];\r\n    /**\r\n     * flags to configure the removal of the environment helper.\r\n     * If not set, the entire background will be removed. If set, flags should be set as well.\r\n     */\r\n    environmentHelperRemovalFlags?: {\r\n        /**\r\n         * Should the skybox be removed (default false)\r\n         */\r\n        skyBox?: boolean;\r\n        /**\r\n         * Should the ground be removed (default false)\r\n         */\r\n        ground?: boolean;\r\n    };\r\n    /**\r\n     * don't disable the environment helper\r\n     */\r\n    ignoreEnvironmentHelper?: boolean;\r\n}\r\n\r\n/**\r\n * A module that will automatically disable background meshes when entering AR and will enable them when leaving AR.\r\n */\r\nexport class WebXRBackgroundRemover extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.BACKGROUND_REMOVER;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * registered observers will be triggered when the background state changes\r\n     */\r\n    public onBackgroundStateChangedObservable: Observable<boolean> = new Observable();\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * read-only options to be used in this module\r\n         */\r\n        public readonly options: IWebXRBackgroundRemoverOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        this._setBackgroundState(false);\r\n        return super.attach();\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        this._setBackgroundState(true);\r\n        return super.detach();\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onBackgroundStateChangedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        // no-op\r\n    }\r\n\r\n    private _setBackgroundState(newState: boolean) {\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.options.ignoreEnvironmentHelper) {\r\n            if (this.options.environmentHelperRemovalFlags) {\r\n                if (this.options.environmentHelperRemovalFlags.skyBox) {\r\n                    const backgroundSkybox = scene.getMeshByName(\"BackgroundSkybox\");\r\n                    if (backgroundSkybox) {\r\n                        backgroundSkybox.setEnabled(newState);\r\n                    }\r\n                }\r\n                if (this.options.environmentHelperRemovalFlags.ground) {\r\n                    const backgroundPlane = scene.getMeshByName(\"BackgroundPlane\");\r\n                    if (backgroundPlane) {\r\n                        backgroundPlane.setEnabled(newState);\r\n                    }\r\n                }\r\n            } else {\r\n                const backgroundHelper = scene.getMeshByName(\"BackgroundHelper\");\r\n                if (backgroundHelper) {\r\n                    backgroundHelper.setEnabled(newState);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.options.backgroundMeshes) {\r\n            this.options.backgroundMeshes.forEach((mesh) => mesh.setEnabled(newState));\r\n        }\r\n\r\n        this.onBackgroundStateChangedObservable.notifyObservers(newState);\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRBackgroundRemover.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRBackgroundRemover(xrSessionManager, options);\r\n    },\r\n    WebXRBackgroundRemover.Version,\r\n    true\r\n);\r\n", "import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options for the controller physics feature\r\n */\r\nexport class IWebXRControllerPhysicsOptions {\r\n    /**\r\n     * Should the headset get its own impostor\r\n     */\r\n    enableHeadsetImpostor?: boolean;\r\n    /**\r\n     * Optional parameters for the headset impostor\r\n     */\r\n    headsetImpostorParams?: {\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * The physics properties of the future impostors\r\n     */\r\n    physicsProperties?: {\r\n        /**\r\n         * If set to true, a mesh impostor will be created when the controller mesh was loaded\r\n         * Note that this requires a physics engine that supports mesh impostors!\r\n         */\r\n        useControllerMesh?: boolean;\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType?: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    public xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\r\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\r\n            Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\r\n        }\r\n        // if no motion controller available, create impostors!\r\n        if (this._options.physicsProperties!.useControllerMesh && xrController.inputSource.gamepad) {\r\n            xrController.onMotionControllerInitObservable.addOnce((motionController) => {\r\n                if (!motionController._doNotLoadControllerMesh) {\r\n                    motionController.onModelLoadedObservable.addOnce(() => {\r\n                        const impostor = new PhysicsImpostor(motionController.rootMesh!, PhysicsImpostor.MeshImpostor, {\r\n                            mass: 0,\r\n                            ...this._options.physicsProperties,\r\n                        });\r\n\r\n                        const controllerMesh = xrController.grip || xrController.pointer;\r\n                        this._controllers[xrController.uniqueId] = {\r\n                            xrController,\r\n                            impostor,\r\n                            oldPos: controllerMesh.position.clone(),\r\n                            oldRotation: controllerMesh.rotationQuaternion!.clone(),\r\n                        };\r\n                    });\r\n                } else {\r\n                    // This controller isn't using a model, create impostors instead\r\n                    this._createPhysicsImpostor(xrController);\r\n                }\r\n            });\r\n        } else {\r\n            this._createPhysicsImpostor(xrController);\r\n        }\r\n    };\r\n\r\n    private _createPhysicsImpostor(xrController: WebXRInputSource) {\r\n        const impostorType: number = this._options.physicsProperties!.impostorType || PhysicsImpostor.SphereImpostor;\r\n        const impostorSize: number | { width: number; height: number; depth: number } = this._options.physicsProperties!.impostorSize || 0.1;\r\n        const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\r\n            diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n            diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n            diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n        });\r\n        impostorMesh.isVisible = this._debugMode;\r\n        impostorMesh.isPickable = false;\r\n        impostorMesh.rotationQuaternion = new Quaternion();\r\n        const controllerMesh = xrController.grip || xrController.pointer;\r\n        impostorMesh.position.copyFrom(controllerMesh.position);\r\n        impostorMesh.rotationQuaternion!.copyFrom(controllerMesh.rotationQuaternion!);\r\n        const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\r\n            mass: 0,\r\n            ...this._options.physicsProperties,\r\n        });\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            impostor,\r\n            impostorMesh,\r\n        };\r\n    }\r\n\r\n    private _controllers: {\r\n        [id: string]: {\r\n            xrController: WebXRInputSource;\r\n            impostorMesh?: AbstractMesh;\r\n            impostor: PhysicsImpostor;\r\n            oldPos?: Vector3;\r\n            oldSpeed?: Vector3;\r\n            oldRotation?: Quaternion;\r\n        };\r\n    } = {};\r\n    private _debugMode = false;\r\n    private _delta: number = 0;\r\n    private _headsetImpostor?: PhysicsImpostor;\r\n    private _headsetMesh?: AbstractMesh;\r\n    private _lastTimestamp: number = 0;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVector: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Construct a new Controller Physics Feature\r\n     * @param _xrSessionManager the corresponding xr session manager\r\n     * @param _options options to create this feature with\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRControllerPhysicsOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        if (!this._options.physicsProperties) {\r\n            this._options.physicsProperties = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * enable debugging - will show console outputs and the impostor mesh\r\n     */\r\n    public _enablePhysicsDebug() {\r\n        this._debugMode = true;\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            if (controllerData.impostorMesh) {\r\n                controllerData.impostorMesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n     * @param xrController the controller to add\r\n     */\r\n    public addController(xrController: WebXRInputSource) {\r\n        this._attachController(xrController);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.xrInput) {\r\n            return true;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        if (this._options.enableHeadsetImpostor) {\r\n            const params = this._options.headsetImpostorParams || {\r\n                impostorType: PhysicsImpostor.SphereImpostor,\r\n                restitution: 0.8,\r\n                impostorSize: 0.3,\r\n            };\r\n            const impostorSize = params.impostorSize || 0.3;\r\n            this._headsetMesh = CreateSphere(\"headset-mesh\", {\r\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n            });\r\n            this._headsetMesh.rotationQuaternion = new Quaternion();\r\n            this._headsetMesh.isVisible = false;\r\n            this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        if (this._headsetMesh) {\r\n            this._headsetMesh.dispose();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the headset impostor, if enabled\r\n     * @returns the impostor\r\n     */\r\n    public getHeadsetImpostor() {\r\n        return this._headsetImpostor;\r\n    }\r\n\r\n    /**\r\n     * Get the physics impostor of a specific controller.\r\n     * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n     * @param controller the controller or the controller id of which to get the impostor\r\n     * @returns the impostor or null\r\n     */\r\n    public getImpostorForController(controller: WebXRInputSource | string): Nullable<PhysicsImpostor> {\r\n        const id = typeof controller === \"string\" ? controller : controller.uniqueId;\r\n        if (this._controllers[id]) {\r\n            return this._controllers[id].impostor;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the physics properties provided in the constructor\r\n     * @param newProperties the new properties object\r\n     * @param newProperties.impostorType\r\n     * @param newProperties.impostorSize\r\n     * @param newProperties.friction\r\n     * @param newProperties.restitution\r\n     */\r\n    public setPhysicsProperties(newProperties: {\r\n        impostorType?: number;\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        friction?: number;\r\n        restitution?: number;\r\n    }) {\r\n        this._options.physicsProperties = {\r\n            ...this._options.physicsProperties,\r\n            ...newProperties,\r\n        };\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: any): void {\r\n        this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\r\n        this._lastTimestamp = this._xrSessionManager.currentTimestamp;\r\n        if (this._headsetMesh && this._headsetImpostor) {\r\n            this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\r\n            this._headsetMesh.rotationQuaternion!.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.linearVelocity) {\r\n                const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                this._headsetImpostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.angularVelocity) {\r\n                const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                this._headsetImpostor.setAngularVelocity(this._tmpVector);\r\n            }\r\n        }\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\r\n            const comparedPosition = controllerData.oldPos || controllerData.impostorMesh!.position;\r\n            if (controllerData.xrController._lastXRPose?.linearVelocity) {\r\n                const lv = controllerData.xrController._lastXRPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            } else {\r\n                controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(1000 / this._delta);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            comparedPosition.copyFrom(controllerMesh.position);\r\n            if (this._debugMode) {\r\n                Logger.Log([this._tmpVector, \"linear\"]);\r\n            }\r\n\r\n            const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh!.rotationQuaternion!;\r\n            if (controllerData.xrController._lastXRPose?.angularVelocity) {\r\n                const av = controllerData.xrController._lastXRPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n            } else {\r\n                if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion!)) {\r\n                    // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\r\n                    comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion!, this._tmpQuaternion);\r\n                    const len = Math.sqrt(\r\n                        this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z\r\n                    );\r\n                    this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\r\n                    // define a better epsilon\r\n                    if (len < 0.001) {\r\n                        this._tmpVector.scaleInPlace(2);\r\n                    } else {\r\n                        const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\r\n                        this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\r\n                    }\r\n                    controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n                }\r\n            }\r\n            comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion!);\r\n            if (this._debugMode) {\r\n                Logger.Log([this._tmpVector, this._tmpQuaternion, \"angular\"]);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.impostorMesh) {\r\n            controllerData.impostorMesh.dispose();\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPhysics.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPhysics(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPhysics.Version,\r\n    true\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRLegacyHitTestOptions, IWebXRLegacyHitResult, IWebXRHitTestFeature } from \"./WebXRHitTestLegacy\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options used for hit testing (version 2)\r\n */\r\nexport interface IWebXRHitTestOptions extends IWebXRLegacyHitTestOptions {\r\n    /**\r\n     * Do not create a permanent hit test. Will usually be used when only\r\n     * transient inputs are needed.\r\n     */\r\n    disablePermanentHitTest?: boolean;\r\n    /**\r\n     * Enable transient (for example touch-based) hit test inspections\r\n     */\r\n    enableTransientHitTest?: boolean;\r\n    /**\r\n     * Override the default transient hit test profile (generic-touchscreen).\r\n     */\r\n    transientHitTestProfile?: string;\r\n    /**\r\n     * Offset ray for the permanent hit test\r\n     */\r\n    offsetRay?: Vector3;\r\n    /**\r\n     * Offset ray for the transient hit test\r\n     */\r\n    transientOffsetRay?: Vector3;\r\n    /**\r\n     * Instead of using viewer space for hit tests, use the reference space defined in the session manager\r\n     */\r\n    useReferenceSpace?: boolean;\r\n\r\n    /**\r\n     * Override the default entity type(s) of the hit-test result\r\n     */\r\n    entityTypes?: XRHitTestTrackableType[];\r\n}\r\n\r\n/**\r\n * Interface defining the babylon result of hit-test\r\n */\r\nexport interface IWebXRHitResult extends IWebXRLegacyHitResult {\r\n    /**\r\n     * The input source that generated this hit test (if transient)\r\n     */\r\n    inputSource?: XRInputSource;\r\n    /**\r\n     * Is this a transient hit test\r\n     */\r\n    isTransient?: boolean;\r\n    /**\r\n     * Position of the hit test result\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * Rotation of the hit test result\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * The native hit test result\r\n     */\r\n    xrHitResult: XRHitTestResult;\r\n}\r\n\r\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n *\r\n * Tested on chrome (mobile) 80.\r\n */\r\nexport class WebXRHitTest extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRHitResult> {\r\n    private _tmpMat: Matrix = new Matrix();\r\n    private _tmpPos: Vector3 = new Vector3();\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _transientXrHitTestSource: Nullable<XRTransientInputHitTestSource>;\r\n    // in XR space z-forward is negative\r\n    private _xrHitTestSource: Nullable<XRHitTestSource>;\r\n    private _initHitTestSource = (referenceSpace: XRReferenceSpace) => {\r\n        if (!referenceSpace) {\r\n            return;\r\n        }\r\n        const offsetRay = new XRRay(this.options.offsetRay || {});\r\n        const hitTestOptions: XRHitTestOptionsInit = {\r\n            space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\r\n            offsetRay: offsetRay,\r\n        };\r\n        if (this.options.entityTypes) {\r\n            hitTestOptions.entityTypes = this.options.entityTypes;\r\n        }\r\n        if (!hitTestOptions.space) {\r\n            Tools.Warn(\"waiting for viewer reference space to initialize\");\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.requestHitTestSource!(hitTestOptions).then((hitTestSource) => {\r\n            if (this._xrHitTestSource) {\r\n                this._xrHitTestSource.cancel();\r\n            }\r\n            this._xrHitTestSource = hitTestSource;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HIT_TEST;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 2;\r\n\r\n    /**\r\n     * When set to true, each hit test will have its own position/rotation objects\r\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\r\n     * the developers will clone them or copy them as they see fit.\r\n     */\r\n    public autoCloneTransformation: boolean = false;\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     * Note - this will be called when results come back from the device. It can be an empty array!!\r\n     */\r\n    public onHitTestResultObservable: Observable<IWebXRHitResult[]> = new Observable();\r\n    /**\r\n     * Use this to temporarily pause hit test checks.\r\n     */\r\n    public paused: boolean = false;\r\n\r\n    /**\r\n     * Creates a new instance of the hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRHitTestOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hit-test\";\r\n        Tools.Warn(\"Hit test is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Feature enabled, but not available\r\n        if (!this._xrSessionManager.session.requestHitTestSource) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.options.disablePermanentHitTest) {\r\n            if (this._xrSessionManager.referenceSpace) {\r\n                this._initHitTestSource(this._xrSessionManager.referenceSpace);\r\n            }\r\n            this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\r\n        }\r\n        if (this.options.enableTransientHitTest) {\r\n            const offsetRay = new XRRay(this.options.transientOffsetRay || {});\r\n            this._xrSessionManager.session.requestHitTestSourceForTransientInput!({\r\n                profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\r\n                offsetRay,\r\n                entityTypes: this.options.entityTypes,\r\n            }).then((hitSource) => {\r\n                this._transientXrHitTestSource = hitSource;\r\n            });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        if (this._xrHitTestSource) {\r\n            this._xrHitTestSource.cancel();\r\n            this._xrHitTestSource = null;\r\n        }\r\n        this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\r\n        if (this._transientXrHitTestSource) {\r\n            this._transientXrHitTestSource.cancel();\r\n            this._transientXrHitTestSource = null;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHitTestResultObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // make sure we do nothing if (async) not attached\r\n        if (!this.attached || this.paused) {\r\n            return;\r\n        }\r\n\r\n        if (this._xrHitTestSource) {\r\n            const results = frame.getHitTestResults(this._xrHitTestSource);\r\n            this._processWebXRHitTestResult(results);\r\n        }\r\n        if (this._transientXrHitTestSource) {\r\n            const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\r\n\r\n            hitTestResultsPerInputSource.forEach((resultsPerInputSource) => {\r\n                this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _processWebXRHitTestResult(hitTestResults: readonly XRHitTestResult[], inputSource?: XRInputSource) {\r\n        const results: IWebXRHitResult[] = [];\r\n        hitTestResults.forEach((hitTestResult) => {\r\n            const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\r\n            if (!pose) {\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            const quat = pose.transform.orientation;\r\n            this._tmpPos.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n            this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\r\n            Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                this._tmpPos.z *= -1;\r\n                this._tmpQuat.z *= -1;\r\n                this._tmpQuat.w *= -1;\r\n                this._tmpMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            const result: IWebXRHitResult = {\r\n                position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\r\n                rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\r\n                transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\r\n                inputSource: inputSource,\r\n                isTransient: !!inputSource,\r\n                xrHitResult: hitTestResult,\r\n            };\r\n            results.push(result);\r\n        });\r\n\r\n        this.onHitTestResultObservable.notifyObservers(results);\r\n    }\r\n}\r\n\r\n//register the plugin versions\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHitTest.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHitTest(xrSessionManager, options);\r\n    },\r\n    WebXRHitTest.Version,\r\n    false\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\n/**\r\n * A babylon interface for a \"WebXR\" feature point.\r\n * Represents the position and confidence value of a given feature point.\r\n */\r\nexport interface IWebXRFeaturePoint {\r\n    /**\r\n     * Represents the position of the feature point in world space.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * Represents the confidence value of the feature point in world space. 0 being least confident, and 1 being most confident.\r\n     */\r\n    confidenceValue: number;\r\n}\r\n\r\n/**\r\n * The feature point system is used to detect feature points from real world geometry.\r\n * This feature is currently experimental and only supported on BabylonNative, and should not be used in the browser.\r\n * The newly introduced API can be seen in webxr.nativeextensions.d.ts and described in FeaturePoints.md.\r\n */\r\nexport class WebXRFeaturePointSystem extends WebXRAbstractFeature {\r\n    private _enabled: boolean = false;\r\n    private _featurePointCloud: Array<IWebXRFeaturePoint> = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.FEATURE_POINTS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n    /**\r\n     * Observers registered here will be executed whenever new feature points are added (on XRFrame while the session is tracking).\r\n     * Will notify the observers about which feature points have been added.\r\n     */\r\n    public readonly onFeaturePointsAddedObservable: Observable<number[]> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed whenever a feature point has been updated (on XRFrame while the session is tracking).\r\n     * Will notify the observers about which feature points have been updated.\r\n     */\r\n    public readonly onFeaturePointsUpdatedObservable: Observable<number[]> = new Observable();\r\n    /**\r\n     * The current feature point cloud maintained across frames.\r\n     */\r\n    public get featurePointCloud(): Array<IWebXRFeaturePoint> {\r\n        return this._featurePointCloud;\r\n    }\r\n\r\n    /**\r\n     * construct the feature point system\r\n     * @param _xrSessionManager an instance of xr Session manager\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"bjsfeature-points\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        this.featurePointCloud.length = 0;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._featurePointCloud.length = 0;\r\n        this.onFeaturePointsUpdatedObservable.clear();\r\n        this.onFeaturePointsAddedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * On receiving a new XR frame if this feature is attached notify observers new feature point data is available.\r\n     * @param frame\r\n     */\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !this._enabled || !frame) {\r\n            return;\r\n        }\r\n\r\n        const featurePointRawData: number[] | undefined = frame.featurePointCloud;\r\n        if (!featurePointRawData || featurePointRawData.length === 0) {\r\n            return;\r\n        } else {\r\n            if (featurePointRawData.length % 5 !== 0) {\r\n                throw new Error(\"Received malformed feature point cloud of length: \" + featurePointRawData.length);\r\n            }\r\n\r\n            const numberOfFeaturePoints: number = featurePointRawData.length / 5;\r\n            const updatedFeaturePoints = [];\r\n            const addedFeaturePoints = [];\r\n            for (let i = 0; i < numberOfFeaturePoints; i++) {\r\n                const rawIndex: number = i * 5;\r\n                const id = featurePointRawData[rawIndex + 4];\r\n\r\n                // IDs should be durable across frames and strictly increasing from 0 up, so use them as indexing into the feature point array.\r\n                if (!this._featurePointCloud[id]) {\r\n                    this._featurePointCloud[id] = { position: new Vector3(), confidenceValue: 0 };\r\n                    addedFeaturePoints.push(id);\r\n                } else {\r\n                    updatedFeaturePoints.push(id);\r\n                }\r\n\r\n                // Set the feature point values.\r\n                this._featurePointCloud[id].position.x = featurePointRawData[rawIndex];\r\n                this._featurePointCloud[id].position.y = featurePointRawData[rawIndex + 1];\r\n                this._featurePointCloud[id].position.z = featurePointRawData[rawIndex + 2];\r\n                this._featurePointCloud[id].confidenceValue = featurePointRawData[rawIndex + 3];\r\n            }\r\n\r\n            // Signal observers that feature points have been added if necessary.\r\n            if (addedFeaturePoints.length > 0) {\r\n                this.onFeaturePointsAddedObservable.notifyObservers(addedFeaturePoints);\r\n            }\r\n\r\n            // Signal observers that feature points have been updated if necessary.\r\n            if (updatedFeaturePoints.length > 0) {\r\n                this.onFeaturePointsUpdatedObservable.notifyObservers(updatedFeaturePoints);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the feature. If the feature point feature is not available for this environment do not mark the feature as enabled.\r\n     */\r\n    private _init() {\r\n        if (!this._xrSessionManager.session.trySetFeaturePointCloudEnabled || !this._xrSessionManager.session.trySetFeaturePointCloudEnabled(true)) {\r\n            // fail silently\r\n            return;\r\n        }\r\n\r\n        this._enabled = true;\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRFeaturePointSystem.Name,\r\n    (xrSessionManager) => {\r\n        return () => new WebXRFeaturePointSystem(xrSessionManager);\r\n    },\r\n    WebXRFeaturePointSystem.Version\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Matrix, Quaternion } from \"../../Maths/math\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Options used in the mesh detector module\r\n */\r\nexport interface IWebXRMeshDetectorOptions {\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * If set to true a reference of the created meshes will be kept until the next session starts\r\n     * If not defined, meshes will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveMeshesOnSessionEnded?: boolean;\r\n    /**\r\n     * Preferred detector configuration, not all preferred options will be supported by all platforms.\r\n     * Babylon native only!\r\n     */\r\n    preferredDetectorOptions?: XRGeometryDetectorOptions;\r\n    /**\r\n     * If set to true, WebXRMeshDetector will convert coordinate systems for meshes.\r\n     * If not defined, mesh conversions from right handed to left handed coordinate systems won't be conducted.\r\n     * Right handed mesh data will be available through IWebXRVertexData.xrMesh.\r\n     */\r\n    convertCoordinateSystems?: boolean;\r\n\r\n    /**\r\n     * If set to true, the feature will generate meshes for the detected data.\r\n     * Note that this might be time consuming, as the mesh's vertex data will be updated on every change.\r\n     * Setting this to true will also set convertCoordinateSystems to true.\r\n     * Note - the meshes will NOT be disposed automatically when the feature is detached or the session ended.\r\n     */\r\n    generateMeshes?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon interface for a XR mesh's vertex data.\r\n */\r\nexport interface IWebXRVertexData {\r\n    /**\r\n     * A babylon-assigned ID for this mesh\r\n     */\r\n    id: number;\r\n    /**\r\n     * Data required for constructing a mesh in Babylon.js.\r\n     */\r\n    xrMesh: XRMesh;\r\n    /**\r\n     * The node to use to transform the local results to world coordinates.\r\n     * WorldParentNode will only exist if it was declared in the IWebXRMeshDetectorOptions.\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * An array of vertex positions in babylon space. right/left hand system is taken into account.\r\n     * Positions will only be calculated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    positions?: Float32Array;\r\n    /**\r\n     * An array of indices in babylon space. Indices have a counterclockwise winding order.\r\n     * Indices will only be populated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    indices?: Uint32Array;\r\n    /**\r\n     * An array of vertex normals in babylon space. right/left hand system is taken into account.\r\n     * Normals will not be calculated if convertCoordinateSystems is undefined in the IWebXRMeshDetectorOptions.\r\n     * Different platforms may or may not support mesh normals when convertCoordinateSystems is set to true.\r\n     */\r\n    normals?: Float32Array;\r\n    /**\r\n     * A transformation matrix to apply on the mesh that will be built using the meshDefinition.\r\n     * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module.\r\n     * TransformationMatrix will only be calculated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    transformationMatrix?: Matrix;\r\n\r\n    /**\r\n     * If generateMeshes is set to true in the IWebXRMeshDetectorOptions, this will be the generated mesh.\r\n     * This mesh will be updated with the vertex data provided and not regenerated every time.\r\n     */\r\n    mesh?: Mesh;\r\n}\r\n\r\nlet meshIdProvider = 0;\r\n\r\n/**\r\n * The mesh detector is used to detect meshes in the real world when in AR\r\n */\r\nexport class WebXRMeshDetector extends WebXRAbstractFeature {\r\n    private _detectedMeshes: Map<XRMesh, IWebXRVertexData> = new Map<XRMesh, IWebXRVertexData>();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MESH_DETECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new mesh was added to the session\r\n     */\r\n    public onMeshAddedObservable: Observable<IWebXRVertexData> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when a mesh is no longer detected in the session\r\n     */\r\n    public onMeshRemovedObservable: Observable<IWebXRVertexData> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing mesh updates\r\n     */\r\n    public onMeshUpdatedObservable: Observable<IWebXRVertexData> = new Observable();\r\n\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: IWebXRMeshDetectorOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"mesh-detection\";\r\n        if (this._options.generateMeshes) {\r\n            this._options.convertCoordinateSystems = true;\r\n        }\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        // Only supported by BabylonNative\r\n        if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\r\n            this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\r\n        }\r\n\r\n        if (!this._options.doNotRemoveMeshesOnSessionEnded) {\r\n            this._detectedMeshes.forEach((mesh) => {\r\n                this.onMeshRemovedObservable.notifyObservers(mesh);\r\n            });\r\n\r\n            this._detectedMeshes.clear();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onMeshAddedObservable.clear();\r\n        this.onMeshRemovedObservable.clear();\r\n        this.onMeshUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // TODO remove try catch\r\n        try {\r\n            if (!this.attached || !frame) {\r\n                return;\r\n            }\r\n\r\n            // babylon native XR and webxr support\r\n            const detectedMeshes = frame.detectedMeshes || frame.worldInformation?.detectedMeshes;\r\n            if (detectedMeshes) {\r\n                const toRemove = new Set<XRMesh>();\r\n                this._detectedMeshes.forEach((vertexData, xrMesh) => {\r\n                    if (!detectedMeshes.has(xrMesh)) {\r\n                        toRemove.add(xrMesh);\r\n                    }\r\n                });\r\n                toRemove.forEach((xrMesh) => {\r\n                    const vertexData = this._detectedMeshes.get(xrMesh);\r\n                    if (vertexData) {\r\n                        this.onMeshRemovedObservable.notifyObservers(vertexData);\r\n                        this._detectedMeshes.delete(xrMesh);\r\n                    }\r\n                });\r\n\r\n                // now check for new ones\r\n                detectedMeshes.forEach((xrMesh) => {\r\n                    if (!this._detectedMeshes.has(xrMesh)) {\r\n                        const partialVertexData: Partial<IWebXRVertexData> = {\r\n                            id: meshIdProvider++,\r\n                            xrMesh: xrMesh,\r\n                        };\r\n                        const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\r\n                        this._detectedMeshes.set(xrMesh, vertexData);\r\n                        this.onMeshAddedObservable.notifyObservers(vertexData);\r\n                    } else {\r\n                        // updated?\r\n                        if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                            const vertexData = this._detectedMeshes.get(xrMesh);\r\n                            if (vertexData) {\r\n                                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\r\n                                this.onMeshUpdatedObservable.notifyObservers(vertexData);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        } catch (error) {\r\n            Logger.Log(error.stack);\r\n        }\r\n    }\r\n\r\n    private _init() {\r\n        // Only supported by BabylonNative\r\n        if (this._xrSessionManager.isNative) {\r\n            if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\r\n                this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\r\n            }\r\n\r\n            if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\r\n                this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateVertexDataWithXRMesh(xrMesh: XRMesh, mesh: Partial<IWebXRVertexData>, xrFrame: XRFrame): IWebXRVertexData {\r\n        mesh.xrMesh = xrMesh;\r\n        mesh.worldParentNode = this._options.worldParentNode;\r\n        const positions = xrMesh.vertices || xrMesh.positions;\r\n\r\n        if (this._options.convertCoordinateSystems) {\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mesh.positions = new Float32Array(positions.length);\r\n                for (let i = 0; i < positions.length; i += 3) {\r\n                    mesh.positions[i] = positions[i];\r\n                    mesh.positions[i + 1] = positions[i + 1];\r\n                    mesh.positions[i + 2] = -1 * positions[i + 2];\r\n                }\r\n\r\n                if (xrMesh.normals) {\r\n                    mesh.normals = new Float32Array(xrMesh.normals.length);\r\n                    for (let i = 0; i < xrMesh.normals.length; i += 3) {\r\n                        mesh.normals[i] = xrMesh.normals[i];\r\n                        mesh.normals[i + 1] = xrMesh.normals[i + 1];\r\n                        mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\r\n                    }\r\n                }\r\n            } else {\r\n                mesh.positions = positions;\r\n                mesh.normals = xrMesh.normals;\r\n            }\r\n\r\n            // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\r\n            mesh.indices = xrMesh.indices;\r\n\r\n            // matrix\r\n            const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\r\n            if (pose) {\r\n                const mat = mesh.transformationMatrix || new Matrix();\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                mesh.transformationMatrix = mat;\r\n                if (this._options.worldParentNode) {\r\n                    mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n                }\r\n            }\r\n\r\n            if (this._options.generateMeshes) {\r\n                if (!mesh.mesh) {\r\n                    const generatedMesh = new Mesh(\"xr mesh \" + mesh.id, this._xrSessionManager.scene);\r\n                    generatedMesh.rotationQuaternion = new Quaternion();\r\n                    generatedMesh.setVerticesData(VertexBuffer.PositionKind, mesh.positions);\r\n                    if (mesh.normals) {\r\n                        generatedMesh.setVerticesData(VertexBuffer.NormalKind, mesh.normals);\r\n                    } else {\r\n                        generatedMesh.createNormals(true);\r\n                    }\r\n                    generatedMesh.setIndices(mesh.indices, undefined, true);\r\n                    mesh.mesh = generatedMesh;\r\n                } else {\r\n                    const generatedMesh = mesh.mesh;\r\n                    generatedMesh.updateVerticesData(VertexBuffer.PositionKind, mesh.positions);\r\n                    if (mesh.normals) {\r\n                        generatedMesh.updateVerticesData(VertexBuffer.NormalKind, mesh.normals);\r\n                    } else {\r\n                        generatedMesh.createNormals(true);\r\n                    }\r\n                    generatedMesh.updateIndices(mesh.indices);\r\n                }\r\n                mesh.transformationMatrix?.decompose(mesh.mesh.scaling, mesh.mesh.rotationQuaternion!, mesh.mesh.position);\r\n            }\r\n        }\r\n\r\n        return <IWebXRVertexData>mesh;\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMeshDetector.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMeshDetector(xrSessionManager, options);\r\n    },\r\n    WebXRMeshDetector.Version,\r\n    false\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the background remover plugin\r\n */\r\nexport interface IWebXRImageTrackingOptions {\r\n    /**\r\n     * A required array with images to track\r\n     */\r\n    images: {\r\n        /**\r\n         * The source of the image. can be a URL or an image bitmap\r\n         */\r\n        src: string | ImageBitmap;\r\n        /**\r\n         * The estimated width in the real world (in meters)\r\n         */\r\n        estimatedRealWorldWidth: number; // In meters!\r\n    }[];\r\n}\r\n\r\n/**\r\n * An object representing an image tracked by the system\r\n */\r\nexport interface IWebXRTrackedImage {\r\n    /**\r\n     * The ID of this image (which is the same as the position in the array that was used to initialize the feature)\r\n     */\r\n    id: number;\r\n    /**\r\n     * Is the transformation provided emulated. If it is, the system \"guesses\" its real position. Otherwise it can be considered as exact position.\r\n     */\r\n    emulated?: boolean;\r\n    /**\r\n     * Just in case it is needed - the image bitmap that is being tracked\r\n     */\r\n    originalBitmap: ImageBitmap;\r\n    /**\r\n     * The native XR result image tracking result, untouched\r\n     */\r\n    xrTrackingResult?: XRImageTrackingResult;\r\n    /**\r\n     * Width in real world (meters)\r\n     */\r\n    realWorldWidth?: number;\r\n    /**\r\n     * A transformation matrix of this current image in the current reference space.\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The width/height ratio of this image. can be used to calculate the size of the detected object/image\r\n     */\r\n    ratio?: number;\r\n}\r\n\r\n/**\r\n * Enum that describes the state of the image trackability score status for this session.\r\n */\r\nenum ImageTrackingScoreStatus {\r\n    // AR Session has not yet assessed image trackability scores.\r\n    NotReceived,\r\n    // A request to retrieve trackability scores has been sent, but no response has been received.\r\n    Waiting,\r\n    // Image trackability scores have been received for this session\r\n    Received,\r\n}\r\n\r\n/**\r\n * Image tracking for immersive AR sessions.\r\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\r\n */\r\nexport class WebXRImageTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.IMAGE_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This will be triggered if the underlying system deems an image untrackable.\r\n     * The index is the index of the image from the array used to initialize the feature.\r\n     */\r\n    public onUntrackableImageFoundObservable: Observable<number> = new Observable();\r\n    /**\r\n     * An image was deemed trackable, and the system will start tracking it.\r\n     */\r\n    public onTrackableImageFoundObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n    /**\r\n     * The image was found and its state was updated.\r\n     */\r\n    public onTrackedImageUpdatedObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n\r\n    private _trackableScoreStatus: ImageTrackingScoreStatus = ImageTrackingScoreStatus.NotReceived;\r\n    private _trackedImages: IWebXRTrackedImage[] = [];\r\n\r\n    private _originalTrackingRequest: XRTrackedImageInit[];\r\n\r\n    /**\r\n     * constructs the image tracking feature\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * read-only options to be used in this module\r\n         */\r\n        public readonly options: IWebXRImageTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"image-tracking\";\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        return super.attach();\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        return super.detach();\r\n    }\r\n\r\n    /**\r\n     * Get a tracked image by its ID.\r\n     *\r\n     * @param id the id of the image to load (position in the init array)\r\n     * @returns a trackable image, if exists in this location\r\n     */\r\n    public getTrackedImageById(id: number): Nullable<IWebXRTrackedImage> {\r\n        return this._trackedImages[id] || null;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._trackedImages.forEach((trackedImage) => {\r\n            trackedImage.originalBitmap.close();\r\n        });\r\n        this._trackedImages.length = 0;\r\n        this.onTrackableImageFoundObservable.clear();\r\n        this.onUntrackableImageFoundObservable.clear();\r\n        this.onTrackedImageUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object fo the xr session init object.\r\n     */\r\n    public async getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        if (!this.options.images || !this.options.images.length) {\r\n            return {};\r\n        }\r\n        const promises = this.options.images.map((image) => {\r\n            if (typeof image.src === \"string\") {\r\n                return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\r\n            } else {\r\n                return Promise.resolve(image.src); // resolve is probably unneeded\r\n            }\r\n        });\r\n\r\n        try {\r\n            const images = await Promise.all(promises);\r\n\r\n            this._originalTrackingRequest = images.map((image, idx) => {\r\n                return {\r\n                    image,\r\n                    widthInMeters: this.options.images[idx].estimatedRealWorldWidth,\r\n                };\r\n            });\r\n\r\n            return {\r\n                trackedImages: this._originalTrackingRequest,\r\n            };\r\n        } catch (ex) {\r\n            Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\r\n            return {};\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\r\n            return;\r\n        }\r\n\r\n        // Image tracking scores may be generated a few frames after the XR Session initializes.\r\n        // If we haven't received scores yet, then kick off the task to check scores and return immediately.\r\n        if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\r\n            this._checkScoresAsync();\r\n            return;\r\n        }\r\n\r\n        const imageTrackedResults = _xrFrame.getImageTrackingResults();\r\n        for (const result of imageTrackedResults) {\r\n            let changed = false;\r\n            const imageIndex = result.index;\r\n\r\n            const imageObject = this._trackedImages[imageIndex];\r\n            if (!imageObject) {\r\n                // something went wrong!\r\n                continue;\r\n            }\r\n\r\n            imageObject.xrTrackingResult = result;\r\n            if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\r\n                imageObject.realWorldWidth = result.measuredWidthInMeters;\r\n                changed = true;\r\n            }\r\n\r\n            // Get the pose of the image relative to a reference space.\r\n            const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\r\n\r\n            if (pose) {\r\n                const mat = imageObject.transformationMatrix;\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                changed = true;\r\n            }\r\n\r\n            const state = result.trackingState;\r\n            const emulated = state === \"emulated\";\r\n\r\n            if (imageObject.emulated !== emulated) {\r\n                imageObject.emulated = emulated;\r\n                changed = true;\r\n            }\r\n            if (changed) {\r\n                this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _checkScoresAsync(): Promise<void> {\r\n        if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\r\n            return;\r\n        }\r\n\r\n        this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\r\n        const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\r\n        if (!imageScores || imageScores.length === 0) {\r\n            this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\r\n            return;\r\n        }\r\n\r\n        // check the scores for all\r\n        for (let idx = 0; idx < imageScores.length; ++idx) {\r\n            if (imageScores[idx] == \"untrackable\") {\r\n                this.onUntrackableImageFoundObservable.notifyObservers(idx);\r\n            } else {\r\n                const originalBitmap = this._originalTrackingRequest[idx].image;\r\n                const imageObject: IWebXRTrackedImage = {\r\n                    id: idx,\r\n                    originalBitmap,\r\n                    transformationMatrix: new Matrix(),\r\n                    ratio: originalBitmap.width / originalBitmap.height,\r\n                };\r\n                this._trackedImages[idx] = imageObject;\r\n                this.onTrackableImageFoundObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n\r\n        this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRImageTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRImageTracking(xrSessionManager, options);\r\n    },\r\n    WebXRImageTracking.Version,\r\n    false\r\n);\r\n", "import { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\n/**\r\n * Options for DOM Overlay feature\r\n */\r\nexport interface IWebXRDomOverlayOptions {\r\n    /**\r\n     * DOM Element or document query selector string for overlay.\r\n     *\r\n     * NOTE: UA may make this element background transparent in XR.\r\n     */\r\n    element: Element | string;\r\n    /**\r\n     * Supress XR Select events on container element (DOM blocks interaction to scene).\r\n     */\r\n    supressXRSelectEvents?: boolean;\r\n}\r\n\r\n/**\r\n * Type of DOM overlay provided by UA.\r\n */\r\ntype WebXRDomOverlayType =\r\n    /**\r\n     * Covers the entire physical screen for a screen-based device, for example handheld AR\r\n     */\r\n    | \"screen\"\r\n    /**\r\n     * Appears as a floating rectangle in space\r\n     */\r\n    | \"floating\"\r\n    /**\r\n     * Follows the user’s head movement consistently, appearing similar to a HUD\r\n     */\r\n    | \"head-locked\";\r\n\r\n/**\r\n * DOM Overlay Feature\r\n *\r\n * @since 5.0.0\r\n */\r\nexport class WebXRDomOverlay extends WebXRAbstractFeature {\r\n    /**\r\n     * Type of overlay - non-null when available\r\n     */\r\n    private _domOverlayType: Nullable<WebXRDomOverlayType> = null;\r\n\r\n    /**\r\n     * Event Listener to supress \"beforexrselect\" events.\r\n     */\r\n    private _beforeXRSelectListener: Nullable<EventListenerOrEventListenerObject> = null;\r\n\r\n    /**\r\n     * Element used for overlay\r\n     */\r\n    private _element: Nullable<Element> = null;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.DOM_OVERLAY;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Creates a new instance of the dom-overlay feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRDomOverlayOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"dom-overlay\";\r\n\r\n        // https://immersive-web.github.io/dom-overlays/\r\n        Tools.Warn(\"dom-overlay is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Feature not available\r\n        if (!this._xrSessionManager.session.domOverlayState || this._xrSessionManager.session.domOverlayState.type === null) {\r\n            return false;\r\n        }\r\n\r\n        this._domOverlayType = this._xrSessionManager.session.domOverlayState.type;\r\n\r\n        if (this._element !== null && this.options.supressXRSelectEvents === true) {\r\n            this._beforeXRSelectListener = (ev) => {\r\n                ev.preventDefault();\r\n            };\r\n            this._element.addEventListener(\"beforexrselect\", this._beforeXRSelectListener);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The type of DOM overlay (null when not supported).  Provided by UA and remains unchanged for duration of session.\r\n     */\r\n    public get domOverlayType(): Nullable<WebXRDomOverlayType> {\r\n        return this._domOverlayType;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        if (this._element !== null && this._beforeXRSelectListener) {\r\n            this._element.removeEventListener(\"beforexrselect\", this._beforeXRSelectListener);\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        /* empty */\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object for the xr session init object.\r\n     */\r\n    public async getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        if (this.options.element === undefined) {\r\n            Tools.Warn('\"element\" option must be provided to attach xr-dom-overlay feature.');\r\n            return {};\r\n        } else if (typeof this.options.element === \"string\") {\r\n            const selectedElement = document.querySelector(this.options.element);\r\n            if (selectedElement === null) {\r\n                Tools.Warn(`element not found '${this.options.element}' (not requesting xr-dom-overlay)`);\r\n                return {};\r\n            }\r\n            this._element = selectedElement;\r\n        } else {\r\n            this._element = this.options.element;\r\n        }\r\n\r\n        return {\r\n            domOverlay: {\r\n                root: this._element,\r\n            },\r\n        };\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRDomOverlay.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRDomOverlay(xrSessionManager, options);\r\n    },\r\n    WebXRDomOverlay.Version,\r\n    false\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue, IWebXRMotionControllerComponentChangesValues } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { MotionControllerComponentType } from \"../motionController/webXRAbstractMotionController\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * The options container for the controller movement module\r\n */\r\nexport interface IWebXRControllerMovementOptions {\r\n    /**\r\n     * Override default behaviour and provide your own movement controls\r\n     */\r\n    customRegistrationConfigurations?: WebXRControllerMovementRegistrationConfiguration[];\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    movementEnabled?: boolean;\r\n    /**\r\n     * Camera direction follows view pose and movement by default will move independently of the viewer's pose.\r\n     */\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    movementSpeed?: number;\r\n    /**\r\n     * Minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    movementThreshold?: number;\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    rotationEnabled?: boolean;\r\n    /**\r\n     * Minimum threshold the controller's thumstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    rotationThreshold?: number;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    rotationSpeed?: number;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Feature context is used in handlers and on each XR frame to control the camera movement/direction.\r\n */\r\nexport type WebXRControllerMovementFeatureContext = {\r\n    movementEnabled: boolean;\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    movementSpeed: number;\r\n    movementThreshold: number;\r\n    rotationEnabled: boolean;\r\n    rotationSpeed: number;\r\n    rotationThreshold: number;\r\n};\r\n\r\n/**\r\n * Current state of Movements shared across components and handlers.\r\n */\r\nexport type WebXRControllerMovementState = {\r\n    moveX: number;\r\n    moveY: number;\r\n    rotateX: number;\r\n    rotateY: number;\r\n};\r\n\r\n/**\r\n * Button of Axis Handler must be specified.\r\n */\r\nexport type WebXRControllerMovementRegistrationConfiguration = {\r\n    /**\r\n     * handlers are filtered to these types only\r\n     */\r\n    allowedComponentTypes?: MotionControllerComponentType[];\r\n    /**\r\n     * For registering movement to specific hand only.  Useful if your app has a \"main hand\" and \"off hand\" for determining the functionality of a controller.\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n    /**\r\n     * For main component only (useful for buttons and may not trigger axis changes).\r\n     */\r\n    mainComponentOnly?: boolean;\r\n    /**\r\n     * Additional predicate to apply to controllers to restrict a handler being added.\r\n     */\r\n    componentSelectionPredicate?: (xrController: WebXRInputSource) => Nullable<WebXRControllerComponent>;\r\n} & (\r\n    | {\r\n          /**\r\n           * Called when axis changes occur.\r\n           */\r\n          axisChangedHandler: (\r\n              axes: IWebXRMotionControllerAxesValue,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n    | {\r\n          /**\r\n           * Called when the button state changes.\r\n           */\r\n          buttonChangedhandler: (\r\n              pressed: IWebXRMotionControllerComponentChangesValues<boolean>,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n);\r\n\r\ntype RegisteredComponent = {\r\n    registrationConfiguration: WebXRControllerMovementRegistrationConfiguration;\r\n    component: WebXRControllerComponent;\r\n    onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n};\r\n\r\n/**\r\n * This is a movement feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            registeredComponents: RegisteredComponent[];\r\n        };\r\n    } = {};\r\n\r\n    private _currentRegistrationConfigurations: WebXRControllerMovementRegistrationConfiguration[] = [];\r\n    // Feature configuration is syncronized - this is passed to all handlers (reduce GC pressure).\r\n    private _featureContext: WebXRControllerMovementFeatureContext;\r\n    // forward direction for movement, which may differ from viewer pose.\r\n    private _movementDirection: Quaternion = new Quaternion();\r\n    private _movementState: WebXRControllerMovementState;\r\n    private _xrInput: WebXRInput;\r\n\r\n    // unused\r\n    private _tmpRotationMatrix: Matrix = Matrix.Identity();\r\n    private _tmpTranslationDirection: Vector3 = new Vector3();\r\n    private _tmpMovementTranslation: Vector3 = new Vector3();\r\n    private _tempCacheQuaternion: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MOVEMENT;\r\n\r\n    /**\r\n     * Standard controller configurations.\r\n     */\r\n    public static readonly REGISTRATIONS: { [key: string]: WebXRControllerMovementRegistrationConfiguration[] } = {\r\n        default: [\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"left\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\r\n                    movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"right\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\r\n                    movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n        ],\r\n    };\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Current movement direction.  Will be null before XR Frames have been processed.\r\n     */\r\n    public get movementDirection(): Quaternion {\r\n        return this._movementDirection;\r\n    }\r\n\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    public get movementEnabled(): boolean {\r\n        return this._featureContext.movementEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement is enabled or not\r\n     * @param enabled is movement enabled\r\n     */\r\n    public set movementEnabled(enabled: boolean) {\r\n        this._featureContext.movementEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * If movement follows viewer pose\r\n     */\r\n    public get movementOrientationFollowsViewerPose(): boolean {\r\n        return this._featureContext.movementOrientationFollowsViewerPose;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement follows viewer pose\r\n     * @param followsPose is movement should follow viewer pose\r\n     */\r\n    public set movementOrientationFollowsViewerPose(followsPose: boolean) {\r\n        this._featureContext.movementOrientationFollowsViewerPose = followsPose;\r\n    }\r\n\r\n    /**\r\n     * Gets movement speed\r\n     */\r\n    public get movementSpeed(): number {\r\n        return this._featureContext.movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets movement speed\r\n     * @param movementSpeed movement speed\r\n     */\r\n    public set movementSpeed(movementSpeed: number) {\r\n        this._featureContext.movementSpeed = movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    public get movementThreshold(): number {\r\n        return this._featureContext.movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     * @param movementThreshold new threshold\r\n     */\r\n    public set movementThreshold(movementThreshold: number) {\r\n        this._featureContext.movementThreshold = movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._featureContext.rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._featureContext.rotationEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * Gets rotation speed factor\r\n     */\r\n    public get rotationSpeed(): number {\r\n        return this._featureContext.rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets rotation speed factor (1.0 is default)\r\n     * @param rotationSpeed new rotation speed factor\r\n     */\r\n    public set rotationSpeed(rotationSpeed: number) {\r\n        this._featureContext.rotationSpeed = rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    public get rotationThreshold(): number {\r\n        return this._featureContext.rotationThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     * @param threshold new threshold\r\n     */\r\n    public set rotationThreshold(threshold: number) {\r\n        this._featureContext.rotationThreshold = threshold;\r\n    }\r\n    /**\r\n     * constructs a new movement controller system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, options: IWebXRControllerMovementOptions) {\r\n        super(_xrSessionManager);\r\n\r\n        if (!options || options.xrInput === undefined) {\r\n            Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(options.customRegistrationConfigurations)) {\r\n            this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\r\n        } else {\r\n            this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\r\n        }\r\n\r\n        // synchronized from feature setter properties\r\n        this._featureContext = {\r\n            movementEnabled: options.movementEnabled || true,\r\n            movementOrientationFollowsViewerPose: options.movementOrientationFollowsViewerPose ?? true,\r\n            movementSpeed: options.movementSpeed ?? 1,\r\n            movementThreshold: options.movementThreshold ?? 0.25,\r\n            rotationEnabled: options.rotationEnabled ?? true,\r\n            rotationSpeed: options.rotationSpeed ?? 1.0,\r\n            rotationThreshold: options.rotationThreshold ?? 0.25,\r\n        };\r\n\r\n        this._movementState = {\r\n            moveX: 0,\r\n            moveY: 0,\r\n            rotateX: 0,\r\n            rotateY: 0,\r\n        };\r\n\r\n        this._xrInput = options.xrInput;\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, (controller: WebXRInputSource) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Occurs on every XR frame.\r\n     * @param _xrFrame\r\n     */\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!this.attached) {\r\n            return;\r\n        }\r\n\r\n        if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\r\n            // smooth rotation\r\n            const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\r\n            const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n\r\n            if (this._featureContext.movementOrientationFollowsViewerPose) {\r\n                this._xrInput.xrCamera.cameraRotation.y += rotationY;\r\n                Quaternion.RotationYawPitchRollToRef(rotationY, 0, 0, this._tempCacheQuaternion);\r\n                this._xrInput.xrCamera.rotationQuaternion.multiplyToRef(this._tempCacheQuaternion, this._movementDirection);\r\n            } else {\r\n                // movement orientation direction does not affect camera.  We use rotation speed multiplier\r\n                // otherwise need to implement inertia and constraints for same feel as TargetCamera.\r\n\r\n                Quaternion.RotationYawPitchRollToRef(rotationY * 3.0, 0, 0, this._tempCacheQuaternion);\r\n                this._movementDirection.multiplyInPlace(this._tempCacheQuaternion);\r\n            }\r\n        } else if (this._featureContext.movementOrientationFollowsViewerPose) {\r\n            this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\r\n        }\r\n\r\n        if ((this._movementState.moveX || this._movementState.moveY) && this._featureContext.movementEnabled) {\r\n            Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\r\n            this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n            // move according to forward direction based on camera speed\r\n            Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\r\n            this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\r\n\r\n            this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            registeredComponents: [],\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n\r\n        // movement controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initController = () => {\r\n                if (xrController.motionController) {\r\n                    for (const registration of this._currentRegistrationConfigurations) {\r\n                        let component: Nullable<WebXRControllerComponent> = null;\r\n\r\n                        if (registration.allowedComponentTypes) {\r\n                            for (const componentType of registration.allowedComponentTypes) {\r\n                                const componentOfType = xrController.motionController.getComponentOfType(componentType);\r\n                                if (componentOfType !== null) {\r\n                                    component = componentOfType;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (registration.mainComponentOnly) {\r\n                            const mainComponent = xrController.motionController.getMainComponent();\r\n                            if (mainComponent === null) {\r\n                                continue;\r\n                            }\r\n                            component = mainComponent;\r\n                        }\r\n\r\n                        if (typeof registration.componentSelectionPredicate === \"function\") {\r\n                            // if does not match we do want to ignore a previously found component\r\n                            component = registration.componentSelectionPredicate(xrController);\r\n                        }\r\n\r\n                        if (component && registration.forceHandedness) {\r\n                            if (xrController.inputSource.handedness !== registration.forceHandedness) {\r\n                                continue; // do not register\r\n                            }\r\n                        }\r\n\r\n                        if (component === null) {\r\n                            continue; // do not register\r\n                        }\r\n\r\n                        const registeredComponent: RegisteredComponent = {\r\n                            registrationConfiguration: registration,\r\n                            component,\r\n                        };\r\n                        controllerData.registeredComponents.push(registeredComponent);\r\n\r\n                        if (\"axisChangedHandler\" in registration) {\r\n                            registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add((axesData) => {\r\n                                registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\r\n                            });\r\n                        }\r\n\r\n                        if (\"buttonChangedhandler\" in registration) {\r\n                            registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\r\n                                if (component!.changes.pressed) {\r\n                                    registration.buttonChangedhandler(component!.changes.pressed, this._movementState, this._featureContext, this._xrInput);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (xrController.motionController) {\r\n                initController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initController();\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n\r\n        for (const registeredComponent of controllerData.registeredComponents) {\r\n            if (registeredComponent.onAxisChangedObserver) {\r\n                registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\r\n            }\r\n            if (registeredComponent.onButtonChangedObserver) {\r\n                registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\r\n            }\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerMovement.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerMovement(xrSessionManager, options);\r\n    },\r\n    WebXRControllerMovement.Version,\r\n    true\r\n);\r\n", "import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { Nullable } from \"core/types\";\r\n/**\r\n * Interface describing all the common properties and methods a shadow light needs to implement.\r\n * This helps both the shadow generator and materials to generate the corresponding shadow maps\r\n * as well as binding the different shadow properties to the effects.\r\n */\r\nexport interface IShadowLight extends Light {\r\n    /**\r\n     * The light id in the scene (used in scene.getLightById for instance)\r\n     */\r\n    id: string;\r\n    /**\r\n     * The position the shadow will be casted from.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * In 2d mode (needCube being false), the direction used to cast the shadow.\r\n     */\r\n    direction: Vector3;\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account.\r\n     */\r\n    transformedPosition: Vector3;\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    transformedDirection: Vector3;\r\n    /**\r\n     * The friendly name of the light in the scene.\r\n     */\r\n    name: string;\r\n    /**\r\n     * Defines the shadow projection clipping minimum z value.\r\n     */\r\n    shadowMinZ: number;\r\n    /**\r\n     * Defines the shadow projection clipping maximum z value.\r\n     */\r\n    shadowMaxZ: number;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    computeTransformedInformation(): boolean;\r\n\r\n    /**\r\n     * Gets the scene the light belongs to.\r\n     * @returns The scene\r\n     */\r\n    getScene(): Scene;\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to update with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;\r\n\r\n    /**\r\n     * Gets the current depth scale used in ESM.\r\n     * @returns The scale\r\n     */\r\n    getDepthScale(): number;\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    needCube(): boolean;\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    needProjectionMatrixCompute(): boolean;\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    forceProjectionMatrixCompute(): void;\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    getShadowDirection(faceIndex?: number): Vector3;\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    getDepthMinZ(activeCamera: Camera): number;\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    getDepthMaxZ(activeCamera: Camera): number;\r\n}\r\n\r\n/**\r\n * Base implementation IShadowLight\r\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\r\n */\r\nexport abstract class ShadowLight extends Light implements IShadowLight {\r\n    protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;\r\n\r\n    protected _position: Vector3;\r\n    protected _setPosition(value: Vector3) {\r\n        this._position = value;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._setPosition(value);\r\n    }\r\n\r\n    protected _direction: Vector3;\r\n    protected _setDirection(value: Vector3) {\r\n        this._direction = value;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    public set direction(value: Vector3) {\r\n        this._setDirection(value);\r\n    }\r\n\r\n    protected _shadowMinZ: number;\r\n    /**\r\n     * Gets the shadow projection clipping minimum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMinZ(): number {\r\n        return this._shadowMinZ;\r\n    }\r\n    /**\r\n     * Sets the shadow projection clipping minimum z value.\r\n     */\r\n    public set shadowMinZ(value: number) {\r\n        this._shadowMinZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    protected _shadowMaxZ: number;\r\n    /**\r\n     * Sets the shadow projection clipping maximum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMaxZ(): number {\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Gets the shadow projection clipping maximum z value.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        this._shadowMaxZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    public customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account. Needs to be computed by calling computeTransformedInformation.\r\n     */\r\n    public transformedPosition: Vector3;\r\n\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    public transformedDirection: Vector3;\r\n\r\n    private _needProjectionMatrixCompute: boolean = true;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    public computeTransformedInformation(): boolean {\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            if (!this.transformedPosition) {\r\n                this.transformedPosition = Vector3.Zero();\r\n            }\r\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\r\n\r\n            // In case the direction is present.\r\n            if (this.direction) {\r\n                if (!this.transformedDirection) {\r\n                    this.transformedDirection = Vector3.Zero();\r\n                }\r\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return the depth scale used for the shadow map.\r\n     * @returns the depth scale.\r\n     */\r\n    public getDepthScale(): number {\r\n        return 50.0;\r\n    }\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getShadowDirection(faceIndex?: number): Vector3 {\r\n        return this.transformedDirection ? this.transformedDirection : this.direction;\r\n    }\r\n\r\n    /**\r\n     * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.\r\n     * @returns the position vector in world space\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return this.transformedPosition ? this.transformedPosition : this.position;\r\n    }\r\n\r\n    /**\r\n     * Sets the ShadowLight direction toward the passed target.\r\n     * @param target The point to target in local space\r\n     * @returns the updated ShadowLight direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(this.position));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the light rotation in euler definition.\r\n     * @returns the x y z rotation in local space.\r\n     */\r\n    public getRotation(): Vector3 {\r\n        this.direction.normalize();\r\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\r\n        const yaxis = Vector3.Cross(xaxis, this.direction);\r\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    public needCube(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    public needProjectionMatrixCompute(): boolean {\r\n        return this._needProjectionMatrixCompute;\r\n    }\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    public forceProjectionMatrixCompute(): void {\r\n        this._needProjectionMatrixCompute = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = Vector3.Zero();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronized(): boolean {\r\n        if (!this._cache.position.equals(this.position)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(force?: boolean): Matrix {\r\n        if (!force && this.isSynchronized()) {\r\n            this._currentRenderId = this.getScene().getRenderId();\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        this._updateCache();\r\n        this._cache.position.copyFrom(this.position);\r\n\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\r\n\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\r\n\r\n            this._markSyncedWithParent();\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n    }\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to updated with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    public setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight {\r\n        if (this.customProjectionMatrixBuilder) {\r\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\r\n        } else {\r\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.parent || !this.parent.getWorldMatrix) {\r\n            (this.transformedPosition as any) = null;\r\n            (this.transformedDirection as any) = null;\r\n        }\r\n    }\r\n\r\n    protected _viewMatrix: Matrix = Matrix.Identity();\r\n    protected _projectionMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(faceIndex?: number): Nullable<Matrix> {\r\n        const lightDirection = TmpVectors.Vector3[0];\r\n\r\n        let lightPosition = this.position;\r\n        if (this.computeTransformedInformation()) {\r\n            lightPosition = this.transformedPosition;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);\r\n        if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1.0) {\r\n            lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        const lightTarget = TmpVectors.Vector3[1];\r\n        lightPosition.addToRef(lightDirection, lightTarget);\r\n\r\n        Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);\r\n\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param viewMatrix The view transform matrix of the light (optional).\r\n     * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(viewMatrix?: Matrix, renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    @serialize(\"orthoLeft\")\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    @serialize(\"orthoRight\")\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    @serialize(\"orthoTop\")\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    @serialize(\"orthoBottom\")\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets the orthoLeft property used to build the light frustum\r\n     */\r\n    public get orthoLeft(): number {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    public set orthoLeft(left: number) {\r\n        this._orthoLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoRight property used to build the light frustum\r\n     */\r\n    public get orthoRight(): number {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    public set orthoRight(right: number) {\r\n        this._orthoRight = right;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoTop property used to build the light frustum\r\n     */\r\n    public get orthoTop(): number {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    public set orthoTop(top: number) {\r\n        this._orthoTop = top;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoBottom property used to build the light frustum\r\n     */\r\n    public get orthoBottom(): number {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    public set orthoBottom(bottom: number) {\r\n        this._orthoBottom = bottom;\r\n    }\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        } else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(\r\n            this.shadowFrustumSize,\r\n            this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ,\r\n            this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            const tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = -Number.MAX_VALUE;\r\n            this._orthoTop = -Number.MAX_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            let shadowMinZ = Number.MAX_VALUE;\r\n            let shadowMaxZ = -Number.MAX_VALUE;\r\n\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                const boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        const xOffset = this._orthoRight - this._orthoLeft;\r\n        const yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(\r\n            this._orthoLeft - xOffset * this.shadowOrthoScale,\r\n            this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale,\r\n            this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { TmpVectors } from \"./math\";\r\n\r\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\r\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\r\n// https://www.ppsloan.org/publications/StupidSH36.pdf\r\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\r\n// https://www.ppsloan.org/publications/SHJCGT.pdf\r\n// https://www.ppsloan.org/publications/shdering.pdf\r\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\r\n// https://patapom.com/blog/SHPortal/\r\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\r\n\r\n// Using real SH basis:\r\n//  m>0             m   m\r\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m<0             m   |m|\r\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m=0   0   0\r\n// y   = K * P * trigono terms\r\n//  l     l   l\r\n//\r\n//  m       (2l + 1)(l - |m|)!\r\n// K = sqrt(------------------)\r\n//  l           4pi(l + |m|)!\r\n//\r\n// and P by recursion:\r\n//\r\n// P00(x) = 1\r\n// P01(x) = x\r\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\r\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\r\n// Plm(x) = ---------------------------------------\r\n//                         l - m\r\n// Leaving the trigonometric terms aside we can precompute the constants to :\r\nconst SH3ylmBasisConstants = [\r\n    Math.sqrt(1 / (4 * Math.PI)), // l00\r\n\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l1_1\r\n    Math.sqrt(3 / (4 * Math.PI)), // l10\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l11\r\n\r\n    Math.sqrt(15 / (4 * Math.PI)), // l2_2\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l2_1\r\n    Math.sqrt(5 / (16 * Math.PI)), // l20\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l21\r\n    Math.sqrt(15 / (16 * Math.PI)), // l22\r\n];\r\n\r\n// cm = cos(m * phi)\r\n// sm = sin(m * phi)\r\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\r\n// By recursion on using trigo identities:\r\nconst SH3ylmBasisTrigonometricTerms = [\r\n    () => 1, // l00\r\n\r\n    (direction: Vector3) => direction.y, // l1_1\r\n    (direction: Vector3) => direction.z, // l10\r\n    (direction: Vector3) => direction.x, // l11\r\n\r\n    (direction: Vector3) => direction.x * direction.y, // l2_2\r\n    (direction: Vector3) => direction.y * direction.z, // l2_1\r\n    (direction: Vector3) => 3 * direction.z * direction.z - 1, // l20\r\n    (direction: Vector3) => direction.x * direction.z, // l21\r\n    (direction: Vector3) => direction.x * direction.x - direction.y * direction.y, // l22\r\n];\r\n\r\n// Wrap the full compute\r\nconst applySH3 = (lm: number, direction: Vector3) => {\r\n    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\r\n};\r\n\r\n// Derived from the integration of the a kernel convolution to SH.\r\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\r\nconst SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\r\n\r\n/**\r\n * Class representing spherical harmonics coefficients to the 3rd degree\r\n */\r\nexport class SphericalHarmonics {\r\n    /**\r\n     * Defines whether or not the harmonics have been prescaled for rendering.\r\n     */\r\n    public preScaled = false;\r\n\r\n    /**\r\n     * The l0,0 coefficients of the spherical harmonics\r\n     */\r\n    public l00: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l1_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,0 coefficients of the spherical harmonics\r\n     */\r\n    public l10: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,1 coefficients of the spherical harmonics\r\n     */\r\n    public l11: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-2 coefficients of the spherical harmonics\r\n     */\r\n    public l2_2: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l2_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,0 coefficients of the spherical harmonics\r\n     */\r\n    public l20: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,1 coefficients of the spherical harmonics\r\n     */\r\n    public l21: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,2 coefficients of the spherical harmonics\r\n     */\r\n    public l22: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds a light to the spherical harmonics\r\n     * @param direction the direction of the light\r\n     * @param color the color of the light\r\n     * @param deltaSolidAngle the delta solid angle of the light\r\n     */\r\n    public addLight(direction: Vector3, color: Color3, deltaSolidAngle: number): void {\r\n        TmpVectors.Vector3[0].set(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        const c = TmpVectors.Vector3[1];\r\n        colorVector.scaleToRef(deltaSolidAngle, c);\r\n\r\n        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\r\n        this.l00.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\r\n        this.l1_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\r\n        this.l10.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\r\n        this.l11.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\r\n        this.l2_2.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\r\n        this.l2_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\r\n        this.l20.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\r\n        this.l21.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\r\n        this.l22.addInPlace(TmpVectors.Vector3[2]);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical harmonics by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number): void {\r\n        this.l00.scaleInPlace(scale);\r\n        this.l1_1.scaleInPlace(scale);\r\n        this.l10.scaleInPlace(scale);\r\n        this.l11.scaleInPlace(scale);\r\n        this.l2_2.scaleInPlace(scale);\r\n        this.l2_1.scaleInPlace(scale);\r\n        this.l20.scaleInPlace(scale);\r\n        this.l21.scaleInPlace(scale);\r\n        this.l22.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\r\n     *\r\n     * ```\r\n     * E_lm = A_l * L_lm\r\n     * ```\r\n     *\r\n     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\r\n     * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\r\n     * the scaling factors are given in equation 9.\r\n     */\r\n    public convertIncidentRadianceToIrradiance(): void {\r\n        // Constant (Band 0)\r\n        this.l00.scaleInPlace(SHCosKernelConvolution[0]);\r\n\r\n        // Linear (Band 1)\r\n        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\r\n        this.l10.scaleInPlace(SHCosKernelConvolution[2]);\r\n        this.l11.scaleInPlace(SHCosKernelConvolution[3]);\r\n\r\n        // Quadratic (Band 2)\r\n        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\r\n        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\r\n        this.l20.scaleInPlace(SHCosKernelConvolution[6]);\r\n        this.l21.scaleInPlace(SHCosKernelConvolution[7]);\r\n        this.l22.scaleInPlace(SHCosKernelConvolution[8]);\r\n    }\r\n\r\n    /**\r\n     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\r\n     *\r\n     * ```\r\n     * L = (1/pi) * E * rho\r\n     * ```\r\n     *\r\n     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\r\n     */\r\n    public convertIrradianceToLambertianRadiance(): void {\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\r\n        // (The pixel shader must apply albedo after texture fetches, etc).\r\n    }\r\n\r\n    /**\r\n     * Integrates the reconstruction coefficients directly in to the SH preventing further\r\n     * required operations at run time.\r\n     *\r\n     * This is simply done by scaling back the SH with Ylm constants parameter.\r\n     * The trigonometric part being applied by the shader at run time.\r\n     */\r\n    public preScaleForRendering(): void {\r\n        this.preScaled = true;\r\n\r\n        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\r\n\r\n        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\r\n        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\r\n        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\r\n\r\n        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\r\n        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\r\n        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\r\n        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\r\n        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        Vector3.FromArrayToRef(data[0], 0, this.l00);\r\n        Vector3.FromArrayToRef(data[1], 0, this.l1_1);\r\n        Vector3.FromArrayToRef(data[2], 0, this.l10);\r\n        Vector3.FromArrayToRef(data[3], 0, this.l11);\r\n        Vector3.FromArrayToRef(data[4], 0, this.l2_2);\r\n        Vector3.FromArrayToRef(data[5], 0, this.l2_1);\r\n        Vector3.FromArrayToRef(data[6], 0, this.l20);\r\n        Vector3.FromArrayToRef(data[7], 0, this.l21);\r\n        Vector3.FromArrayToRef(data[8], 0, this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given floats array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromFloatsArray(data: ArrayLike<number>): SphericalHarmonics {\r\n        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\r\n        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\r\n        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\r\n        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\r\n        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\r\n        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\r\n        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\r\n        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\r\n        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical harmonics from an array.\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        const sh = new SphericalHarmonics();\r\n        return sh.updateFromArray(data);\r\n    }\r\n\r\n    // Keep for references.\r\n    /**\r\n     * Gets the spherical harmonics from polynomial\r\n     * @param polynomial the spherical polynomial\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromPolynomial(polynomial: SphericalPolynomial): SphericalHarmonics {\r\n        const result = new SphericalHarmonics();\r\n\r\n        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\r\n        result.l1_1 = polynomial.y.scale(0.977204);\r\n        result.l10 = polynomial.z.scale(0.977204);\r\n        result.l11 = polynomial.x.scale(0.977204);\r\n        result.l2_2 = polynomial.xy.scale(1.16538);\r\n        result.l2_1 = polynomial.yz.scale(1.16538);\r\n        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\r\n        result.l21 = polynomial.zx.scale(1.16538);\r\n        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\r\n\r\n        result.l1_1.scaleInPlace(-1);\r\n        result.l11.scaleInPlace(-1);\r\n        result.l2_1.scaleInPlace(-1);\r\n        result.l21.scaleInPlace(-1);\r\n\r\n        result.scaleInPlace(Math.PI);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing spherical polynomial coefficients to the 3rd degree\r\n */\r\nexport class SphericalPolynomial {\r\n    private _harmonics: Nullable<SphericalHarmonics>;\r\n\r\n    /**\r\n     * The spherical harmonics used to create the polynomials.\r\n     */\r\n    public get preScaledHarmonics(): SphericalHarmonics {\r\n        if (!this._harmonics) {\r\n            this._harmonics = SphericalHarmonics.FromPolynomial(this);\r\n        }\r\n        if (!this._harmonics.preScaled) {\r\n            this._harmonics.preScaleForRendering();\r\n        }\r\n        return this._harmonics;\r\n    }\r\n\r\n    /**\r\n     * The x coefficients of the spherical polynomial\r\n     */\r\n    public x: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The y coefficients of the spherical polynomial\r\n     */\r\n    public y: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The z coefficients of the spherical polynomial\r\n     */\r\n    public z: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xx coefficients of the spherical polynomial\r\n     */\r\n    public xx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yy coefficients of the spherical polynomial\r\n     */\r\n    public yy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zz coefficients of the spherical polynomial\r\n     */\r\n    public zz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xy coefficients of the spherical polynomial\r\n     */\r\n    public xy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yz coefficients of the spherical polynomial\r\n     */\r\n    public yz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zx coefficients of the spherical polynomial\r\n     */\r\n    public zx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds an ambient color to the spherical polynomial\r\n     * @param color the color to add\r\n     */\r\n    public addAmbient(color: Color3): void {\r\n        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        this.xx.addInPlace(colorVector);\r\n        this.yy.addInPlace(colorVector);\r\n        this.zz.addInPlace(colorVector);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical polynomial by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number) {\r\n        this.x.scaleInPlace(scale);\r\n        this.y.scaleInPlace(scale);\r\n        this.z.scaleInPlace(scale);\r\n        this.xx.scaleInPlace(scale);\r\n        this.yy.scaleInPlace(scale);\r\n        this.zz.scaleInPlace(scale);\r\n        this.yz.scaleInPlace(scale);\r\n        this.zx.scaleInPlace(scale);\r\n        this.xy.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Updates the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public updateFromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        this._harmonics = harmonics;\r\n\r\n        this.x.copyFrom(harmonics.l11);\r\n        this.x.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.y.copyFrom(harmonics.l1_1);\r\n        this.y.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.z.copyFrom(harmonics.l10);\r\n        this.z.scaleInPlace(1.02333);\r\n\r\n        this.xx.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\r\n        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\r\n        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\r\n        this.yy.copyFrom(harmonics.l00);\r\n        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\r\n        this.zz.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\r\n        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\r\n\r\n        this.yz.copyFrom(harmonics.l2_1);\r\n        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.zx.copyFrom(harmonics.l21);\r\n        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.xy.copyFrom(harmonics.l2_2);\r\n        this.xy.scaleInPlace(0.858086);\r\n\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        const result = new SphericalPolynomial();\r\n        return result.updateFromHarmonics(harmonics);\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical polynomial from an array.\r\n     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalPolynomial {\r\n        const sp = new SphericalPolynomial();\r\n        Vector3.FromArrayToRef(data[0], 0, sp.x);\r\n        Vector3.FromArrayToRef(data[1], 0, sp.y);\r\n        Vector3.FromArrayToRef(data[2], 0, sp.z);\r\n        Vector3.FromArrayToRef(data[3], 0, sp.xx);\r\n        Vector3.FromArrayToRef(data[4], 0, sp.yy);\r\n        Vector3.FromArrayToRef(data[5], 0, sp.zz);\r\n        Vector3.FromArrayToRef(data[6], 0, sp.yz);\r\n        Vector3.FromArrayToRef(data[7], 0, sp.zx);\r\n        Vector3.FromArrayToRef(data[8], 0, sp.xy);\r\n        return sp;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"hdrFilteringVertexShader\";\nconst shader = `attribute vec2 position;varying vec3 direction;uniform vec3 up;uniform vec3 right;uniform vec3 front;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nmat3 view=mat3(up,right,front);direction=view*vec3(position,1.0);gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"importanceSampling\";\nconst shader = `vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \nfloat phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const importanceSampling = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBRDFFunctions\";\nconst shader = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}\n#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\n#endif\nreturn brdfLookup.rgb;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;}\n#endif\n/* NOT USED\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\n{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}\n#endif\n*/\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\n*/\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}\n#endif\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\n#ifdef CLEARCOAT\nvec3 getR0RemappedForClearCoat(vec3 f0) {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);\n#endif\n}\n#endif\n#ifdef IRIDESCENCE\nconst mat3 XYZ_TO_REC709=mat3(\n3.2404542,-0.9692660, 0.0556434,\n-1.5371385, 1.8760108,-0.2040259,\n-0.4985314, 0.0415560, 1.0572252\n);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}\nvec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}\nfloat getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}\nvec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}\nvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}\nfloat cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \nvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)\n{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}\nreturn max(I,vec3(0.0));}\n#endif\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}\n#ifdef SHEEN\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\n{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}\n#endif\n#ifdef ANISOTROPIC\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}\n#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\n#ifdef MOBILE\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);\n#else\nfloat a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);\n#endif\n}\n#else\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\n{\n#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nfloat alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\n{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}\n#endif\n#ifdef ANISOTROPIC\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}\n#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }\n#endif\n#ifdef SHEEN\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\n{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}\n/* NOT USED\n#ifdef SHEEN_SOFTER\nfloat l(float x,float alphaG)\n{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}\nfloat lambdaSheen(float cosTheta,float alphaG)\n{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}\nfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\n{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}\n#endif\n*/\n#endif\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}\n#ifdef SS_TRANSLUCENCY\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBRDFFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"hdrFilteringFunctions\";\nconst shader = `#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfloat radicalInverse_VdC(uint bits) \n{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }\nvec2 hammersley(uint i,uint N)\n{return vec2(float(i)/float(N),radicalInverse_VdC(i));}\n#else\nfloat vanDerCorpus(int n,int base)\n{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)\n{if(n>0)\n{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}\nreturn result;}\nvec2 hammersley(int i,int N)\n{return vec2(float(i)/float(N),vanDerCorpus(i,2));}\n#endif\nfloat log4(float x) {return log2(x)/2.;}\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;\n#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c;}}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}\n#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; \nif (alphaG==0.) {\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;}}\nresult=result/weight;return result;}}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\n\nconst name = \"hdrFilteringPixelShader\";\nconst shader = `#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nuniform float alphaG;uniform samplerCube inputTexture;uniform vec2 vFilteringInfo;uniform float hdrScale;varying vec3 direction;void main() {vec3 color=radiance(alphaG,inputTexture,direction,vFilteringInfo);gl_FragColor=vec4(color*hdrScale,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringPixelShader = { name, shader };\n", "import { Vector3 } from \"../../../Maths/math\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { BaseTexture } from \"../baseTexture\";\r\nimport type { ThinEngine } from \"../../../Engines/thinEngine\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\nimport \"../../../Shaders/hdrFiltering.vertex\";\r\nimport \"../../../Shaders/hdrFiltering.fragment\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\n/**\r\n * Options for texture filtering\r\n */\r\ninterface IHDRFilteringOptions {\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    hdrScale?: number;\r\n\r\n    /**\r\n     * Quality of the filter. Should be `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` for prefiltering\r\n     */\r\n    quality?: number;\r\n}\r\n\r\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\r\nexport class HDRFiltering {\r\n    private _engine: ThinEngine;\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n\r\n    private _lodGenerationOffset: number = 0;\r\n    private _lodGenerationScale: number = 0.8;\r\n\r\n    /**\r\n     * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless\r\n     * you care about baking speed.\r\n     */\r\n    public quality: number = Constants.TEXTURE_FILTERING_QUALITY_OFFLINE;\r\n\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    public hdrScale: number = 1;\r\n\r\n    /**\r\n     * Instantiates HDR filter for reflection maps\r\n     *\r\n     * @param engine Thin engine\r\n     * @param options Options\r\n     */\r\n    constructor(engine: ThinEngine, options: IHDRFilteringOptions = {}) {\r\n        // pass\r\n        this._engine = engine;\r\n        this.hdrScale = options.hdrScale || this.hdrScale;\r\n        this.quality = options.quality || this.quality;\r\n    }\r\n\r\n    private _createRenderTarget(size: number): RenderTargetWrapper {\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else if (this._engine.getCaps().textureFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            type: textureType,\r\n            createMipMaps: true,\r\n            generateMipMaps: false,\r\n            generateDepthBuffer: false,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        });\r\n        this._engine.updateTextureWrappingMode(rtWrapper.texture!, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE);\r\n\r\n        this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, rtWrapper.texture!, true);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    private _prefilterInternal(texture: BaseTexture): BaseTexture {\r\n        const width = texture.getSize().width;\r\n        const mipmapsCount = Scalar.ILog2(width) + 1;\r\n\r\n        const effect = this._effectWrapper.effect;\r\n        const outputTexture = this._createRenderTarget(width);\r\n        this._effectRenderer.saveStates();\r\n        this._effectRenderer.setViewport();\r\n\r\n        const intTexture = texture.getInternalTexture();\r\n        if (intTexture) {\r\n            // Just in case generate fresh clean mips.\r\n            this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, intTexture, true);\r\n        }\r\n\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n        const directions = [\r\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\r\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\r\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\r\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\r\n        ];\r\n\r\n        effect.setFloat(\"hdrScale\", this.hdrScale);\r\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\r\n        effect.setTexture(\"inputTexture\", texture);\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            effect.setVector3(\"up\", directions[face][0]);\r\n            effect.setVector3(\"right\", directions[face][1]);\r\n            effect.setVector3(\"front\", directions[face][2]);\r\n\r\n            for (let lod = 0; lod < mipmapsCount; lod++) {\r\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\r\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\r\n                if (lod === 0) {\r\n                    alpha = 0;\r\n                }\r\n\r\n                effect.setFloat(\"alphaG\", alpha);\r\n\r\n                this._effectRenderer.draw();\r\n            }\r\n        }\r\n\r\n        // Cleanup\r\n        this._effectRenderer.restoreStates();\r\n        this._engine.restoreDefaultFramebuffer();\r\n        this._engine._releaseTexture(texture._texture!);\r\n\r\n        // Internal Swap\r\n        const type = outputTexture.texture!.type;\r\n        const format = outputTexture.texture!.format;\r\n\r\n        outputTexture._swapAndDie(texture._texture!);\r\n\r\n        texture._texture!.type = type;\r\n        texture._texture!.format = format;\r\n\r\n        // New settings\r\n        texture.gammaSpace = false;\r\n        texture.lodGenerationOffset = this._lodGenerationOffset;\r\n        texture.lodGenerationScale = this._lodGenerationScale;\r\n        texture._prefiltered = true;\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _createEffect(texture: BaseTexture, onCompiled?: Nullable<(effect: Effect) => void>): EffectWrapper {\r\n        const defines = [];\r\n        if (texture.gammaSpace) {\r\n            defines.push(\"#define GAMMA_INPUT\");\r\n        }\r\n\r\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\r\n\r\n        const effectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            name: \"hdrFiltering\",\r\n            vertexShader: \"hdrFiltering\",\r\n            fragmentShader: \"hdrFiltering\",\r\n            samplerNames: [\"inputTexture\"],\r\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\r\n            useShaderStore: true,\r\n            defines,\r\n            onCompiled: onCompiled,\r\n        });\r\n\r\n        return effectWrapper;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the filter is ready to be used\r\n     * @param texture Texture to filter\r\n     * @returns true if the filter is ready\r\n     */\r\n    public isReady(texture: BaseTexture) {\r\n        return texture.isReady() && this._effectWrapper.effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n     * Prefiltering will be invoked at the end of next rendering pass.\r\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n     * @param texture Texture to filter\r\n     * @param onFinished Callback when filtering is done\r\n     * @returns Promise called when prefiltering is done\r\n     */\r\n    public prefilter(texture: BaseTexture, onFinished: Nullable<() => void> = null): Promise<void> {\r\n        if (!this._engine._features.allowTexturePrefiltering) {\r\n            Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n            return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            this._effectRenderer = new EffectRenderer(this._engine);\r\n            this._effectWrapper = this._createEffect(texture);\r\n            this._effectWrapper.effect.executeWhenCompiled(() => {\r\n                this._prefilterInternal(texture);\r\n                this._effectRenderer.dispose();\r\n                this._effectWrapper.dispose();\r\n                resolve();\r\n                if (onFinished) {\r\n                    onFinished();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n", "import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { DirectionalLight } from \"../../Lights/directionalLight\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { LightConstants } from \"../../Lights/lightConstants\";\r\nimport { HDRFiltering } from \"core/Materials/Textures/Filtering/hdrFiltering\";\r\n\r\n/**\r\n * Options for Light Estimation feature\r\n */\r\nexport interface IWebXRLightEstimationOptions {\r\n    /**\r\n     * Disable the cube map reflection feature. In this case only light direction and color will be updated\r\n     */\r\n    disableCubeMapReflection?: boolean;\r\n    /**\r\n     * Should the scene's env texture be set to the cube map reflection texture\r\n     * Note that this doesn't work is disableCubeMapReflection if set to false\r\n     */\r\n    setSceneEnvironmentTexture?: boolean;\r\n    /**\r\n     * How often should the cubemap update in ms.\r\n     * If not set the cubemap will be updated every time the underlying system updates the environment texture.\r\n     */\r\n    cubeMapPollInterval?: number;\r\n    /**\r\n     * How often should the light estimation properties update in ms.\r\n     * If not set the light estimation properties will be updated on every frame (depending on the underlying system)\r\n     */\r\n    lightEstimationPollInterval?: number;\r\n    /**\r\n     * Should a directional light source be created.\r\n     * If created, this light source will be updated whenever the light estimation values change\r\n     */\r\n    createDirectionalLightSource?: boolean;\r\n    /**\r\n     * Define the format to be used for the light estimation texture.\r\n     */\r\n    reflectionFormat?: XRReflectionFormat;\r\n    /**\r\n     * Should the light estimation's needed vectors be constructed on each frame.\r\n     * Use this when you use those vectors and don't want their values to change outside of the light estimation feature\r\n     */\r\n    disableVectorReuse?: boolean;\r\n\r\n    /**\r\n     * disable applying the spherical polynomial to the cube map texture\r\n     */\r\n    disableSphericalPolynomial?: boolean;\r\n\r\n    /**\r\n     * disable prefiltering the cube map texture\r\n     */\r\n    disablePreFiltering?: boolean;\r\n}\r\n\r\n/**\r\n * An interface describing the result of a light estimation\r\n */\r\nexport interface IWebXRLightEstimation {\r\n    /**\r\n     * The intensity of the light source\r\n     */\r\n    lightIntensity: number;\r\n    /**\r\n     * Color of light source\r\n     */\r\n    lightColor: Color3;\r\n    /**\r\n     * The direction from the light source\r\n     */\r\n    lightDirection: Vector3;\r\n    /**\r\n     * Spherical harmonics coefficients of the light source\r\n     */\r\n    sphericalHarmonics: SphericalHarmonics;\r\n}\r\n\r\n/**\r\n * Light Estimation Feature\r\n *\r\n * @since 5.0.0\r\n */\r\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\r\n    private _canvasContext: Nullable<WebGLRenderingContext | WebGL2RenderingContext> = null;\r\n    private _reflectionCubeMap: Nullable<BaseTexture> = null;\r\n    private _xrLightEstimate: Nullable<XRLightEstimate> = null;\r\n    private _xrLightProbe: Nullable<XRLightProbe> = null;\r\n    private _xrWebGLBinding: Nullable<XRWebGLBinding> = null;\r\n    private _lightDirection: Vector3 = Vector3.Up().negateInPlace();\r\n    private _lightColor: Color3 = Color3.White();\r\n    private _intensity: number = 1;\r\n    private _sphericalHarmonics: SphericalHarmonics = new SphericalHarmonics();\r\n    private _cubeMapPollTime = Date.now();\r\n    private _lightEstimationPollTime = Date.now();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.LIGHT_ESTIMATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * ARCore's reflection cube map size is 16x16.\r\n     * Once other systems support this feature we will need to change this to be dynamic.\r\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\r\n     */\r\n    private _reflectionCubeMapTextureSize: number = 16;\r\n\r\n    private _hdrFilter: HDRFiltering;\r\n\r\n    /**\r\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\r\n     * Otherwise this can be set with an external directional light source.\r\n     * This light will be updated whenever the light estimation values change.\r\n     */\r\n    public directionalLight: Nullable<DirectionalLight> = null;\r\n\r\n    /**\r\n     * This observable will notify when the reflection cube map is updated.\r\n     */\r\n    public onReflectionCubeMapUpdatedObservable: Observable<BaseTexture> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the light estimation feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRLightEstimationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"light-estimation\";\r\n\r\n        if (this.options.createDirectionalLightSource) {\r\n            this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\r\n            this.directionalLight.position = new Vector3(0, 8, 0);\r\n            // intensity will be set later\r\n            this.directionalLight.intensity = 0;\r\n            this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\r\n        }\r\n\r\n        this._hdrFilter = new HDRFiltering(this._xrSessionManager.scene.getEngine());\r\n\r\n        // https://immersive-web.github.io/lighting-estimation/\r\n        Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\r\n     * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\r\n     * when it has been updated.\r\n     */\r\n    public get reflectionCubeMapTexture(): Nullable<BaseTexture> {\r\n        return this._reflectionCubeMap;\r\n    }\r\n\r\n    /**\r\n     * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\r\n     */\r\n    public get xrLightingEstimate(): Nullable<IWebXRLightEstimation> {\r\n        if (this._xrLightEstimate) {\r\n            return {\r\n                lightColor: this._lightColor,\r\n                lightDirection: this._lightDirection,\r\n                lightIntensity: this._intensity,\r\n                sphericalHarmonics: this._sphericalHarmonics,\r\n            };\r\n        }\r\n        return this._xrLightEstimate;\r\n    }\r\n\r\n    private _getCanvasContext(): WebGLRenderingContext | WebGL2RenderingContext {\r\n        if (this._canvasContext === null) {\r\n            this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\r\n        }\r\n        return this._canvasContext;\r\n    }\r\n\r\n    private _getXRGLBinding(): XRWebGLBinding {\r\n        if (this._xrWebGLBinding === null) {\r\n            const context = this._getCanvasContext();\r\n            this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\r\n        }\r\n        return this._xrWebGLBinding;\r\n    }\r\n\r\n    /**\r\n     * Event Listener for \"reflectionchange\" events.\r\n     */\r\n    private _updateReflectionCubeMap = (): void => {\r\n        if (!this._xrLightProbe) {\r\n            return;\r\n        }\r\n        // check poll time, do not update if it has not been long enough\r\n        if (this.options.cubeMapPollInterval) {\r\n            const now = Date.now();\r\n            if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\r\n                return;\r\n            }\r\n            this._cubeMapPollTime = now;\r\n        }\r\n        const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\r\n        if (lp && this._reflectionCubeMap) {\r\n            if (!this._reflectionCubeMap._texture) {\r\n                const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\r\n                internalTexture.isCube = true;\r\n                internalTexture.invertY = false;\r\n                internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.generateMipMaps = true;\r\n                internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n                internalTexture.width = this._reflectionCubeMapTextureSize;\r\n                internalTexture.height = this._reflectionCubeMapTextureSize;\r\n                internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext() as WebGLRenderingContext);\r\n                this._reflectionCubeMap._texture = internalTexture;\r\n            } else {\r\n                this._reflectionCubeMap._texture._hardwareTexture?.set(lp);\r\n                this._reflectionCubeMap._texture.getEngine().resetTextureCache();\r\n            }\r\n            this._reflectionCubeMap._texture.isReady = true;\r\n            if (!this.options.disablePreFiltering) {\r\n                this._xrLightProbe!.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n                this._hdrFilter.prefilter(this._reflectionCubeMap).then(() => {\r\n                    this._xrSessionManager.scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n                    this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap!);\r\n                    this._xrLightProbe!.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n                });\r\n            } else {\r\n                this._xrSessionManager.scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n\r\n                this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const reflectionFormat = this.options.reflectionFormat ?? (this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\");\r\n        this.options.reflectionFormat = reflectionFormat;\r\n        this._xrSessionManager.session\r\n            .requestLightProbe({\r\n                reflectionFormat,\r\n            })\r\n            .then((xrLightProbe: XRLightProbe) => {\r\n                this._xrLightProbe = xrLightProbe;\r\n                if (!this.options.disableCubeMapReflection) {\r\n                    if (!this._reflectionCubeMap) {\r\n                        this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\r\n                        this._reflectionCubeMap._isCube = true;\r\n                        this._reflectionCubeMap.coordinatesMode = Constants.TEXTURE_CUBIC_MODE;\r\n                        if (this.options.setSceneEnvironmentTexture) {\r\n                            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\r\n                        }\r\n                    }\r\n                    this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n                }\r\n            });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        const detached = super.detach();\r\n\r\n        if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\r\n            this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n            this._xrLightProbe = null;\r\n        }\r\n\r\n        this._canvasContext = null;\r\n        this._xrLightEstimate = null;\r\n        // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\r\n        this._xrWebGLBinding = null;\r\n\r\n        return detached;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onReflectionCubeMapUpdatedObservable.clear();\r\n\r\n        if (this.directionalLight) {\r\n            this.directionalLight.dispose();\r\n            this.directionalLight = null;\r\n        }\r\n\r\n        if (this._reflectionCubeMap !== null) {\r\n            if (this._reflectionCubeMap._texture) {\r\n                this._reflectionCubeMap._texture.dispose();\r\n            }\r\n            this._reflectionCubeMap.dispose();\r\n            this._reflectionCubeMap = null;\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        if (this._xrLightProbe !== null) {\r\n            if (this.options.lightEstimationPollInterval) {\r\n                const now = Date.now();\r\n                if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\r\n                    return;\r\n                }\r\n                this._lightEstimationPollTime = now;\r\n            }\r\n            this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\r\n            if (this._xrLightEstimate) {\r\n                this._intensity = Math.max(\r\n                    1.0,\r\n                    this._xrLightEstimate.primaryLightIntensity.x,\r\n                    this._xrLightEstimate.primaryLightIntensity.y,\r\n                    this._xrLightEstimate.primaryLightIntensity.z\r\n                );\r\n\r\n                const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\r\n\r\n                // recreate the vector caches, so that the last one provided to the user will persist\r\n                if (this.options.disableVectorReuse) {\r\n                    this._lightDirection = new Vector3();\r\n                    this._lightColor = new Color3();\r\n                    if (this.directionalLight) {\r\n                        this.directionalLight.direction = this._lightDirection;\r\n                        this.directionalLight.diffuse = this._lightColor;\r\n                    }\r\n                }\r\n\r\n                this._lightDirection.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightDirection.x,\r\n                    this._xrLightEstimate.primaryLightDirection.y,\r\n                    this._xrLightEstimate.primaryLightDirection.z * rhsFactor\r\n                );\r\n                this._lightColor.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightIntensity.x / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.y / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.z / this._intensity\r\n                );\r\n                this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\r\n                if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\r\n                    this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\r\n                    this._reflectionCubeMap.sphericalPolynomial?.updateFromHarmonics(this._sphericalHarmonics);\r\n                }\r\n\r\n                // direction from instead of direction to\r\n                this._lightDirection.negateInPlace();\r\n                // set the values after calculating them\r\n                if (this.directionalLight) {\r\n                    this.directionalLight.direction.copyFrom(this._lightDirection);\r\n                    this.directionalLight.intensity = Math.min(this._intensity, 1.0);\r\n                    this.directionalLight.diffuse.copyFrom(this._lightColor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRLightEstimation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRLightEstimation(xrSessionManager, options);\r\n    },\r\n    WebXRLightEstimation.Version,\r\n    false\r\n);\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * The WebXR Eye Tracking feature grabs eye data from the device and provides it in an easy-access format.\r\n * Currently only enabled for BabylonNative applications.\r\n */\r\nexport class WebXREyeTracking extends WebXRAbstractFeature {\r\n    private _latestEyeSpace: Nullable<XRSpace>;\r\n    private _gazeRay: Nullable<Ray>;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.EYE_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This observable will notify registered observers when eye tracking starts\r\n     */\r\n    public readonly onEyeTrackingStartedObservable: Observable<Ray> = new Observable();\r\n    /**\r\n     * This observable will notify registered observers when eye tracking ends\r\n     */\r\n    public readonly onEyeTrackingEndedObservable: Observable<void> = new Observable();\r\n    /**\r\n     * This observable will notify registered observers on each frame that has valid tracking\r\n     */\r\n    public readonly onEyeTrackingFrameUpdateObservable: Observable<Ray> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the XR eye tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"eye-tracking\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._xrSessionManager.session.removeEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\r\n        this._xrSessionManager.session.removeEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\r\n\r\n        this.onEyeTrackingStartedObservable.clear();\r\n        this.onEyeTrackingEndedObservable.clear();\r\n        this.onEyeTrackingFrameUpdateObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Returns whether the gaze data is valid or not\r\n     * @returns true if the data is valid\r\n     */\r\n    public get isEyeGazeValid(): boolean {\r\n        return !!this._gazeRay;\r\n    }\r\n\r\n    /**\r\n     * Get a reference to the gaze ray. This data is valid while eye tracking persists, and will be set to null when gaze data is no longer available\r\n     * @returns a reference to the gaze ray if it exists and is valid, returns null otherwise.\r\n     */\r\n    public getEyeGaze(): Nullable<Ray> {\r\n        return this._gazeRay;\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        if (this._latestEyeSpace && this._gazeRay) {\r\n            const pose = frame.getPose(this._latestEyeSpace, this._xrSessionManager.referenceSpace);\r\n            if (pose) {\r\n                this._gazeRay.origin.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n                const quat = pose.transform.orientation;\r\n                TmpVectors.Quaternion[0].set(quat.x, quat.y, quat.z, quat.w);\r\n\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    this._gazeRay.origin.z *= -1;\r\n                    TmpVectors.Quaternion[0].z *= -1;\r\n                    TmpVectors.Quaternion[0].w *= -1;\r\n\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\r\n                } else {\r\n                    Vector3.RightHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\r\n                }\r\n\r\n                this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _eyeTrackingStartListener = (event: XREyeTrackingSourceEvent) => {\r\n        this._latestEyeSpace = event.gazeSpace;\r\n        this._gazeRay = new Ray(Vector3.Zero(), Vector3.Forward());\r\n        this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay);\r\n    };\r\n\r\n    private _eyeTrackingEndListener = () => {\r\n        this._latestEyeSpace = null;\r\n        this._gazeRay = null;\r\n        this.onEyeTrackingEndedObservable.notifyObservers();\r\n    };\r\n\r\n    private _init() {\r\n        // Only supported by BabylonNative\r\n        if (this._xrSessionManager.isNative) {\r\n            this._xrSessionManager.session.addEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXREyeTracking.Name,\r\n    (xrSessionManager) => {\r\n        return () => new WebXREyeTracking(xrSessionManager);\r\n    },\r\n    WebXREyeTracking.Version,\r\n    false\r\n);\r\n", "import type { Engine } from \"../../Engines/engine\";\r\nimport { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\nclass CircleBuffer {\r\n    private _samples: Array<Vector2> = [];\r\n    private _idx: number = 0;\r\n\r\n    constructor(numSamples: number, initializer?: () => Vector2) {\r\n        for (let idx = 0; idx < numSamples; ++idx) {\r\n            this._samples.push(initializer ? initializer() : Vector2.Zero());\r\n        }\r\n    }\r\n\r\n    public get length() {\r\n        return this._samples.length;\r\n    }\r\n\r\n    public push(x: number, y: number) {\r\n        this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\r\n        this.at(0).copyFromFloats(x, y);\r\n    }\r\n\r\n    public at(idx: number) {\r\n        if (idx >= this._samples.length) {\r\n            throw new Error(\"Index out of bounds\");\r\n        }\r\n        return this._samples[(this._idx + idx) % this._samples.length];\r\n    }\r\n}\r\n\r\ninterface IDetectedStep {\r\n    leftApex: Vector2;\r\n    rightApex: Vector2;\r\n    currentPosition: Vector2;\r\n    currentStepDirection: \"left\" | \"right\";\r\n}\r\n\r\nclass FirstStepDetector {\r\n    private _samples = new CircleBuffer(20);\r\n    private _entropy = 0;\r\n\r\n    public onFirstStepDetected: Observable<IDetectedStep> = new Observable<IDetectedStep>();\r\n\r\n    public update(posX: number, posY: number, forwardX: number, forwardY: number) {\r\n        this._samples.push(posX, posY);\r\n        const origin = this._samples.at(0);\r\n\r\n        this._entropy *= this._entropyDecayFactor;\r\n        this._entropy += Vector2.Distance(origin, this._samples.at(1));\r\n        if (this._entropy > this._entropyThreshold) {\r\n            return;\r\n        }\r\n\r\n        let samePointIdx;\r\n        for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\r\n            if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (samePointIdx === this._samples.length) {\r\n            return;\r\n        }\r\n\r\n        let apexDistSquared = -1;\r\n        let apexIdx = 0;\r\n        for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {\r\n            distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\r\n            if (distSquared > apexDistSquared) {\r\n                apexIdx = idx;\r\n                apexDistSquared = distSquared;\r\n            }\r\n        }\r\n\r\n        if (apexDistSquared < this._apexSquaredDistanceThreshold) {\r\n            return;\r\n        }\r\n\r\n        const apex = this._samples.at(apexIdx);\r\n        const axis = apex.subtract(origin);\r\n        axis.normalize();\r\n\r\n        const vec = TmpVectors.Vector2[0];\r\n        let dot;\r\n        let sample;\r\n        let sumSquaredProjectionDistances = 0;\r\n        for (let idx = 1; idx < samePointIdx; ++idx) {\r\n            sample = this._samples.at(idx);\r\n            sample.subtractToRef(origin, vec);\r\n            dot = Vector2.Dot(axis, vec);\r\n            sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\r\n        }\r\n\r\n        if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\r\n            return;\r\n        }\r\n\r\n        const forwardVec = TmpVectors.Vector3[0];\r\n        forwardVec.set(forwardX, forwardY, 0);\r\n        const axisVec = TmpVectors.Vector3[1];\r\n        axisVec.set(axis.x, axis.y, 0);\r\n        const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\r\n        const leftApex = origin.clone();\r\n        const rightApex = origin.clone();\r\n        apex.subtractToRef(origin, axis);\r\n        if (isApexLeft) {\r\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\r\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\r\n        } else {\r\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\r\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\r\n        }\r\n        this.onFirstStepDetected.notifyObservers({\r\n            leftApex: leftApex,\r\n            rightApex: rightApex,\r\n            currentPosition: origin,\r\n            currentStepDirection: isApexLeft ? \"right\" : \"left\",\r\n        });\r\n    }\r\n\r\n    public reset() {\r\n        for (let idx = 0; idx < this._samples.length; ++idx) {\r\n            this._samples.at(idx).copyFromFloats(0, 0);\r\n        }\r\n    }\r\n\r\n    private get _samePointCheckStartIdx() {\r\n        return Math.floor(this._samples.length / 3);\r\n    }\r\n\r\n    private get _samePointSquaredDistanceThreshold() {\r\n        return 0.03 * 0.03;\r\n    }\r\n\r\n    private get _apexSquaredDistanceThreshold() {\r\n        return 0.09 * 0.09;\r\n    }\r\n\r\n    private get _squaredProjectionDistanceThreshold() {\r\n        return 0.03 * 0.03;\r\n    }\r\n\r\n    private get _axisToApexShrinkFactor() {\r\n        return 0.8;\r\n    }\r\n\r\n    private get _axisToApexExtendFactor() {\r\n        return -1.6;\r\n    }\r\n\r\n    private get _entropyDecayFactor() {\r\n        return 0.93;\r\n    }\r\n\r\n    private get _entropyThreshold() {\r\n        return 0.4;\r\n    }\r\n}\r\n\r\nclass WalkingTracker {\r\n    private _leftApex = new Vector2();\r\n    private _rightApex = new Vector2();\r\n    private _currentPosition = new Vector2();\r\n    private _axis = new Vector2();\r\n    private _axisLength = -1;\r\n    private _forward = new Vector2();\r\n    private _steppingLeft = false;\r\n    private _t = -1;\r\n    private _maxT = -1;\r\n    private _maxTPosition = new Vector2();\r\n    private _vitality = 0;\r\n\r\n    public onMovement = new Observable<{ deltaT: number }>();\r\n    public onFootfall = new Observable<{ foot: \"left\" | \"right\" }>();\r\n\r\n    constructor(leftApex: Vector2, rightApex: Vector2, currentPosition: Vector2, currentStepDirection: \"left\" | \"right\") {\r\n        this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\r\n    }\r\n\r\n    private _reset(leftApex: Vector2, rightApex: Vector2, currentPosition: Vector2, steppingLeft: boolean) {\r\n        this._leftApex.copyFrom(leftApex);\r\n        this._rightApex.copyFrom(rightApex);\r\n        this._steppingLeft = steppingLeft;\r\n\r\n        if (this._steppingLeft) {\r\n            this._leftApex.subtractToRef(this._rightApex, this._axis);\r\n            this._forward.copyFromFloats(-this._axis.y, this._axis.x);\r\n        } else {\r\n            this._rightApex.subtractToRef(this._leftApex, this._axis);\r\n            this._forward.copyFromFloats(this._axis.y, -this._axis.x);\r\n        }\r\n        this._axisLength = this._axis.length();\r\n        this._forward.scaleInPlace(1 / this._axisLength);\r\n\r\n        this._updateTAndVitality(currentPosition.x, currentPosition.y);\r\n        this._maxT = this._t;\r\n        this._maxTPosition.copyFrom(currentPosition);\r\n\r\n        this._vitality = 1;\r\n    }\r\n\r\n    private _updateTAndVitality(x: number, y: number) {\r\n        this._currentPosition.copyFromFloats(x, y);\r\n\r\n        if (this._steppingLeft) {\r\n            this._currentPosition.subtractInPlace(this._rightApex);\r\n        } else {\r\n            this._currentPosition.subtractInPlace(this._leftApex);\r\n        }\r\n        const priorT = this._t;\r\n        const dot = Vector2.Dot(this._currentPosition, this._axis);\r\n        this._t = dot / (this._axisLength * this._axisLength);\r\n        const projDistSquared = this._currentPosition.lengthSquared() - (dot / this._axisLength) * (dot / this._axisLength);\r\n\r\n        // TODO: Extricate the magic.\r\n        this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\r\n    }\r\n\r\n    public update(x: number, y: number) {\r\n        if (this._vitality < this._vitalityThreshold) {\r\n            return false;\r\n        }\r\n\r\n        const priorT = this._t;\r\n        this._updateTAndVitality(x, y);\r\n\r\n        if (this._t > this._maxT) {\r\n            this._maxT = this._t;\r\n            this._maxTPosition.copyFromFloats(x, y);\r\n        }\r\n\r\n        if (this._vitality < this._vitalityThreshold) {\r\n            return false;\r\n        }\r\n\r\n        if (this._t > priorT) {\r\n            this.onMovement.notifyObservers({ deltaT: this._t - priorT });\r\n\r\n            if (priorT < 0.5 && this._t >= 0.5) {\r\n                this.onFootfall.notifyObservers({ foot: this._steppingLeft ? \"left\" : \"right\" });\r\n            }\r\n        }\r\n\r\n        if (this._t < 0.95 * this._maxT) {\r\n            this._currentPosition.copyFromFloats(x, y);\r\n            if (this._steppingLeft) {\r\n                this._leftApex.copyFrom(this._maxTPosition);\r\n            } else {\r\n                this._rightApex.copyFrom(this._maxTPosition);\r\n            }\r\n            this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\r\n        }\r\n\r\n        if (this._axisLength < 0.03) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private get _vitalityThreshold() {\r\n        return 0.1;\r\n    }\r\n\r\n    get forward() {\r\n        return this._forward;\r\n    }\r\n}\r\n\r\nclass Walker {\r\n    private _engine: Engine;\r\n    private _detector = new FirstStepDetector();\r\n    private _walker: Nullable<WalkingTracker> = null;\r\n    private _movement = new Vector2();\r\n    private _millisecondsSinceLastUpdate: number = Walker._MillisecondsPerUpdate;\r\n\r\n    private static get _MillisecondsPerUpdate(): number {\r\n        // 15 FPS\r\n        return 1000 / 15;\r\n    }\r\n\r\n    public movementThisFrame: Vector3 = Vector3.Zero();\r\n\r\n    constructor(engine: Engine) {\r\n        this._engine = engine;\r\n        this._detector.onFirstStepDetected.add((event) => {\r\n            if (!this._walker) {\r\n                this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\r\n                this._walker.onFootfall.add(() => {\r\n                    Logger.Log(\"Footfall!\");\r\n                });\r\n                this._walker.onMovement.add((event) => {\r\n                    this._walker!.forward.scaleAndAddToRef(0.024 * event.deltaT, this._movement);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    public update(position: Vector3, forward: Vector3) {\r\n        forward.y = 0;\r\n        forward.normalize();\r\n\r\n        // Enforce reduced framerate\r\n        this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\r\n        if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\r\n            this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\r\n            this._detector.update(position.x, position.z, forward.x, forward.z);\r\n            if (this._walker) {\r\n                const updated = this._walker.update(position.x, position.z);\r\n                if (!updated) {\r\n                    this._walker = null;\r\n                }\r\n            }\r\n            this._movement.scaleInPlace(0.85);\r\n        }\r\n\r\n        this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the walking locomotion feature.\r\n */\r\nexport interface IWebXRWalkingLocomotionOptions {\r\n    /**\r\n     * The target to be moved by walking locomotion. This should be the transform node\r\n     * which is the root of the XR space (i.e., the WebXRCamera's parent node). However,\r\n     * for simple cases and legacy purposes, articulating the WebXRCamera itself is also\r\n     * supported as a deprecated feature.\r\n     */\r\n    locomotionTarget: WebXRCamera | TransformNode;\r\n}\r\n\r\n/**\r\n * A module that will enable VR locomotion by detecting when the user walks in place.\r\n */\r\nexport class WebXRWalkingLocomotion extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name.\r\n     */\r\n    public static get Name(): string {\r\n        return WebXRFeatureName.WALKING_LOCOMOTION;\r\n    }\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number has no external basis.\r\n     */\r\n    public static get Version(): number {\r\n        return 1;\r\n    }\r\n\r\n    private _sessionManager: WebXRSessionManager;\r\n    private _up: Vector3 = new Vector3();\r\n    private _forward: Vector3 = new Vector3();\r\n    private _position: Vector3 = new Vector3();\r\n    private _movement: Vector3 = new Vector3();\r\n    private _walker: Nullable<Walker>;\r\n\r\n    private _locomotionTarget: WebXRCamera | TransformNode;\r\n    private _isLocomotionTargetWebXRCamera: boolean;\r\n\r\n    /**\r\n     * The target to be articulated by walking locomotion.\r\n     * When the walking locomotion feature detects walking in place, this element's\r\n     * X and Z coordinates will be modified to reflect locomotion. This target should\r\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\r\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\r\n     * of the WebXRCamera directly and is thus discouraged.\r\n     */\r\n    public get locomotionTarget(): WebXRCamera | TransformNode {\r\n        return this._locomotionTarget;\r\n    }\r\n\r\n    /**\r\n     * The target to be articulated by walking locomotion.\r\n     * When the walking locomotion feature detects walking in place, this element's\r\n     * X and Z coordinates will be modified to reflect locomotion. This target should\r\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\r\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\r\n     * of the WebXRCamera directly and is thus discouraged.\r\n     */\r\n    public set locomotionTarget(locomotionTarget: WebXRCamera | TransformNode) {\r\n        this._locomotionTarget = locomotionTarget;\r\n        this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Construct a new Walking Locomotion feature.\r\n     * @param sessionManager manager for the current XR session\r\n     * @param options creation options, prominently including the vector target for locomotion\r\n     */\r\n    public constructor(sessionManager: WebXRSessionManager, options: IWebXRWalkingLocomotionOptions) {\r\n        super(sessionManager);\r\n        this._sessionManager = sessionManager;\r\n        this.locomotionTarget = options.locomotionTarget;\r\n        if (this._isLocomotionTargetWebXRCamera) {\r\n            Logger.Warn(\r\n                \"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether this feature is compatible with the current WebXR session.\r\n     * Walking locomotion is only compatible with \"immersive-vr\" sessions.\r\n     * @returns true if compatible, false otherwise\r\n     */\r\n    public isCompatible(): boolean {\r\n        return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\r\n    }\r\n\r\n    /**\r\n     * Attaches the feature.\r\n     * Typically called automatically by the features manager.\r\n     * @returns true if attach succeeded, false otherwise\r\n     */\r\n    public attach(): boolean {\r\n        if (!this.isCompatible || !super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._walker = new Walker(this._sessionManager.scene.getEngine());\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detaches the feature.\r\n     * Typically called automatically by the features manager.\r\n     * @returns true if detach succeeded, false otherwise\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        this._walker = null;\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame): void {\r\n        const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n\r\n        const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\r\n\r\n        const m = pose.transform.matrix;\r\n        this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\r\n        this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\r\n        this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);\r\n\r\n        // Compute the nape position\r\n        this._forward.scaleAndAddToRef(0.05, this._position);\r\n        this._up.scaleAndAddToRef(-0.05, this._position);\r\n        this._walker!.update(this._position, this._forward);\r\n        this._movement.copyFrom(this._walker!.movementThisFrame);\r\n        if (!this._isLocomotionTargetWebXRCamera) {\r\n            Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\r\n        }\r\n        this.locomotionTarget.position.addInPlace(this._movement);\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRWalkingLocomotion.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRWalkingLocomotion(xrSessionManager, options);\r\n    },\r\n    WebXRWalkingLocomotion.Version,\r\n    false\r\n);\r\n", "import type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport type { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"core/Maths/math.viewport\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { WebXRLayerType } from \"core/XR/webXRLayerWrapper\";\r\nimport { WebXRLayerWrapper } from \"core/XR/webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"core/XR/webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"core/XR/webXRSessionManager\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Wraps xr composition layers.\r\n * @internal\r\n */\r\nexport class WebXRCompositionLayerWrapper extends WebXRLayerWrapper {\r\n    constructor(\r\n        public getWidth: () => number,\r\n        public getHeight: () => number,\r\n        public readonly layer: XRCompositionLayer,\r\n        public readonly layerType: WebXRLayerType,\r\n        public readonly isMultiview: boolean,\r\n        public createRTTProvider: (xrSessionManager: WebXRSessionManager) => WebXRLayerRenderTargetTextureProvider,\r\n        public _originalInternalTexture: Nullable<InternalTexture> = null\r\n    ) {\r\n        super(getWidth, getHeight, layer, layerType, createRTTProvider);\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRCompositionLayer.\r\n * @internal\r\n */\r\nexport class WebXRCompositionLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    protected _lastSubImages = new Map<XREye, XRWebGLSubImage>();\r\n    private _compositionLayer: XRCompositionLayer;\r\n    /**\r\n     * Fires every time a new render target texture is created (either for eye, for view, or for the entire frame)\r\n     */\r\n    public onRenderTargetTextureCreatedObservable = new Observable<{ texture: RenderTargetTexture; eye?: XREye }>();\r\n\r\n    constructor(\r\n        protected readonly _xrSessionManager: WebXRSessionManager,\r\n        protected readonly _xrWebGLBinding: XRWebGLBinding,\r\n        public readonly layerWrapper: WebXRCompositionLayerWrapper\r\n    ) {\r\n        super(_xrSessionManager.scene, layerWrapper);\r\n        this._compositionLayer = layerWrapper.layer;\r\n    }\r\n\r\n    protected _getRenderTargetForSubImage(subImage: XRWebGLSubImage, eye: XREye = \"none\") {\r\n        const lastSubImage = this._lastSubImages.get(eye);\r\n        const eyeIndex = eye == \"right\" ? 1 : 0;\r\n\r\n        const colorTextureWidth = subImage.colorTextureWidth ?? subImage.textureWidth;\r\n        const colorTextureHeight = subImage.colorTextureHeight ?? subImage.textureHeight;\r\n\r\n        if (!this._renderTargetTextures[eyeIndex] || lastSubImage?.textureWidth !== colorTextureWidth || lastSubImage?.textureHeight !== colorTextureHeight) {\r\n            let depthStencilTexture;\r\n            const depthStencilTextureWidth = subImage.depthStencilTextureWidth ?? colorTextureWidth;\r\n            const depthStencilTextureHeight = subImage.depthStencilTextureHeight ?? colorTextureHeight;\r\n            if (colorTextureWidth === depthStencilTextureWidth || colorTextureHeight === depthStencilTextureHeight) {\r\n                depthStencilTexture = subImage.depthStencilTexture;\r\n            }\r\n\r\n            this._renderTargetTextures[eyeIndex] = this._createRenderTargetTexture(\r\n                colorTextureWidth,\r\n                colorTextureHeight,\r\n                null,\r\n                subImage.colorTexture,\r\n                depthStencilTexture,\r\n                this.layerWrapper.isMultiview\r\n            );\r\n\r\n            this._framebufferDimensions = {\r\n                framebufferWidth: colorTextureWidth,\r\n                framebufferHeight: colorTextureHeight,\r\n            };\r\n            this.onRenderTargetTextureCreatedObservable.notifyObservers({ texture: this._renderTargetTextures[eyeIndex], eye });\r\n        }\r\n\r\n        this._lastSubImages.set(eye, subImage);\r\n        return this._renderTargetTextures[eyeIndex];\r\n    }\r\n    private _getSubImageForEye(eye?: XREye): Nullable<XRWebGLSubImage> {\r\n        const currentFrame = this._xrSessionManager.currentFrame;\r\n        if (currentFrame) {\r\n            return this._xrWebGLBinding.getSubImage(this._compositionLayer, currentFrame, eye);\r\n        }\r\n        return null;\r\n    }\r\n    public getRenderTargetTextureForEye(eye?: XREye): Nullable<RenderTargetTexture> {\r\n        const subImage = this._getSubImageForEye(eye);\r\n        if (subImage) {\r\n            return this._getRenderTargetForSubImage(subImage, eye);\r\n        }\r\n        return null;\r\n    }\r\n    public getRenderTargetTextureForView(view?: XRView): Nullable<RenderTargetTexture> {\r\n        return this.getRenderTargetTextureForEye(view?.eye);\r\n    }\r\n\r\n    protected _setViewportForSubImage(viewport: Viewport, subImage: XRWebGLSubImage) {\r\n        const textureWidth = subImage.colorTextureWidth ?? subImage.textureWidth;\r\n        const textureHeight = subImage.colorTextureHeight ?? subImage.textureHeight;\r\n        const xrViewport = subImage.viewport;\r\n        viewport.x = xrViewport.x / textureWidth;\r\n        viewport.y = xrViewport.y / textureHeight;\r\n        viewport.width = xrViewport.width / textureWidth;\r\n        viewport.height = xrViewport.height / textureHeight;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForEye(view.eye);\r\n        if (subImage) {\r\n            this._setViewportForSubImage(viewport, subImage);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n", "import type { WebXRSessionManager } from \"core/XR/webXRSessionManager\";\r\nimport { WebXRCompositionLayerRenderTargetTextureProvider, WebXRCompositionLayerWrapper } from \"./WebXRCompositionLayer\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"core/Maths/math.viewport\";\r\n\r\n/**\r\n * Wraps xr projection layers.\r\n * @internal\r\n */\r\nexport class WebXRProjectionLayerWrapper extends WebXRCompositionLayerWrapper {\r\n    constructor(\r\n        public readonly layer: XRProjectionLayer,\r\n        isMultiview: boolean,\r\n        xrGLBinding: XRWebGLBinding\r\n    ) {\r\n        super(\r\n            () => layer.textureWidth,\r\n            () => layer.textureHeight,\r\n            layer,\r\n            \"XRProjectionLayer\",\r\n            isMultiview,\r\n            (sessionManager) => new WebXRProjectionLayerRenderTargetTextureProvider(sessionManager, xrGLBinding, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRProjectionLayer.\r\n * @internal\r\n */\r\nclass WebXRProjectionLayerRenderTargetTextureProvider extends WebXRCompositionLayerRenderTargetTextureProvider {\r\n    private readonly _projectionLayer: XRProjectionLayer;\r\n\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        _xrWebGLBinding: XRWebGLBinding,\r\n        public readonly layerWrapper: WebXRProjectionLayerWrapper\r\n    ) {\r\n        super(_xrSessionManager, _xrWebGLBinding, layerWrapper);\r\n        this._projectionLayer = layerWrapper.layer;\r\n    }\r\n\r\n    private _getSubImageForView(view: XRView): XRWebGLSubImage {\r\n        return this._xrWebGLBinding.getViewSubImage(this._projectionLayer, view);\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._getRenderTargetForSubImage(this._getSubImageForView(view), view.eye);\r\n    }\r\n\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        const lastSubImage = this._lastSubImages.get(eye);\r\n        if (lastSubImage) {\r\n            return this._getRenderTargetForSubImage(lastSubImage, eye);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForView(view);\r\n        if (subImage) {\r\n            this._setViewportForSubImage(viewport, subImage);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\nexport const defaultXRProjectionLayerInit: XRProjectionLayerInit = {\r\n    textureType: \"texture\",\r\n    colorFormat: 0x1908 /* WebGLRenderingContext.RGBA */,\r\n    depthFormat: 0x88f0 /* WebGLRenderingContext.DEPTH24_STENCIL8 */,\r\n    scaleFactor: 1.0,\r\n    clearOnAccess: false,\r\n};\r\n", "import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRLayerWrapper } from \"../webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"../webXRWebGLLayer\";\r\nimport { WebXRProjectionLayerWrapper, defaultXRProjectionLayerInit } from \"./Layers/WebXRProjectionLayer\";\r\nimport { WebXRCompositionLayerRenderTargetTextureProvider, WebXRCompositionLayerWrapper } from \"./Layers/WebXRCompositionLayer\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\nimport type { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport type { LensFlareSystem } from \"core/LensFlares/lensFlareSystem\";\r\n\r\nconst defaultXRWebGLLayerInit: XRWebGLLayerInit = {};\r\n\r\n/**\r\n * Configuration options of the layers feature\r\n */\r\nexport interface IWebXRLayersOptions {\r\n    /**\r\n     * Whether to try initializing the base projection layer as a multiview render target, if multiview is supported.\r\n     * Defaults to false.\r\n     */\r\n    preferMultiviewOnInit?: boolean;\r\n\r\n    /**\r\n     * Optional configuration for the base projection layer.\r\n     */\r\n    projectionLayerInit?: Partial<XRProjectionLayerInit>;\r\n}\r\n\r\n/**\r\n * Exposes the WebXR Layers API.\r\n */\r\nexport class WebXRLayers extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.LAYERS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n    /**\r\n     * Already-created layers\r\n     */\r\n    private _existingLayers: WebXRLayerWrapper[] = [];\r\n\r\n    private _glContext: WebGLRenderingContext | WebGL2RenderingContext;\r\n    private _xrWebGLBinding: XRWebGLBinding;\r\n    private _isMultiviewEnabled = false;\r\n    private _projectionLayerInitialized = false;\r\n\r\n    private _compositionLayerTextureMapping: WeakMap<XRCompositionLayer, ThinTexture> = new WeakMap();\r\n    private _layerToRTTProviderMapping: WeakMap<XRCompositionLayer, WebXRCompositionLayerRenderTargetTextureProvider> = new WeakMap();\r\n\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRLayersOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"layers\";\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._xrSessionManager.scene.getEngine();\r\n        this._glContext = engine._gl;\r\n        this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\r\n        this._existingLayers.length = 0;\r\n\r\n        const projectionLayerInit = { ...defaultXRProjectionLayerInit, ...this._options.projectionLayerInit };\r\n        this._isMultiviewEnabled = this._options.preferMultiviewOnInit && engine.getCaps().multiview;\r\n        this.createProjectionLayer(projectionLayerInit /*, projectionLayerMultiview*/);\r\n        this._projectionLayerInitialized = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        this._existingLayers.forEach((layer) => {\r\n            layer.dispose();\r\n        });\r\n        this._existingLayers.length = 0;\r\n        this._projectionLayerInitialized = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a new XRWebGLLayer.\r\n     * @param params an object providing configuration options for the new XRWebGLLayer\r\n     * @returns the XRWebGLLayer\r\n     */\r\n    public createXRWebGLLayer(params = defaultXRWebGLLayerInit): WebXRWebGLLayerWrapper {\r\n        const layer = new XRWebGLLayer(this._xrSessionManager.session, this._glContext, params);\r\n        return new WebXRWebGLLayerWrapper(layer);\r\n    }\r\n\r\n    private _validateLayerInit(params: XRProjectionLayerInit | XRQuadLayerInit, multiview = this._isMultiviewEnabled): void {\r\n        // check if we are in session\r\n        if (!this._xrSessionManager.inXRSession) {\r\n            throw new Error(\"Cannot create a layer outside of a WebXR session. Make sure the session has started before creating layers.\");\r\n        }\r\n        if (multiview && params.textureType !== \"texture-array\") {\r\n            throw new Error(\"Projection layers can only be made multiview if they use texture arrays. Set the textureType parameter to 'texture-array'.\");\r\n        }\r\n\r\n        // TODO (rgerd): Support RTT's that are bound to sub-images in the texture array.\r\n        if (!multiview && params.textureType === \"texture-array\") {\r\n            throw new Error(\"We currently only support multiview rendering when the textureType parameter is set to 'texture-array'.\");\r\n        }\r\n    }\r\n\r\n    private _extendXRLayerInit(params: XRProjectionLayerInit | XRQuadLayerInit, multiview = this._isMultiviewEnabled): XRProjectionLayerInit | XRQuadLayerInit {\r\n        if (multiview) {\r\n            params.textureType = \"texture-array\";\r\n        }\r\n        return params;\r\n    }\r\n\r\n    /**\r\n     * Creates a new XRProjectionLayer.\r\n     * @param params an object providing configuration options for the new XRProjectionLayer.\r\n     * @param multiview whether the projection layer should render with multiview. Will be tru automatically if the extension initialized with multiview.\r\n     * @returns the projection layer\r\n     */\r\n    public createProjectionLayer(params = defaultXRProjectionLayerInit, multiview = this._isMultiviewEnabled): WebXRProjectionLayerWrapper {\r\n        this._extendXRLayerInit(params, multiview);\r\n        this._validateLayerInit(params, multiview);\r\n\r\n        const projLayer = this._xrWebGLBinding.createProjectionLayer(params);\r\n        const layer = new WebXRProjectionLayerWrapper(projLayer, multiview, this._xrWebGLBinding);\r\n        this.addXRSessionLayer(layer);\r\n        return layer;\r\n    }\r\n\r\n    /**\r\n     * Note about making it private - this function will be exposed once I decide on a proper API to support all of the XR layers' options\r\n     * @param options an object providing configuration options for the new XRQuadLayer.\r\n     * @param babylonTexture the texture to display in the layer\r\n     * @returns the quad layer\r\n     */\r\n    private _createQuadLayer(options: { params: Partial<XRQuadLayerInit> } = { params: {} }, babylonTexture?: ThinTexture): WebXRCompositionLayerWrapper {\r\n        this._extendXRLayerInit(options.params, false);\r\n        const width = (this._existingLayers[0].layer as XRProjectionLayer).textureWidth;\r\n        const height = (this._existingLayers[0].layer as XRProjectionLayer).textureHeight;\r\n        const populatedParams: XRQuadLayerInit = {\r\n            space: this._xrSessionManager.referenceSpace,\r\n            viewPixelWidth: width,\r\n            viewPixelHeight: height,\r\n            clearOnAccess: true,\r\n            ...options.params,\r\n        };\r\n        this._validateLayerInit(populatedParams, false);\r\n        const quadLayer = this._xrWebGLBinding.createQuadLayer(populatedParams);\r\n\r\n        quadLayer.width = this._isMultiviewEnabled ? 1 : 2;\r\n        quadLayer.height = 1;\r\n        // this wrapper is not really needed, but it's here for consistency\r\n        const wrapper: WebXRCompositionLayerWrapper = new WebXRCompositionLayerWrapper(\r\n            () => quadLayer.width,\r\n            () => quadLayer.height,\r\n            quadLayer,\r\n            \"XRQuadLayer\",\r\n            false,\r\n            (sessionManager) => new WebXRCompositionLayerRenderTargetTextureProvider(sessionManager, this._xrWebGLBinding, wrapper)\r\n        );\r\n\r\n        if (babylonTexture) {\r\n            this._compositionLayerTextureMapping.set(quadLayer, babylonTexture);\r\n        }\r\n        const rtt = wrapper.createRenderTargetTextureProvider(this._xrSessionManager) as WebXRCompositionLayerRenderTargetTextureProvider;\r\n        this._layerToRTTProviderMapping.set(quadLayer, rtt);\r\n        this.addXRSessionLayer(wrapper);\r\n        return wrapper;\r\n    }\r\n\r\n    /**\r\n     * @experimental\r\n     * This will support full screen ADT when used with WebXR Layers. This API might change in the future.\r\n     * Note that no interaction will be available with the ADT when using this method\r\n     * @param texture the texture to display in the layer\r\n     * @param options optional parameters for the layer\r\n     * @returns a composition layer containing the texture\r\n     */\r\n    public addFullscreenAdvancedDynamicTexture(texture: DynamicTexture, options: { distanceFromHeadset: number } = { distanceFromHeadset: 1.5 }): WebXRCompositionLayerWrapper {\r\n        const wrapper = this._createQuadLayer(\r\n            {\r\n                params: {\r\n                    space: this._xrSessionManager.viewerReferenceSpace,\r\n                    textureType: \"texture\",\r\n                    layout: \"mono\",\r\n                },\r\n            },\r\n            texture\r\n        );\r\n\r\n        const layer = wrapper.layer as XRQuadLayer;\r\n        const distance = Math.max(0.1, options.distanceFromHeadset);\r\n        const pos = { x: 0, y: 0, z: -distance };\r\n        const orient = { x: 0, y: 0, z: 0, w: 1 };\r\n        layer.transform = new XRRigidTransform(pos, orient);\r\n\r\n        const rttProvider = this._layerToRTTProviderMapping.get(layer);\r\n        if (!rttProvider) {\r\n            throw new Error(\"Could not find the RTT provider for the layer\");\r\n        }\r\n        const babylonLayer = this._xrSessionManager.scene.layers.find((babylonLayer) => {\r\n            return babylonLayer.texture === texture;\r\n        });\r\n        if (!babylonLayer) {\r\n            throw new Error(\"Could not find the babylon layer for the texture\");\r\n        }\r\n        rttProvider.onRenderTargetTextureCreatedObservable.add((data) => {\r\n            if (data.eye && data.eye === \"right\") {\r\n                return;\r\n            }\r\n            data.texture.clearColor = new Color4(0, 0, 0, 0);\r\n            babylonLayer.renderTargetTextures.push(data.texture);\r\n            babylonLayer.renderOnlyInRenderTargetTextures = true;\r\n            // for stereo (not for gui) it should be onBeforeCameraRenderObservable\r\n            this._xrSessionManager.scene.onBeforeRenderObservable.add(() => {\r\n                data.texture.render();\r\n            });\r\n            babylonLayer.renderTargetTextures.push(data.texture);\r\n            babylonLayer.renderOnlyInRenderTargetTextures = true;\r\n            // add it back when the session ends\r\n            this._xrSessionManager.onXRSessionEnded.addOnce(() => {\r\n                babylonLayer.renderTargetTextures.splice(babylonLayer.renderTargetTextures.indexOf(data.texture), 1);\r\n                babylonLayer.renderOnlyInRenderTargetTextures = false;\r\n            });\r\n        });\r\n        return wrapper;\r\n    }\r\n\r\n    /**\r\n     * @experimental\r\n     * This functions allows you to add a lens flare system to the XR scene.\r\n     * Note - this will remove the lens flare system from the scene and add it to the XR scene.\r\n     * This feature is experimental and might change in the future.\r\n     * @param flareSystem the flare system to add\r\n     * @returns a composition layer containing the flare system\r\n     */\r\n    protected _addLensFlareSystem(flareSystem: LensFlareSystem): WebXRCompositionLayerWrapper {\r\n        const wrapper = this._createQuadLayer({\r\n            params: {\r\n                space: this._xrSessionManager.viewerReferenceSpace,\r\n                textureType: \"texture\",\r\n                layout: \"mono\",\r\n            },\r\n        });\r\n\r\n        const layer = wrapper.layer as XRQuadLayer;\r\n        layer.width = 2;\r\n        layer.height = 1;\r\n        const distance = 10;\r\n        const pos = { x: 0, y: 0, z: -distance };\r\n        const orient = { x: 0, y: 0, z: 0, w: 1 };\r\n        layer.transform = new XRRigidTransform(pos, orient);\r\n\r\n        // get the rtt wrapper\r\n        const rttProvider = this._layerToRTTProviderMapping.get(layer);\r\n        if (!rttProvider) {\r\n            throw new Error(\"Could not find the RTT provider for the layer\");\r\n        }\r\n        // render the flare system to the rtt\r\n        rttProvider.onRenderTargetTextureCreatedObservable.add((data) => {\r\n            data.texture.clearColor = new Color4(0, 0, 0, 0);\r\n            data.texture.customRenderFunction = () => {\r\n                flareSystem.render();\r\n            };\r\n\r\n            // add to the scene's render targets\r\n            // this._xrSessionManager.scene.onBeforeCameraRenderObservable.add(() => {\r\n            //     data.texture.render();\r\n            // });\r\n        });\r\n        // remove the lens flare system from the scene\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._xrSessionManager.scene.lensFlareSystems.splice(this._xrSessionManager.scene.lensFlareSystems.indexOf(flareSystem), 1);\r\n        });\r\n        // add it back when the session ends\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._xrSessionManager.scene.lensFlareSystems.push(flareSystem);\r\n        });\r\n\r\n        return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Add a new layer to the already-existing list of layers\r\n     * @param wrappedLayer the new layer to add to the existing ones\r\n     */\r\n    public addXRSessionLayer(wrappedLayer: WebXRLayerWrapper) {\r\n        this._existingLayers.push(wrappedLayer);\r\n        this.setXRSessionLayers(this._existingLayers);\r\n    }\r\n\r\n    /**\r\n     * Sets the layers to be used by the XR session.\r\n     * Note that you must call this function with any layers you wish to render to\r\n     * since it adds them to the XR session's render state\r\n     * (replacing any layers that were added in a previous call to setXRSessionLayers or updateRenderState).\r\n     * This method also sets up the session manager's render target texture provider\r\n     * as the first layer in the array, which feeds the WebXR camera(s) attached to the session.\r\n     * @param wrappedLayers An array of WebXRLayerWrapper, usually returned from the WebXRLayers createLayer functions.\r\n     */\r\n    public setXRSessionLayers(wrappedLayers: Array<WebXRLayerWrapper> = this._existingLayers): void {\r\n        // this._existingLayers = wrappedLayers;\r\n        const renderStateInit: XRRenderStateInit = { ...this._xrSessionManager.session.renderState };\r\n        // Clear out the layer-related fields.\r\n        renderStateInit.baseLayer = undefined;\r\n        renderStateInit.layers = wrappedLayers.map((wrappedLayer) => wrappedLayer.layer);\r\n        this._xrSessionManager.updateRenderState(renderStateInit);\r\n        if (!this._projectionLayerInitialized) {\r\n            this._xrSessionManager._setBaseLayerWrapper(wrappedLayers.length > 0 ? wrappedLayers.at(0)! : null);\r\n        }\r\n    }\r\n\r\n    public isCompatible(): boolean {\r\n        // TODO (rgerd): Add native support.\r\n        return !this._xrSessionManager.isNative && typeof XRWebGLBinding !== \"undefined\" && !!XRWebGLBinding.prototype.createProjectionLayer;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        // Replace once the mapped internal texture of each available composition layer, apart from the last one, which is the projection layer that needs an RTT\r\n        const layers = this._existingLayers;\r\n        for (let i = 0; i < layers.length; ++i) {\r\n            const layer = layers[i];\r\n            if (layer.layerType !== \"XRProjectionLayer\") {\r\n                // get the rtt provider\r\n                const rttProvider = this._layerToRTTProviderMapping.get(layer.layer as XRCompositionLayer);\r\n                if (!rttProvider) {\r\n                    continue;\r\n                }\r\n\r\n                if (rttProvider.layerWrapper.isMultiview) {\r\n                    // get the views, if we are in multiview\r\n                    const pose = _xrFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n                    if (pose) {\r\n                        const views = pose.views;\r\n                        for (let j = 0; j < views.length; ++j) {\r\n                            const view = views[j];\r\n                            rttProvider.getRenderTargetTextureForView(view);\r\n                        }\r\n                    }\r\n                } else {\r\n                    rttProvider.getRenderTargetTextureForView();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRLayers.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRLayers(xrSessionManager, options);\r\n    },\r\n    WebXRLayers.Version,\r\n    false\r\n);\r\n", "import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            creationFlags?: number,\r\n            useSRGBBuffer?: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    } else {\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n        const level = 0;\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            if (compression) {\r\n                gl.compressedTexImage2D(\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    level,\r\n                    (<any>this.getCaps().s3tc)[compression],\r\n                    texture.width,\r\n                    texture.height,\r\n                    0,\r\n                    undefined as any\r\n                );\r\n            } else {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n", "import { RawTexture } from \"../../Materials/Textures/rawTexture\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\n\r\nexport type WebXRDepthUsage = \"cpu\" | \"gpu\";\r\nexport type WebXRDepthDataFormat = \"ushort\" | \"float\";\r\n\r\n/**\r\n * Options for Depth Sensing feature\r\n */\r\nexport interface IWebXRDepthSensingOptions {\r\n    /**\r\n     *  The desired depth sensing usage for the session\r\n     */\r\n    usagePreference: WebXRDepthUsage[];\r\n    /**\r\n     * The desired depth sensing data format for the session\r\n     */\r\n    dataFormatPreference: WebXRDepthDataFormat[];\r\n}\r\n\r\ntype GetDepthInMetersType = (x: number, y: number) => number;\r\n\r\n/**\r\n * WebXR Feature for WebXR Depth Sensing Module\r\n * @since 5.49.1\r\n */\r\nexport class WebXRDepthSensing extends WebXRAbstractFeature {\r\n    private _width: Nullable<number> = null;\r\n    private _height: Nullable<number> = null;\r\n    private _rawValueToMeters: Nullable<number> = null;\r\n    private _normDepthBufferFromNormView: Nullable<XRRigidTransform> = null;\r\n    private _cachedDepthBuffer: Nullable<ArrayBuffer> = null;\r\n    private _cachedWebGLTexture: Nullable<WebGLTexture> = null;\r\n    private _cachedDepthImageTexture: Nullable<RawTexture> = null;\r\n\r\n    /**\r\n     * Width of depth data. If depth data is not exist, returns null.\r\n     */\r\n    public get width(): Nullable<number> {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Height of depth data. If depth data is not exist, returns null.\r\n     */\r\n    public get height(): Nullable<number> {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * Scale factor by which the raw depth values must be multiplied in order to get the depths in meters.\r\n     */\r\n    public get rawValueToMeters(): Nullable<number> {\r\n        return this._rawValueToMeters;\r\n    }\r\n\r\n    /**\r\n     * An XRRigidTransform that needs to be applied when indexing into the depth buffer.\r\n     */\r\n    public get normDepthBufferFromNormView(): Nullable<XRRigidTransform> {\r\n        return this._normDepthBufferFromNormView;\r\n    }\r\n\r\n    /**\r\n     * Describes which depth-sensing usage (\"cpu\" or \"gpu\") is used.\r\n     */\r\n    public get depthUsage(): WebXRDepthUsage {\r\n        switch (this._xrSessionManager.session.depthUsage) {\r\n            case \"cpu-optimized\":\r\n                return \"cpu\";\r\n            case \"gpu-optimized\":\r\n                return \"gpu\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Describes which depth sensing data format (\"ushort\" or \"float\") is used.\r\n     */\r\n    public get depthDataFormat(): WebXRDepthDataFormat {\r\n        switch (this._xrSessionManager.session.depthDataFormat) {\r\n            case \"luminance-alpha\":\r\n                return \"ushort\";\r\n            case \"float32\":\r\n                return \"float\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Latest cached InternalTexture which containing depth buffer information.\r\n     * This can be used when the depth usage is \"gpu\".\r\n     */\r\n    public get latestInternalTexture(): Nullable<InternalTexture> {\r\n        if (!this._cachedWebGLTexture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._xrSessionManager.scene.getEngine();\r\n        const internalTexture = new InternalTexture(engine, InternalTextureSource.Unknown);\r\n        internalTexture.isCube = false;\r\n        internalTexture.invertY = false;\r\n        internalTexture._useSRGBBuffer = false;\r\n        internalTexture.format = this.depthDataFormat === \"ushort\" ? Constants.TEXTUREFORMAT_LUMINANCE_ALPHA : Constants.TEXTUREFORMAT_RGBA;\r\n        internalTexture.generateMipMaps = false;\r\n        internalTexture.type = this.depthDataFormat === \"ushort\" ? Constants.TEXTURETYPE_UNSIGNED_SHORT : Constants.TEXTURETYPE_FLOAT;\r\n        internalTexture.samplingMode = Constants.TEXTURE_NEAREST_LINEAR;\r\n        internalTexture.width = this.width ?? 0;\r\n        internalTexture.height = this.height ?? 0;\r\n        internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(this._cachedWebGLTexture, engine._gl);\r\n\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * cached depth buffer\r\n     */\r\n    public get latestDepthBuffer(): Nullable<ArrayBufferView> {\r\n        if (!this._cachedDepthBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this.depthDataFormat === \"ushort\" ? new Uint16Array(this._cachedDepthBuffer) : new Float32Array(this._cachedDepthBuffer);\r\n    }\r\n\r\n    /**\r\n     * Event that notify when `DepthInformation.getDepthInMeters` is available.\r\n     * `getDepthInMeters` method needs active XRFrame (not available for cached XRFrame)\r\n     */\r\n    public onGetDepthInMetersAvailable: Observable<GetDepthInMetersType> = new Observable<GetDepthInMetersType>();\r\n\r\n    /**\r\n     * Latest cached Texture of depth image which is made from the depth buffer data.\r\n     */\r\n    public get latestDepthImageTexture(): Nullable<RawTexture> {\r\n        return this._cachedDepthImageTexture;\r\n    }\r\n\r\n    /**\r\n     * XRWebGLBinding which is used for acquiring WebGLDepthInformation\r\n     */\r\n    private _glBinding?: XRWebGLBinding;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.DEPTH_SENSING;\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Creates a new instance of the depth sensing feature\r\n     * @param _xrSessionManager the WebXRSessionManager\r\n     * @param options options for WebXR Depth Sensing Feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        public readonly options: IWebXRDepthSensingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"depth-sensing\";\r\n\r\n        // https://immersive-web.github.io/depth-sensing/\r\n        Tools.Warn(\"depth-sensing is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    public attach(force?: boolean | undefined): boolean {\r\n        if (!super.attach(force)) {\r\n            return false;\r\n        }\r\n\r\n        const isBothDepthUsageAndFormatNull = this._xrSessionManager.session.depthDataFormat == null || this._xrSessionManager.session.depthUsage == null;\r\n        if (isBothDepthUsageAndFormatNull) {\r\n            return false;\r\n        }\r\n\r\n        this._glBinding = new XRWebGLBinding(this._xrSessionManager.session, this._xrSessionManager.scene.getEngine()._gl);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._cachedDepthImageTexture?.dispose();\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        const referenceSPace = this._xrSessionManager.referenceSpace;\r\n\r\n        const pose = _xrFrame.getViewerPose(referenceSPace);\r\n        if (pose == null) {\r\n            return;\r\n        }\r\n\r\n        for (const view of pose.views) {\r\n            switch (this.depthUsage) {\r\n                case \"cpu\":\r\n                    this._updateDepthInformationAndTextureCPUDepthUsage(_xrFrame, view, this.depthDataFormat);\r\n                    break;\r\n\r\n                case \"gpu\":\r\n                    if (!this._glBinding) {\r\n                        break;\r\n                    }\r\n\r\n                    this._updateDepthInformationAndTextureWebGLDepthUsage(this._glBinding, view, this.depthDataFormat);\r\n                    break;\r\n\r\n                default:\r\n                    Tools.Error(\"Unknown depth usage\");\r\n                    this.detach();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateDepthInformationAndTextureCPUDepthUsage(frame: XRFrame, view: XRView, dataFormat: WebXRDepthDataFormat): void {\r\n        const depthInfo = frame.getDepthInformation(view);\r\n        if (depthInfo === null) {\r\n            return;\r\n        }\r\n\r\n        const { data, width, height, rawValueToMeters, getDepthInMeters } = depthInfo as XRCPUDepthInformation;\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._rawValueToMeters = rawValueToMeters;\r\n        this._cachedDepthBuffer = data;\r\n\r\n        // to avoid Illegal Invocation error, bind `this`\r\n        this.onGetDepthInMetersAvailable.notifyObservers(getDepthInMeters.bind(depthInfo));\r\n\r\n        if (!this._cachedDepthImageTexture) {\r\n            this._cachedDepthImageTexture = RawTexture.CreateRTexture(\r\n                null,\r\n                width,\r\n                height,\r\n                this._xrSessionManager.scene,\r\n                false,\r\n                true,\r\n                Texture.NEAREST_SAMPLINGMODE,\r\n                Engine.TEXTURETYPE_FLOAT\r\n            );\r\n        }\r\n\r\n        switch (dataFormat) {\r\n            case \"ushort\":\r\n                this._cachedDepthImageTexture.update(Float32Array.from(new Uint16Array(data)).map((value) => value * rawValueToMeters));\r\n                break;\r\n\r\n            case \"float\":\r\n                this._cachedDepthImageTexture.update(new Float32Array(data).map((value) => value * rawValueToMeters));\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _updateDepthInformationAndTextureWebGLDepthUsage(webglBinding: XRWebGLBinding, view: XRView, dataFormat: WebXRDepthDataFormat): void {\r\n        const depthInfo = webglBinding.getDepthInformation(view);\r\n        if (depthInfo === null) {\r\n            return;\r\n        }\r\n\r\n        const { texture, width, height } = depthInfo as XRWebGLDepthInformation;\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._cachedWebGLTexture = texture;\r\n\r\n        const scene = this._xrSessionManager.scene;\r\n        const engine = scene.getEngine();\r\n        const internalTexture = engine.wrapWebGLTexture(texture);\r\n\r\n        if (!this._cachedDepthImageTexture) {\r\n            this._cachedDepthImageTexture = RawTexture.CreateRTexture(\r\n                null,\r\n                width,\r\n                height,\r\n                scene,\r\n                false,\r\n                true,\r\n                Texture.NEAREST_SAMPLINGMODE,\r\n                dataFormat === \"ushort\" ? Engine.TEXTURETYPE_UNSIGNED_BYTE : Engine.TEXTURETYPE_FLOAT\r\n            );\r\n        }\r\n\r\n        this._cachedDepthImageTexture._texture = internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object for the xr session init object.\r\n     */\r\n    public getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        const isDepthUsageDeclared = this.options.usagePreference != null && this.options.usagePreference.length !== 0;\r\n        const isDataFormatDeclared = this.options.dataFormatPreference != null && this.options.dataFormatPreference.length !== 0;\r\n\r\n        return new Promise((resolve) => {\r\n            if (isDepthUsageDeclared && isDataFormatDeclared) {\r\n                const usages: XRDepthUsage[] = this.options.usagePreference.map((usage) => {\r\n                    switch (usage) {\r\n                        case \"cpu\":\r\n                            return \"cpu-optimized\";\r\n                        case \"gpu\":\r\n                            return \"gpu-optimized\";\r\n                    }\r\n                });\r\n                const dataFormats: XRDepthDataFormat[] = this.options.dataFormatPreference.map((format) => {\r\n                    switch (format) {\r\n                        case \"ushort\":\r\n                            return \"luminance-alpha\";\r\n                        case \"float\":\r\n                            return \"float32\";\r\n                    }\r\n                });\r\n\r\n                resolve({\r\n                    depthSensing: {\r\n                        usagePreference: usages,\r\n                        dataFormatPreference: dataFormats,\r\n                    },\r\n                });\r\n            } else {\r\n                resolve({});\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRDepthSensing.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRDepthSensing(xrSessionManager, options);\r\n    },\r\n    WebXRDepthSensing.Version,\r\n    false\r\n);\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"velocityPixelShader\";\nconst shader = `precision highp float;\n#define CUSTOM_FRAGMENT_BEGIN\nvarying vec4 clipPos;varying vec4 previousClipPos;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nhighp vec4 motionVector=( clipPos/clipPos.w-previousClipPos/previousClipPos.w );gl_FragColor=motionVector;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const velocityPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\n\nconst name = \"velocityVertexShader\";\nconst shader = `#define CUSTOM_VERTEX_BEGIN\n#define VELOCITY\nattribute vec3 position;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform mat4 previousViewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;uniform mat4 previousViewProjectionR;\n#endif\nvarying vec4 clipPos;varying vec4 previousClipPos;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vec4 previousWorldPos=finalPreviousWorld*vec4(positionUpdated,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {clipPos=viewProjection*worldPos;previousClipPos=previousViewProjection*previousWorldPos;gl_Position=clipPos;} else {clipPos=viewProjectionR*worldPos;previousClipPos=previousViewProjectionR*previousWorldPos;gl_Position=clipPos;}\n#elif\nclipPos=viewProjection*worldPos;previousClipPos=previousViewProjection*previousWorldPos;gl_Position=clipPos;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const velocityVertexShader = { name, shader };\n", "import type { Engine } from \"../../Engines/engine\";\r\nimport type { WebGLRenderTargetWrapper } from \"../../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IWebXRRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\nimport \"../../Shaders/velocity.fragment\";\r\nimport \"../../Shaders/velocity.vertex\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\n\r\n/**\r\n * Used for Space Warp render process\r\n */\r\nexport class XRSpaceWarpRenderTarget extends RenderTargetTexture {\r\n    private _velocityMaterial: ShaderMaterial;\r\n    private _originalPairing: Array<[AbstractMesh, Nullable<Material>]> = [];\r\n    private _previousWorldMatrices: Array<Matrix> = [];\r\n    private _previousTransforms: Matrix[] = [Matrix.Identity(), Matrix.Identity()];\r\n\r\n    /**\r\n     * Creates a Space Warp render target\r\n     * @param motionVectorTexture WebGLTexture provided by WebGLSubImage\r\n     * @param depthStencilTexture WebGLTexture provided by WebGLSubImage\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(motionVectorTexture: WebGLTexture, depthStencilTexture: WebGLTexture, scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"spacewarp rtt\", size, scene, false, true, Constants.TEXTURETYPE_HALF_FLOAT, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = this.getScene()!\r\n            .getEngine()\r\n            .createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight(), motionVectorTexture, depthStencilTexture);\r\n        (this._renderTarget as WebGLRenderTargetWrapper)._disposeOnlyFramebuffers = true;\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        if (scene) {\r\n            this._velocityMaterial = new ShaderMaterial(\r\n                \"velocity shader material\",\r\n                scene,\r\n                {\r\n                    vertex: \"velocity\",\r\n                    fragment: \"velocity\",\r\n                },\r\n                {\r\n                    uniforms: [\"world\", \"previousWorld\", \"viewProjection\", \"viewProjectionR\", \"previousViewProjection\", \"previousViewProjectionR\"],\r\n                }\r\n            );\r\n            this._velocityMaterial._materialHelperNeedsPreviousMatrices = true;\r\n            this._velocityMaterial.onBindObservable.add((mesh) => {\r\n                // mesh. getWorldMatrix can be incorrect under rare conditions (e.g. when using a effective mesh in the render function).\r\n                // If the case arise that will require changing it we will need to change the bind process in the material class to also provide the world matrix as a parameter\r\n                this._previousWorldMatrices[mesh.uniqueId] = this._previousWorldMatrices[mesh.uniqueId] || mesh.getWorldMatrix();\r\n                this._velocityMaterial.getEffect().setMatrix(\"previousWorld\", this._previousWorldMatrices[mesh.uniqueId]);\r\n                this._previousWorldMatrices[mesh.uniqueId] = mesh.getWorldMatrix();\r\n                // now set the scene's previous matrix\r\n                this._velocityMaterial.getEffect().setMatrix(\"previousViewProjection\", this._previousTransforms[0]);\r\n                // multiview for sure\r\n                this._velocityMaterial.getEffect().setMatrix(\"previousViewProjectionR\", this._previousTransforms[1]);\r\n\r\n                // store the previous (current, to be exact) transforms\r\n                this._previousTransforms[0].copyFrom(scene.getTransformMatrix());\r\n                this._previousTransforms[1].copyFrom(scene._transformMatrixR);\r\n            });\r\n            this._velocityMaterial.freeze();\r\n        }\r\n    }\r\n\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        // Swap to use velocity material\r\n        this._originalPairing.length = 0;\r\n        const scene = this.getScene();\r\n        // set the velocity material to render the velocity RTT\r\n        if (scene && this._velocityMaterial) {\r\n            scene.getActiveMeshes().forEach((mesh) => {\r\n                this._originalPairing.push([mesh, mesh.material]);\r\n                mesh.material = this._velocityMaterial;\r\n            });\r\n        }\r\n\r\n        super.render(useCameraPostProcess, dumpForDebug);\r\n\r\n        // Restore original materials\r\n        this._originalPairing.forEach((tuple) => {\r\n            tuple[0].material = tuple[1];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        this.getScene()!.getEngine().bindSpaceWarpFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a SpaceWarpRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 2;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._velocityMaterial.dispose();\r\n        this._previousTransforms.length = 0;\r\n        this._previousWorldMatrices.length = 0;\r\n        this._originalPairing.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Space Warp Render Target Texture Provider\r\n */\r\nexport class WebXRSpaceWarpRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    protected _lastSubImages = new Map<XRView, XRWebGLSubImage>();\r\n    protected _renderTargetTextures = new Map<XREye, RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n    protected _engine: Engine;\r\n\r\n    constructor(\r\n        protected readonly _scene: Scene,\r\n        protected readonly _xrSessionManager: WebXRSessionManager,\r\n        protected readonly _xrWebGLBinding: XRWebGLBinding\r\n    ) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _getSubImageForView(view: XRView): XRWebGLSubImage {\r\n        const layerWrapper = this._xrSessionManager._getBaseLayerWrapper();\r\n        if (!layerWrapper) {\r\n            throw new Error(\"For Space Warp, the base layer should be a WebXR Projection Layer.\");\r\n        }\r\n        if (layerWrapper.layerType !== \"XRProjectionLayer\") {\r\n            throw new Error('For Space Warp, the base layer type should \"XRProjectionLayer\".');\r\n        }\r\n        const layer = layerWrapper.layer as XRProjectionLayer;\r\n        return this._xrWebGLBinding.getViewSubImage(layer, view);\r\n    }\r\n\r\n    protected _setViewportForSubImage(viewport: Viewport, subImage: XRWebGLSubImage) {\r\n        viewport.x = 0;\r\n        viewport.y = 0;\r\n        viewport.width = subImage.motionVectorTextureWidth!;\r\n        viewport.height = subImage.motionVectorTextureHeight!;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        motionVectorTexture: WebGLTexture,\r\n        depthStencilTexture: WebGLTexture\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = new XRSpaceWarpRenderTarget(motionVectorTexture, depthStencilTexture, this._scene, textureSize);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        if (framebuffer) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        renderTargetWrapper._colorTextureArray = motionVectorTexture;\r\n        renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n\r\n        renderTargetTexture.disableRescaling();\r\n        renderTargetTexture.renderListPredicate = () => true;\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _getRenderTargetForSubImage(subImage: XRWebGLSubImage, view: XRView) {\r\n        const lastSubImage = this._lastSubImages.get(view);\r\n        let renderTargetTexture = this._renderTargetTextures.get(view.eye);\r\n\r\n        const width = subImage.motionVectorTextureWidth!;\r\n        const height = subImage.motionVectorTextureHeight!;\r\n\r\n        if (!renderTargetTexture || lastSubImage?.textureWidth !== width || lastSubImage?.textureHeight != height) {\r\n            renderTargetTexture = this._createRenderTargetTexture(width, height, null, subImage.motionVectorTexture!, subImage.depthStencilTexture!);\r\n            this._renderTargetTextures.set(view.eye, renderTargetTexture);\r\n\r\n            this._framebufferDimensions = {\r\n                framebufferWidth: width,\r\n                framebufferHeight: height,\r\n            };\r\n        }\r\n\r\n        this._lastSubImages.set(view, subImage);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const subImage = this._lastSubImages.get(view) || this._getSubImageForView(view);\r\n        if (subImage) {\r\n            this._setViewportForSubImage(viewport, subImage);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Access the motion vector (which will turn on Space Warp)\r\n     * @param view the view to access the motion vector texture for\r\n     */\r\n    public accessMotionVector(view: XRView): void {\r\n        const subImage = this._getSubImageForView(view);\r\n        if (subImage) {\r\n            // Meta Quest Browser uses accessing these textures as a sign for turning on Space Warp\r\n            subImage.motionVectorTexture;\r\n            subImage.depthStencilTexture;\r\n        }\r\n    }\r\n\r\n    public getRenderTargetTextureForEye(_eye: XREye): Nullable<RenderTargetTexture> {\r\n        return null;\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        const subImage = this._getSubImageForView(view);\r\n        if (subImage) {\r\n            return this._getRenderTargetForSubImage(subImage, view);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * the WebXR Space Warp feature.\r\n */\r\nexport class WebXRSpaceWarp extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.SPACE_WARP;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * The space warp provider\r\n     */\r\n    public spaceWarpRTTProvider: Nullable<WebXRSpaceWarpRenderTargetTextureProvider>;\r\n    private _glContext: WebGLRenderingContext | WebGL2RenderingContext;\r\n    private _xrWebGLBinding: XRWebGLBinding;\r\n    private _renderTargetTexture: Nullable<RenderTargetTexture>;\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * constructor for the space warp feature\r\n     * @param _xrSessionManager the xr session manager for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"space-warp\";\r\n        this._xrSessionManager.scene.needsPreviousWorldMatrices = true;\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._xrSessionManager.scene.getEngine();\r\n        this._glContext = engine._gl;\r\n        this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\r\n\r\n        this.spaceWarpRTTProvider = new WebXRSpaceWarpRenderTargetTextureProvider(this._xrSessionManager.scene, this._xrSessionManager, this._xrWebGLBinding);\r\n\r\n        this._onAfterRenderObserver = this._xrSessionManager.scene.onAfterRenderObservable.add(() => this._onAfterRender());\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        this._xrSessionManager.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        return super.detach();\r\n    }\r\n\r\n    private _onAfterRender(): void {\r\n        if (this.attached && this._renderTargetTexture) {\r\n            this._renderTargetTexture.render(false, false);\r\n        }\r\n    }\r\n\r\n    public dependsOn: string[] = [WebXRFeatureName.LAYERS];\r\n\r\n    public isCompatible(): boolean {\r\n        return this._xrSessionManager.scene.getEngine().getCaps().colorBufferHalfFloat || false;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        const pose = _xrFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n\r\n        // get the first view to which we will create a texture (or update it)\r\n        const view = pose.views[0];\r\n        this._renderTargetTexture = this._renderTargetTexture || this.spaceWarpRTTProvider!.getRenderTargetTextureForView(view);\r\n        this.spaceWarpRTTProvider!.accessMotionVector(view);\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRSpaceWarp.Name,\r\n    (xrSessionManager) => {\r\n        return () => new WebXRSpaceWarp(xrSessionManager);\r\n    },\r\n    WebXRSpaceWarp.Version,\r\n    false\r\n);\r\n", "import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\n/**\r\n * Options for raw camera access\r\n */\r\nexport interface IWebXRRawCameraAccessOptions {\r\n    /**\r\n     * Keep the created textures and metadata when detaching the feature.\r\n     */\r\n    doNotDisposeOnDetach?: boolean;\r\n}\r\n\r\n/**\r\n * WebXR Feature for WebXR raw camera access\r\n * @since 6.31.0\r\n * @see https://immersive-web.github.io/raw-camera-access/\r\n */\r\nexport class WebXRRawCameraAccess extends WebXRAbstractFeature {\r\n    private _cachedInternalTextures: InternalTexture[] = [];\r\n    /**\r\n     * This is an array of camera views\r\n     * Note that mostly the array will contain a single view\r\n     * If you want to know the order of the views, use the `viewIndex` array\r\n     */\r\n    public texturesData: BaseTexture[] = [];\r\n    /**\r\n     * If needed, this array will contain the eye definition of each texture in `texturesArray`\r\n     */\r\n    public viewIndex: string[] = [];\r\n\r\n    /**\r\n     * If needed, this array will contain the camera's intrinsics\r\n     * You can use this data to convert from camera space to screen space and vice versa\r\n     */\r\n    public cameraIntrinsics: {\r\n        u0: number;\r\n        v0: number;\r\n        ax: number;\r\n        ay: number;\r\n        gamma: number;\r\n        width: number;\r\n        height: number;\r\n        viewportX: number;\r\n        viewportY: number;\r\n    }[] = [];\r\n\r\n    /**\r\n     * An observable that will notify when the camera's textures are updated\r\n     */\r\n    public onTexturesUpdatedObservable: Observable<BaseTexture[]> = new Observable();\r\n\r\n    private _glBinding?: XRWebGLBinding;\r\n    private _glContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.RAW_CAMERA_ACCESS;\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Creates a new instance of the feature\r\n     * @param _xrSessionManager the WebXRSessionManager\r\n     * @param options options for the Feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        public readonly options: IWebXRRawCameraAccessOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"camera-access\";\r\n    }\r\n\r\n    public attach(force?: boolean | undefined): boolean {\r\n        if (!super.attach(force)) {\r\n            return false;\r\n        }\r\n\r\n        this._glContext = this._xrSessionManager.scene.getEngine()._gl;\r\n        this._glBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        this._glBinding = undefined;\r\n        if (!this.options.doNotDisposeOnDetach) {\r\n            this._cachedInternalTextures.forEach((t) => t.dispose());\r\n            this.texturesData.forEach((t) => t.dispose());\r\n            this._cachedInternalTextures.length = 0;\r\n            this.texturesData.length = 0;\r\n            this.cameraIntrinsics.length = 0;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onTexturesUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @see https://github.com/immersive-web/raw-camera-access/blob/main/explainer.md\r\n     * @param view the XRView to update\r\n     * @param index the index of the view in the views array\r\n     */\r\n    private _updateCameraIntrinsics(view: XRView, index: number): void {\r\n        const cameraViewport = {\r\n            width: view.camera!.width,\r\n            height: view.camera!.height,\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        const p = view.projectionMatrix;\r\n\r\n        // Principal point in pixels (typically at or near the center of the viewport)\r\n        const u0 = ((1 - p[8]) * cameraViewport.width) / 2 + cameraViewport.x;\r\n        const v0 = ((1 - p[9]) * cameraViewport.height) / 2 + cameraViewport.y;\r\n\r\n        // Focal lengths in pixels (these are equal for square pixels)\r\n        const ax = (cameraViewport.width / 2) * p[0];\r\n        const ay = (cameraViewport.height / 2) * p[5];\r\n\r\n        // Skew factor in pixels (nonzero for rhomboid pixels)\r\n        const gamma = (cameraViewport.width / 2) * p[4];\r\n        this.cameraIntrinsics[index] = {\r\n            u0,\r\n            v0,\r\n            ax,\r\n            ay,\r\n            gamma,\r\n            width: cameraViewport.width,\r\n            height: cameraViewport.height,\r\n            viewportX: cameraViewport.x,\r\n            viewportY: cameraViewport.y,\r\n        };\r\n    }\r\n\r\n    private _updateInternalTextures(view: XRView, index = 0): boolean {\r\n        if (!view.camera) {\r\n            return false;\r\n        }\r\n        this.viewIndex[index] = view.eye;\r\n        const lp = this._glBinding?.getCameraImage(view.camera);\r\n\r\n        if (!this._cachedInternalTextures[index]) {\r\n            const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown, true);\r\n            internalTexture.isCube = true;\r\n            internalTexture.invertY = false;\r\n            // internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\r\n            internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            internalTexture.generateMipMaps = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n            internalTexture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n            internalTexture.width = view.camera.width;\r\n            internalTexture.height = view.camera.height;\r\n            internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n            internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n            internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._glContext);\r\n            this._cachedInternalTextures[index] = internalTexture;\r\n            // create the base texture\r\n            const texture = new BaseTexture(this._xrSessionManager.scene);\r\n            texture.name = `WebXR Raw Camera Access (${index})`;\r\n            texture._texture = this._cachedInternalTextures[index];\r\n            this.texturesData[index] = texture;\r\n            // get the camera intrinsics\r\n            this._updateCameraIntrinsics(view, index);\r\n        } else {\r\n            // make sure the webgl texture is updated. Should happen automatically\r\n            this._cachedInternalTextures[index]._hardwareTexture?.set(lp);\r\n        }\r\n        this._cachedInternalTextures[index].isReady = true;\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        const referenceSPace = this._xrSessionManager.referenceSpace;\r\n\r\n        const pose = _xrFrame.getViewerPose(referenceSPace);\r\n        if (!pose || !pose.views) {\r\n            return;\r\n        }\r\n        let updated = true;\r\n        pose.views.forEach((view, index) => {\r\n            updated = updated && this._updateInternalTextures(view, index);\r\n        });\r\n        if (updated) {\r\n            this.onTexturesUpdatedObservable.notifyObservers(this.texturesData);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRRawCameraAccess.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRRawCameraAccess(xrSessionManager, options);\r\n    },\r\n    WebXRRawCameraAccess.Version,\r\n    false\r\n);\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { IMotionControllerLayoutMap, IMinimalMotionControllerObject, MotionControllerHandedness } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { WebXRMotionControllerManager } from \"./webXRMotionControllerManager\";\r\n\r\n/**\r\n * A generic hand controller class that supports select and a secondary grasp\r\n */\r\nexport class WebXRGenericHandController extends WebXRAbstractMotionController {\r\n    public profileId = \"generic-hand-select-grasp\";\r\n\r\n    /**\r\n     * Create a new hand controller object, without loading a controller model\r\n     * @param scene the scene to use to create this controller\r\n     * @param gamepadObject the corresponding gamepad object\r\n     * @param handedness the handedness of the controller\r\n     */\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        // Don't load the controller model - for now, hands have no real model.\r\n        super(scene, GenericHandSelectGraspProfile[handedness], gamepadObject, handedness, true);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        // no-op\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        // no-op\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op\r\n    }\r\n}\r\n\r\n// register the profiles\r\nWebXRMotionControllerManager.RegisterController(\"generic-hand-select-grasp\", (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRGenericHandController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// https://github.com/immersive-web/webxr-input-profiles/blob/main/packages/registry/profiles/generic/generic-hand-select-grasp.json\r\nconst GenericHandSelectGraspProfile: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr-standard-trigger\",\r\n                visualResponses: {},\r\n            },\r\n            grasp: {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"grasp\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-hand-select-grasp-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr-standard-trigger\",\r\n                visualResponses: {},\r\n            },\r\n            grasp: {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"grasp\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-hand-select-grasp-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n    none: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr-standard-trigger\",\r\n                visualResponses: {},\r\n            },\r\n            grasp: {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"grasp\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-hand-select-grasp-none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IMinimalMotionControllerObject, MotionControllerHandedness, IMotionControllerLayoutMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport { WebXRMotionControllerManager } from \"./webXRMotionControllerManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\n/**\r\n * The motion controller class for all microsoft mixed reality controllers\r\n */\r\nexport class WebXRMicrosoftMixedRealityController extends WebXRAbstractMotionController {\r\n    // use this in the future - https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets/profiles/microsoft\r\n    protected readonly _mapping = {\r\n        defaultButton: {\r\n            valueNodeName: \"VALUE\",\r\n            unpressedNodeName: \"UNPRESSED\",\r\n            pressedNodeName: \"PRESSED\",\r\n        },\r\n        defaultAxis: {\r\n            valueNodeName: \"VALUE\",\r\n            minNodeName: \"MIN\",\r\n            maxNodeName: \"MAX\",\r\n        },\r\n        buttons: {\r\n            \"xr-standard-trigger\": {\r\n                rootNodeName: \"SELECT\",\r\n                componentProperty: \"button\",\r\n                states: [\"default\", \"touched\", \"pressed\"],\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                rootNodeName: \"GRASP\",\r\n                componentProperty: \"state\",\r\n                states: [\"pressed\"],\r\n            },\r\n            \"xr-standard-touchpad\": {\r\n                rootNodeName: \"TOUCHPAD_PRESS\",\r\n                labelAnchorNodeName: \"squeeze-label\",\r\n                touchPointNodeName: \"TOUCH\", // TODO - use this for visual feedback\r\n            },\r\n            \"xr-standard-thumbstick\": {\r\n                rootNodeName: \"THUMBSTICK_PRESS\",\r\n                componentProperty: \"state\",\r\n                states: [\"pressed\"],\r\n            },\r\n        },\r\n        axes: {\r\n            \"xr-standard-touchpad\": {\r\n                \"x-axis\": {\r\n                    rootNodeName: \"TOUCHPAD_TOUCH_X\",\r\n                },\r\n                \"y-axis\": {\r\n                    rootNodeName: \"TOUCHPAD_TOUCH_Y\",\r\n                },\r\n            },\r\n            \"xr-standard-thumbstick\": {\r\n                \"x-axis\": {\r\n                    rootNodeName: \"THUMBSTICK_X\",\r\n                },\r\n                \"y-axis\": {\r\n                    rootNodeName: \"THUMBSTICK_Y\",\r\n                },\r\n            },\r\n        },\r\n    };\r\n\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/microsoft/\";\r\n    /**\r\n     * The name of the left controller model file\r\n     */\r\n    public static MODEL_LEFT_FILENAME: string = \"left.glb\";\r\n    /**\r\n     * The name of the right controller model file\r\n     */\r\n    public static MODEL_RIGHT_FILENAME: string = \"right.glb\";\r\n\r\n    public profileId = \"microsoft-mixed-reality\";\r\n\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        super(scene, MixedRealityProfile[\"left-right\"], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        let filename = \"\";\r\n        if (this.handedness === \"left\") {\r\n            filename = WebXRMicrosoftMixedRealityController.MODEL_LEFT_FILENAME;\r\n        } else {\r\n            // Right is the default if no hand is specified\r\n            filename = WebXRMicrosoftMixedRealityController.MODEL_RIGHT_FILENAME;\r\n        }\r\n\r\n        const device = \"default\";\r\n        const path = WebXRMicrosoftMixedRealityController.MODEL_BASE_URL + device + \"/\";\r\n        return {\r\n            filename,\r\n            path,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(\".glb\");\r\n        if (!glbLoaded) {\r\n            Logger.Warn(\"glTF / glb loaded was not registered, using generic controller instead\");\r\n        }\r\n        return glbLoaded;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        if (!this.rootMesh) {\r\n            return;\r\n        }\r\n\r\n        // Button Meshes\r\n        this.getComponentIds().forEach((id, i) => {\r\n            if (this.disableAnimation) {\r\n                return;\r\n            }\r\n            if (id && this.rootMesh) {\r\n                const buttonMap = (<any>this._mapping.buttons)[id];\r\n                const buttonMeshName = buttonMap.rootNodeName;\r\n                if (!buttonMeshName) {\r\n                    Logger.Log(\"Skipping unknown button at index: \" + i + \" with mapped name: \" + id);\r\n                    return;\r\n                }\r\n\r\n                const buttonMesh = this._getChildByName(this.rootMesh, buttonMeshName);\r\n                if (!buttonMesh) {\r\n                    Logger.Warn(\"Missing button mesh with name: \" + buttonMeshName);\r\n                    return;\r\n                }\r\n\r\n                buttonMap.valueMesh = this._getImmediateChildByName(buttonMesh, this._mapping.defaultButton.valueNodeName);\r\n                buttonMap.pressedMesh = this._getImmediateChildByName(buttonMesh, this._mapping.defaultButton.pressedNodeName);\r\n                buttonMap.unpressedMesh = this._getImmediateChildByName(buttonMesh, this._mapping.defaultButton.unpressedNodeName);\r\n\r\n                if (buttonMap.valueMesh && buttonMap.pressedMesh && buttonMap.unpressedMesh) {\r\n                    const comp = this.getComponent(id);\r\n                    if (comp) {\r\n                        comp.onButtonStateChangedObservable.add(\r\n                            (component) => {\r\n                                this._lerpTransform(buttonMap, component.value);\r\n                            },\r\n                            undefined,\r\n                            true\r\n                        );\r\n                    }\r\n                } else {\r\n                    // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\r\n                    Logger.Warn(\"Missing button submesh under mesh with name: \" + buttonMeshName);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Axis Meshes\r\n        this.getComponentIds().forEach((id) => {\r\n            const comp = this.getComponent(id);\r\n            if (!comp.isAxes()) {\r\n                return;\r\n            }\r\n\r\n            [\"x-axis\", \"y-axis\"].forEach((axis) => {\r\n                if (!this.rootMesh) {\r\n                    return;\r\n                }\r\n                const axisMap = (<any>this._mapping.axes)[id][axis];\r\n\r\n                const axisMesh = this._getChildByName(this.rootMesh, axisMap.rootNodeName);\r\n                if (!axisMesh) {\r\n                    Logger.Warn(\"Missing axis mesh with name: \" + axisMap.rootNodeName);\r\n                    return;\r\n                }\r\n\r\n                axisMap.valueMesh = this._getImmediateChildByName(axisMesh, this._mapping.defaultAxis.valueNodeName);\r\n                axisMap.minMesh = this._getImmediateChildByName(axisMesh, this._mapping.defaultAxis.minNodeName);\r\n                axisMap.maxMesh = this._getImmediateChildByName(axisMesh, this._mapping.defaultAxis.maxNodeName);\r\n\r\n                if (axisMap.valueMesh && axisMap.minMesh && axisMap.maxMesh) {\r\n                    if (comp) {\r\n                        comp.onAxisValueChangedObservable.add(\r\n                            (axisValues) => {\r\n                                const value = axis === \"x-axis\" ? axisValues.x : axisValues.y;\r\n                                this._lerpTransform(axisMap, value, true);\r\n                            },\r\n                            undefined,\r\n                            true\r\n                        );\r\n                    }\r\n                } else {\r\n                    // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\r\n                    Logger.Warn(\"Missing axis submesh under mesh with name: \" + axisMap.rootNodeName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n        this.rootMesh.isPickable = false;\r\n        let rootMesh;\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            mesh.isPickable = false;\r\n\r\n            if (!mesh.parent) {\r\n                // Handle root node, attach to the new parentMesh\r\n                rootMesh = mesh;\r\n            }\r\n        }\r\n\r\n        if (rootMesh) {\r\n            rootMesh.setParent(this.rootMesh);\r\n        }\r\n\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n        }\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op. model is updated using observables.\r\n    }\r\n}\r\n\r\n// register the profile\r\nWebXRMotionControllerManager.RegisterController(\"windows-mixed-reality\", (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRMicrosoftMixedRealityController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// https://github.com/immersive-web/webxr-input-profiles/blob/master/packages/registry/profiles/microsoft/microsoft-mixed-reality.json\r\nconst MixedRealityProfile: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {\r\n                    xr_standard_trigger_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_trigger_pressed_value\",\r\n                        minNodeName: \"xr_standard_trigger_pressed_min\",\r\n                        maxNodeName: \"xr_standard_trigger_pressed_max\",\r\n                    },\r\n                },\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {\r\n                    xr_standard_squeeze_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_squeeze_pressed_value\",\r\n                        minNodeName: \"xr_standard_squeeze_pressed_min\",\r\n                        maxNodeName: \"xr_standard_squeeze_pressed_max\",\r\n                    },\r\n                },\r\n            },\r\n            \"xr-standard-touchpad\": {\r\n                type: \"touchpad\",\r\n                gamepadIndices: {\r\n                    button: 2,\r\n                    xAxis: 0,\r\n                    yAxis: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_touchpad\",\r\n                visualResponses: {\r\n                    xr_standard_touchpad_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_pressed_value\",\r\n                        minNodeName: \"xr_standard_touchpad_pressed_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_pressed_max\",\r\n                    },\r\n                    xr_standard_touchpad_xaxis_pressed: {\r\n                        componentProperty: \"xAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_xaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_touchpad_xaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_xaxis_pressed_max\",\r\n                    },\r\n                    xr_standard_touchpad_yaxis_pressed: {\r\n                        componentProperty: \"yAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_yaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_touchpad_yaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_yaxis_pressed_max\",\r\n                    },\r\n                    xr_standard_touchpad_xaxis_touched: {\r\n                        componentProperty: \"xAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_xaxis_touched_value\",\r\n                        minNodeName: \"xr_standard_touchpad_xaxis_touched_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_xaxis_touched_max\",\r\n                    },\r\n                    xr_standard_touchpad_yaxis_touched: {\r\n                        componentProperty: \"yAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_yaxis_touched_value\",\r\n                        minNodeName: \"xr_standard_touchpad_yaxis_touched_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_yaxis_touched_max\",\r\n                    },\r\n                    xr_standard_touchpad_axes_touched: {\r\n                        componentProperty: \"state\",\r\n                        states: [\"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"visibility\",\r\n                        valueNodeName: \"xr_standard_touchpad_axes_touched_value\",\r\n                    },\r\n                },\r\n                touchPointNodeName: \"xr_standard_touchpad_axes_touched_value\",\r\n            },\r\n            \"xr-standard-thumbstick\": {\r\n                type: \"thumbstick\",\r\n                gamepadIndices: {\r\n                    button: 3,\r\n                    xAxis: 2,\r\n                    yAxis: 3,\r\n                },\r\n                rootNodeName: \"xr_standard_thumbstick\",\r\n                visualResponses: {\r\n                    xr_standard_thumbstick_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_thumbstick_pressed_value\",\r\n                        minNodeName: \"xr_standard_thumbstick_pressed_min\",\r\n                        maxNodeName: \"xr_standard_thumbstick_pressed_max\",\r\n                    },\r\n                    xr_standard_thumbstick_xaxis_pressed: {\r\n                        componentProperty: \"xAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_thumbstick_xaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_thumbstick_xaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_thumbstick_xaxis_pressed_max\",\r\n                    },\r\n                    xr_standard_thumbstick_yaxis_pressed: {\r\n                        componentProperty: \"yAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_thumbstick_yaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_thumbstick_yaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_thumbstick_yaxis_pressed_max\",\r\n                    },\r\n                },\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"microsoft-mixed-reality-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {\r\n                    xr_standard_trigger_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_trigger_pressed_value\",\r\n                        minNodeName: \"xr_standard_trigger_pressed_min\",\r\n                        maxNodeName: \"xr_standard_trigger_pressed_max\",\r\n                    },\r\n                },\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {\r\n                    xr_standard_squeeze_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_squeeze_pressed_value\",\r\n                        minNodeName: \"xr_standard_squeeze_pressed_min\",\r\n                        maxNodeName: \"xr_standard_squeeze_pressed_max\",\r\n                    },\r\n                },\r\n            },\r\n            \"xr-standard-touchpad\": {\r\n                type: \"touchpad\",\r\n                gamepadIndices: {\r\n                    button: 2,\r\n                    xAxis: 0,\r\n                    yAxis: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_touchpad\",\r\n                visualResponses: {\r\n                    xr_standard_touchpad_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_pressed_value\",\r\n                        minNodeName: \"xr_standard_touchpad_pressed_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_pressed_max\",\r\n                    },\r\n                    xr_standard_touchpad_xaxis_pressed: {\r\n                        componentProperty: \"xAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_xaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_touchpad_xaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_xaxis_pressed_max\",\r\n                    },\r\n                    xr_standard_touchpad_yaxis_pressed: {\r\n                        componentProperty: \"yAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_yaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_touchpad_yaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_yaxis_pressed_max\",\r\n                    },\r\n                    xr_standard_touchpad_xaxis_touched: {\r\n                        componentProperty: \"xAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_xaxis_touched_value\",\r\n                        minNodeName: \"xr_standard_touchpad_xaxis_touched_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_xaxis_touched_max\",\r\n                    },\r\n                    xr_standard_touchpad_yaxis_touched: {\r\n                        componentProperty: \"yAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_touchpad_yaxis_touched_value\",\r\n                        minNodeName: \"xr_standard_touchpad_yaxis_touched_min\",\r\n                        maxNodeName: \"xr_standard_touchpad_yaxis_touched_max\",\r\n                    },\r\n                    xr_standard_touchpad_axes_touched: {\r\n                        componentProperty: \"state\",\r\n                        states: [\"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"visibility\",\r\n                        valueNodeName: \"xr_standard_touchpad_axes_touched_value\",\r\n                    },\r\n                },\r\n                touchPointNodeName: \"xr_standard_touchpad_axes_touched_value\",\r\n            },\r\n            \"xr-standard-thumbstick\": {\r\n                type: \"thumbstick\",\r\n                gamepadIndices: {\r\n                    button: 3,\r\n                    xAxis: 2,\r\n                    yAxis: 3,\r\n                },\r\n                rootNodeName: \"xr_standard_thumbstick\",\r\n                visualResponses: {\r\n                    xr_standard_thumbstick_pressed: {\r\n                        componentProperty: \"button\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_thumbstick_pressed_value\",\r\n                        minNodeName: \"xr_standard_thumbstick_pressed_min\",\r\n                        maxNodeName: \"xr_standard_thumbstick_pressed_max\",\r\n                    },\r\n                    xr_standard_thumbstick_xaxis_pressed: {\r\n                        componentProperty: \"xAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_thumbstick_xaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_thumbstick_xaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_thumbstick_xaxis_pressed_max\",\r\n                    },\r\n                    xr_standard_thumbstick_yaxis_pressed: {\r\n                        componentProperty: \"yAxis\",\r\n                        states: [\"default\", \"touched\", \"pressed\"],\r\n                        valueNodeProperty: \"transform\",\r\n                        valueNodeName: \"xr_standard_thumbstick_yaxis_pressed_value\",\r\n                        minNodeName: \"xr_standard_thumbstick_yaxis_pressed_min\",\r\n                        maxNodeName: \"xr_standard_thumbstick_yaxis_pressed_max\",\r\n                    },\r\n                },\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"microsoft-mixed-reality-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IMinimalMotionControllerObject, MotionControllerHandedness, IMotionControllerLayoutMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport { WebXRMotionControllerManager } from \"./webXRMotionControllerManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\n\r\n/**\r\n * The motion controller class for oculus touch (quest, rift).\r\n * This class supports legacy mapping as well the standard xr mapping\r\n */\r\nexport class WebXROculusTouchMotionController extends WebXRAbstractMotionController {\r\n    private _modelRootNode: AbstractMesh;\r\n\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/oculus/\";\r\n    /**\r\n     * The name of the left controller model file\r\n     */\r\n    public static MODEL_LEFT_FILENAME: string = \"left.babylon\";\r\n    /**\r\n     * The name of the right controller model file\r\n     */\r\n    public static MODEL_RIGHT_FILENAME: string = \"right.babylon\";\r\n    /**\r\n     * Base Url for the Quest controller model.\r\n     */\r\n    public static QUEST_MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/oculusQuest/\";\r\n\r\n    public profileId = \"oculus-touch\";\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        gamepadObject: IMinimalMotionControllerObject,\r\n        handedness: MotionControllerHandedness,\r\n        _legacyMapping: boolean = false,\r\n        private _forceLegacyControllers: boolean = false\r\n    ) {\r\n        super(scene, OculusTouchLayouts[handedness], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        let filename = \"\";\r\n        if (this.handedness === \"left\") {\r\n            filename = WebXROculusTouchMotionController.MODEL_LEFT_FILENAME;\r\n        } else {\r\n            // Right is the default if no hand is specified\r\n            filename = WebXROculusTouchMotionController.MODEL_RIGHT_FILENAME;\r\n        }\r\n\r\n        const path = this._isQuest() ? WebXROculusTouchMotionController.QUEST_MODEL_BASE_URL : WebXROculusTouchMotionController.MODEL_BASE_URL;\r\n        return {\r\n            filename,\r\n            path,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        const isQuest = this._isQuest();\r\n        const triggerDirection = this.handedness === \"right\" ? -1 : 1;\r\n\r\n        this.getComponentIds().forEach((id) => {\r\n            const comp = id && this.getComponent(id);\r\n            if (comp) {\r\n                comp.onButtonStateChangedObservable.add(\r\n                    (component) => {\r\n                        if (!this.rootMesh || this.disableAnimation) {\r\n                            return;\r\n                        }\r\n\r\n                        switch (id) {\r\n                            case \"xr-standard-trigger\": // index trigger\r\n                                if (!isQuest) {\r\n                                    (<AbstractMesh>this._modelRootNode.getChildren()[3]).rotation.x = -component.value * 0.2;\r\n                                    (<AbstractMesh>this._modelRootNode.getChildren()[3]).position.y = -component.value * 0.005;\r\n                                    (<AbstractMesh>this._modelRootNode.getChildren()[3]).position.z = -component.value * 0.005;\r\n                                }\r\n                                return;\r\n                            case \"xr-standard-squeeze\": // secondary trigger\r\n                                if (!isQuest) {\r\n                                    (<AbstractMesh>this._modelRootNode.getChildren()[4]).position.x = triggerDirection * component.value * 0.0035;\r\n                                }\r\n                                return;\r\n                            case \"xr-standard-thumbstick\": // thumbstick\r\n                                return;\r\n                            case \"a-button\":\r\n                            case \"x-button\":\r\n                                if (!isQuest) {\r\n                                    if (component.pressed) {\r\n                                        (<AbstractMesh>this._modelRootNode.getChildren()[1]).position.y = -0.001;\r\n                                    } else {\r\n                                        (<AbstractMesh>this._modelRootNode.getChildren()[1]).position.y = 0;\r\n                                    }\r\n                                }\r\n                                return;\r\n                            case \"b-button\":\r\n                            case \"y-button\":\r\n                                if (!isQuest) {\r\n                                    if (component.pressed) {\r\n                                        (<AbstractMesh>this._modelRootNode.getChildren()[2]).position.y = -0.001;\r\n                                    } else {\r\n                                        (<AbstractMesh>this._modelRootNode.getChildren()[2]).position.y = 0;\r\n                                    }\r\n                                }\r\n                                return;\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    true\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n        }\r\n\r\n        meshes.forEach((mesh) => {\r\n            mesh.isPickable = false;\r\n        });\r\n        if (this._isQuest()) {\r\n            this._modelRootNode = meshes[0];\r\n        } else {\r\n            this._modelRootNode = meshes[1];\r\n            this.rootMesh.position.y = 0.034;\r\n            this.rootMesh.position.z = 0.052;\r\n        }\r\n        this._modelRootNode.parent = this.rootMesh;\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op. model is updated using observables.\r\n    }\r\n\r\n    /**\r\n     * Is this the new type of oculus touch. At the moment both have the same profile and it is impossible to differentiate\r\n     * between the touch and touch 2.\r\n     * @returns true if this is the new type of oculus touch controllers.\r\n     */\r\n    private _isQuest() {\r\n        // this is SADLY the only way to currently check. Until proper profiles will be available.\r\n        return !!navigator.userAgent.match(/Quest/gi) && !this._forceLegacyControllers;\r\n    }\r\n}\r\n\r\n// register the profile\r\nWebXRMotionControllerManager.RegisterController(\"oculus-touch\", (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXROculusTouchMotionController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\nWebXRMotionControllerManager.RegisterController(\"oculus-touch-legacy\", (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXROculusTouchMotionController(scene, <any>xrInput.gamepad, xrInput.handedness, true);\r\n});\r\n\r\nconst OculusTouchLayouts: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-thumbstick\": {\r\n                type: \"thumbstick\",\r\n                gamepadIndices: {\r\n                    button: 3,\r\n                    xAxis: 2,\r\n                    yAxis: 3,\r\n                },\r\n                rootNodeName: \"xr_standard_thumbstick\",\r\n                visualResponses: {},\r\n            },\r\n            \"x-button\": {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"x_button\",\r\n                visualResponses: {},\r\n            },\r\n            \"y-button\": {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 5,\r\n                },\r\n                rootNodeName: \"y_button\",\r\n                visualResponses: {},\r\n            },\r\n            thumbrest: {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 6,\r\n                },\r\n                rootNodeName: \"thumbrest\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"oculus-touch-v2-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-thumbstick\": {\r\n                type: \"thumbstick\",\r\n                gamepadIndices: {\r\n                    button: 3,\r\n                    xAxis: 2,\r\n                    yAxis: 3,\r\n                },\r\n                rootNodeName: \"xr_standard_thumbstick\",\r\n                visualResponses: {},\r\n            },\r\n            \"a-button\": {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"a_button\",\r\n                visualResponses: {},\r\n            },\r\n            \"b-button\": {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 5,\r\n                },\r\n                rootNodeName: \"b_button\",\r\n                visualResponses: {},\r\n            },\r\n            thumbrest: {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 6,\r\n                },\r\n                rootNodeName: \"thumbrest\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"oculus-touch-v2-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IMotionControllerLayoutMap, IMinimalMotionControllerObject, MotionControllerHandedness } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { WebXRMotionControllerManager } from \"./webXRMotionControllerManager\";\r\n\r\n/**\r\n * The motion controller class for the standard HTC-Vive controllers\r\n */\r\nexport class WebXRHTCViveMotionController extends WebXRAbstractMotionController {\r\n    private _modelRootNode: AbstractMesh;\r\n\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/vive/\";\r\n    /**\r\n     * File name for the controller model.\r\n     */\r\n    public static MODEL_FILENAME: string = \"wand.babylon\";\r\n\r\n    public profileId = \"htc-vive\";\r\n\r\n    /**\r\n     * Create a new Vive motion controller object\r\n     * @param scene the scene to use to create this controller\r\n     * @param gamepadObject the corresponding gamepad object\r\n     * @param handedness the handedness of the controller\r\n     */\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        super(scene, HTCViveLayout[handedness], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        const filename = WebXRHTCViveMotionController.MODEL_FILENAME;\r\n        const path = WebXRHTCViveMotionController.MODEL_BASE_URL;\r\n\r\n        return {\r\n            filename,\r\n            path,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        this.getComponentIds().forEach((id) => {\r\n            const comp = id && this.getComponent(id);\r\n            if (comp) {\r\n                comp.onButtonStateChangedObservable.add(\r\n                    (component) => {\r\n                        if (!this.rootMesh || this.disableAnimation) {\r\n                            return;\r\n                        }\r\n\r\n                        switch (id) {\r\n                            case \"xr-standard-trigger\":\r\n                                (<AbstractMesh>this._modelRootNode.getChildren()[6]).rotation.x = -component.value * 0.15;\r\n                                return;\r\n                            case \"xr-standard-touchpad\":\r\n                                return;\r\n                            case \"xr-standard-squeeze\":\r\n                                return;\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    true\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            mesh.isPickable = false;\r\n        });\r\n        this._modelRootNode = meshes[1];\r\n        this._modelRootNode.parent = this.rootMesh;\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n        }\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op. model is updated using observables.\r\n    }\r\n}\r\n\r\n// register the profile\r\nWebXRMotionControllerManager.RegisterController(\"htc-vive\", (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRHTCViveMotionController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// WebXRMotionControllerManager.RegisterController(\"htc-vive-legacy\", (xrInput: XRInputSource, scene: Scene) => {\r\n//     return new WebXRHTCViveMotionController(scene, <any>(xrInput.gamepad), xrInput.handedness, true);\r\n// });\r\n\r\nconst HTCViveLayout: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-touchpad\": {\r\n                type: \"touchpad\",\r\n                gamepadIndices: {\r\n                    button: 2,\r\n                    xAxis: 0,\r\n                    yAxis: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_touchpad\",\r\n                visualResponses: {},\r\n            },\r\n            menu: {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"menu\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"htc_vive_none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-touchpad\": {\r\n                type: \"touchpad\",\r\n                gamepadIndices: {\r\n                    button: 2,\r\n                    xAxis: 0,\r\n                    yAxis: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_touchpad\",\r\n                visualResponses: {},\r\n            },\r\n            menu: {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"menu\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"htc_vive_none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n    none: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-squeeze\": {\r\n                type: \"squeeze\",\r\n                gamepadIndices: {\r\n                    button: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_squeeze\",\r\n                visualResponses: {},\r\n            },\r\n            \"xr-standard-touchpad\": {\r\n                type: \"touchpad\",\r\n                gamepadIndices: {\r\n                    button: 2,\r\n                    xAxis: 0,\r\n                    yAxis: 1,\r\n                },\r\n                rootNodeName: \"xr_standard_touchpad\",\r\n                visualResponses: {},\r\n            },\r\n            menu: {\r\n                type: \"button\",\r\n                gamepadIndices: {\r\n                    button: 4,\r\n                },\r\n                rootNodeName: \"menu\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"htc-vive-none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n};\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdDecodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdDecodePixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"passCubePixelShader\";\nconst shader = `varying vec2 vUV;uniform samplerCube textureSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{vec2 uv=vUV*2.0-1.0;\n#ifdef POSITIVEX\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));\n#endif\n#ifdef NEGATIVEX\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));\n#endif\n#ifdef POSITIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));\n#endif\n#ifdef NEGATIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));\n#endif\n#ifdef POSITIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001));\n#endif\n#ifdef NEGATIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const passCubePixelShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Shaders/pass.fragment\";\r\nimport \"../Shaders/passCube.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class PassPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PassPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"pass\", null, null, options, camera, samplingMode, engine, reusable, undefined, textureType, undefined, null, blockCompilation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PassPostProcess\", PassPostProcess);\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class PassCubePostProcess extends PostProcess {\r\n    private _face = 0;\r\n\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    public get face(): number {\r\n        return this._face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        if (value < 0 || value > 5) {\r\n            return;\r\n        }\r\n\r\n        this._face = value;\r\n        switch (this._face) {\r\n            case 0:\r\n                this.updateEffect(\"#define POSITIVEX\");\r\n                break;\r\n            case 1:\r\n                this.updateEffect(\"#define NEGATIVEX\");\r\n                break;\r\n            case 2:\r\n                this.updateEffect(\"#define POSITIVEY\");\r\n                break;\r\n            case 3:\r\n                this.updateEffect(\"#define NEGATIVEY\");\r\n                break;\r\n            case 4:\r\n                this.updateEffect(\"#define POSITIVEZ\");\r\n                break;\r\n            case 5:\r\n                this.updateEffect(\"#define NEGATIVEZ\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassCubePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PassCubePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"passCube\", null, null, options, camera, samplingMode, engine, reusable, \"#define POSITIVEX\", textureType, undefined, null, blockCompilation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassCubePostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nEngine._RescalePostProcessFactory = (engine: Engine) => {\r\n    return new PassPostProcess(\"rescale\", 1, null, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, engine, false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.getEffect().executeWhenCompiled(() => {\r\n        passPostProcess.onApply = function (effect) {\r\n            effect.setTexture(\"textureSampler\", texture);\r\n        };\r\n\r\n        const internalTexture = rtt.renderTarget;\r\n\r\n        if (internalTexture) {\r\n            scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n            engine.unBindFramebuffer(internalTexture);\r\n            rtt.disposeFramebufferObjects();\r\n            passPostProcess.dispose();\r\n\r\n            rtt.getInternalTexture()!.isReady = true;\r\n        }\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @param width width of the output texture. If not provided, use the one from internalTexture\r\n * @param height height of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number,\r\n    width?: number,\r\n    height?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n    width = width ?? internalTexture.width;\r\n    height = height ?? internalTexture.height;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: width as number, height: height as number },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.getEffect().executeWhenCompiled(() => {\r\n            // PP Render Pass\r\n            postProcess.onApply = (effect) => {\r\n                effect._bindTexture(\"textureSampler\", internalTexture);\r\n                effect.setFloat2(\"scale\", 1, 1);\r\n            };\r\n            scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n            // Cleanup\r\n            engine.restoreDefaultFramebuffer();\r\n            engine._releaseTexture(internalTexture);\r\n            if (postProcess) {\r\n                postProcess.dispose();\r\n            }\r\n\r\n            // Internal Swap\r\n            encodedTexture._swapAndDie(internalTexture);\r\n\r\n            // Ready to get rolling again.\r\n            internalTexture.type = type!;\r\n            internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            internalTexture.isReady = true;\r\n\r\n            resolve(internalTexture);\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\nconst ProcessAsync = async (texture: BaseTexture, width: number, height: number, face: number, lod: number): Promise<Uint8Array> => {\r\n    const scene = texture.getScene()!;\r\n    const engine = scene.getEngine();\r\n\r\n    let lodPostProcess: PostProcess;\r\n\r\n    if (!texture.isCube) {\r\n        lodPostProcess = new PostProcess(\"lod\", \"lod\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine);\r\n    } else {\r\n        const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\r\n        lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine, false, faceDefines[face]);\r\n    }\r\n\r\n    await new Promise((resolve) => {\r\n        lodPostProcess.getEffect().executeWhenCompiled(() => {\r\n            resolve(0);\r\n        });\r\n    });\r\n\r\n    const rtt = new RenderTargetTexture(\"temp\", { width: width, height: height }, scene, false);\r\n\r\n    lodPostProcess.onApply = function (effect) {\r\n        effect.setTexture(\"textureSampler\", texture);\r\n        effect.setFloat(\"lod\", lod);\r\n        effect.setBool(\"gamma\", texture.gammaSpace);\r\n    };\r\n\r\n    const internalTexture = texture.getInternalTexture();\r\n\r\n    try {\r\n        if (rtt.renderTarget && internalTexture) {\r\n            const samplingMode = internalTexture.samplingMode;\r\n            if (lod !== 0) {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\r\n            } else {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST);\r\n            }\r\n\r\n            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\r\n            texture.updateSamplingMode(samplingMode);\r\n\r\n            //Reading datas from WebGL\r\n            const bufferView = await engine.readPixels(0, 0, width, height);\r\n            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\r\n\r\n            // Unbind\r\n            engine.unBindFramebuffer(rtt.renderTarget);\r\n\r\n            return data;\r\n        } else {\r\n            throw Error(\"Render to texture failed.\");\r\n        }\r\n    } finally {\r\n        rtt.dispose();\r\n        lodPostProcess.dispose();\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n * @param texture the source texture\r\n * @param width the width of the result, which does not have to match the source texture width\r\n * @param height the height of the result, which does not have to match the source texture height\r\n * @param face if the texture has multiple faces, the face index to use for the source\r\n * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n * @returns the 8-bit texture data\r\n */\r\nexport async function GetTextureDataAsync(texture: BaseTexture, width: number, height: number, face: number = 0, lod: number = 0): Promise<Uint8Array> {\r\n    if (!texture.isReady() && texture._texture) {\r\n        await new Promise((resolve, reject) => {\r\n            if (texture._texture === null) {\r\n                reject(0);\r\n                return;\r\n            }\r\n            texture._texture.onLoadedObservable.addOnce(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    }\r\n    return await ProcessAsync(texture, width, height, face, lod);\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param channels a filter for which of the RGBA channels to return in the result\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    GetTextureDataAsync,\r\n};\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        const isReady = internalTexture.isReady;\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        const expandRGBDTexture = () => {\r\n            // Expand the texture if possible\r\n            // Simply run through the decode PP.\r\n            const rgbdPostProcess = new PostProcess(\r\n                \"rgbdDecode\",\r\n                \"rgbdDecode\",\r\n                null,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                undefined,\r\n                internalTexture.type,\r\n                undefined,\r\n                null,\r\n                false\r\n            );\r\n            rgbdPostProcess.externalTextureSamplerBinding = true;\r\n\r\n            // Hold the output of the decoding.\r\n            const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode: internalTexture.samplingMode,\r\n                type: internalTexture.type,\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n            });\r\n\r\n            rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                rgbdPostProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                if (rgbdPostProcess) {\r\n                    rgbdPostProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                expandedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.isReady = true;\r\n            });\r\n        };\r\n\r\n        if (expandTexture) {\r\n            if (isReady) {\r\n                expandRGBDTexture();\r\n            } else {\r\n                texture.onLoadObservable.addOnce(expandRGBDTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode the texture to RGBD if possible.\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param outputTextureType type of the texture in which the encoding is performed\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static EncodeTextureToRGBD(internalTexture: InternalTexture, scene: Scene, outputTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE): Promise<InternalTexture> {\r\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n    }\r\n}\r\n", "import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Scalar.Clamp(r, 0, max);\r\n                        g = Scalar.Clamp(g, 0, max);\r\n                        b = Scalar.Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\n\r\ndeclare module \"./baseTexture\" {\r\n    export interface BaseTexture {\r\n        /**\r\n         * Get the polynomial representation of the texture data.\r\n         * This is mainly use as a fast way to recover IBL Diffuse irradiance data.\r\n         * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance\r\n         */\r\n        sphericalPolynomial: Nullable<SphericalPolynomial>;\r\n\r\n        /**\r\n         * Force recomputation of spherical polynomials.\r\n         * Can be useful if you generate a cubemap multiple times (from a probe for eg) and you need the proper polynomials each time\r\n         */\r\n        forceSphericalPolynomialsRecompute(): void;\r\n    }\r\n}\r\n\r\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function (): void {\r\n    if (this._texture) {\r\n        this._texture._sphericalPolynomial = null;\r\n        this._texture._sphericalPolynomialPromise = null;\r\n        this._texture._sphericalPolynomialComputed = false;\r\n    }\r\n};\r\n\r\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\r\n    get: function (this: BaseTexture) {\r\n        if (this._texture) {\r\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\r\n                return this._texture._sphericalPolynomial;\r\n            }\r\n\r\n            if (this._texture.isReady) {\r\n                if (!this._texture._sphericalPolynomialPromise) {\r\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\r\n                    if (this._texture._sphericalPolynomialPromise === null) {\r\n                        this._texture._sphericalPolynomialComputed = true;\r\n                    } else {\r\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\r\n                            this._texture!._sphericalPolynomial = sphericalPolynomial;\r\n                            this._texture!._sphericalPolynomialComputed = true;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n    set: function (this: BaseTexture, value: Nullable<SphericalPolynomial>) {\r\n        if (this._texture) {\r\n            this._texture._sphericalPolynomial = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdEncodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdEncodePixelShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { DumpTools } from \"../Misc/dumpTools\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    if (manifest.specular) {\r\n        // Extend the header with the position of the payload.\r\n        manifest.specular.specularDataPosition = pos;\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\r\n    texture.sphericalPolynomial;\r\n\r\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\r\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            let faceData = await texture.readPixels(face, i, undefined, false);\r\n            if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n                const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n                for (let i = 0; i < faceData.byteLength; i++) {\r\n                    faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n                    // Gamma to linear\r\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n                }\r\n                faceData = faceDataFloat;\r\n            } else if (faceData && texture.gammaSpace) {\r\n                const floatData = faceData as Float32Array;\r\n                for (let i = 0; i < floatData.length; i++) {\r\n                    // Gamma to linear\r\n                    floatData[i] = Math.pow(floatData[i], 2.2);\r\n                }\r\n            }\r\n\r\n            const tempTexture = engine.createRawTexture(\r\n                faceData,\r\n                faceWidth,\r\n                faceWidth,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                textureType\r\n            );\r\n\r\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\r\n\r\n            const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\r\n\r\n            specularTextures[i * 6 + face] = imageEncodedData as ArrayBuffer;\r\n\r\n            tempTexture.dispose();\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Ensure completion of the polynomial creation promise.\r\n    if (sphericalPolynomialPromise) {\r\n        await sphericalPolynomialPromise;\r\n    }\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    } as any;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Scalar.Log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve();\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n    return UploadLevelsAsync(texture, imageData, info.imageType);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                // Uncompress the data to a RTT\r\n                rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                rgbdPostProcess!.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                };\r\n\r\n                if (!engine.scenes.length) {\r\n                    return;\r\n                }\r\n\r\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                tempTexture.dispose();\r\n                URL.revokeObjectURL(url);\r\n                resolve();\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport function UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    // Add extra process if texture lod is not supported\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = true;\r\n        lodTextures = {};\r\n    }\r\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    if (expandTexture) {\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Once all done, finishes the cleanup and return\r\n    return Promise.all(promises).then(() => {\r\n        // Release temp RTT.\r\n        if (cubeRtt) {\r\n            engine._releaseTexture(texture);\r\n            cubeRtt._swapAndDie(texture);\r\n        }\r\n        // Release temp Post Process.\r\n        if (rgbdPostProcess) {\r\n            rgbdPostProcess.dispose();\r\n        }\r\n        // Flag internal texture as ready in case they are in use.\r\n        if (generateNonLODTextures) {\r\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                texture._lodTextureHigh._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                texture._lodTextureMid._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                texture._lodTextureLow._texture.isReady = true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n", "/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @param c2 an optional second character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string, c2?: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            Logger.Log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    Logger.Warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\", \"{\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import type { INative, INativeDataStream } from \"./nativeInterfaces\";\r\n\r\ndeclare const _native: INative;\r\n\r\n/** @internal */\r\nexport type NativeData = Uint32Array;\r\n\r\n/** @internal */\r\nexport class NativeDataStream {\r\n    private readonly _uint32s: Uint32Array;\r\n    private readonly _int32s: Int32Array;\r\n    private readonly _float32s: Float32Array;\r\n    private readonly _length: number;\r\n    private _position: number;\r\n    private readonly _nativeDataStream: INativeDataStream;\r\n\r\n    // Must be multiple of 4!\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static readonly DEFAULT_BUFFER_SIZE = 65536;\r\n\r\n    constructor() {\r\n        const buffer = new ArrayBuffer(NativeDataStream.DEFAULT_BUFFER_SIZE);\r\n        this._uint32s = new Uint32Array(buffer);\r\n        this._int32s = new Int32Array(buffer);\r\n        this._float32s = new Float32Array(buffer);\r\n\r\n        this._length = NativeDataStream.DEFAULT_BUFFER_SIZE / 4;\r\n        this._position = 0;\r\n\r\n        this._nativeDataStream = new _native.NativeDataStream(() => {\r\n            this._flush();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Writes a uint32 to the stream\r\n     * @param value the value to write\r\n     */\r\n    public writeUint32(value: number): void {\r\n        this._flushIfNecessary(1);\r\n        this._uint32s[this._position++] = value;\r\n    }\r\n\r\n    /**\r\n     * Writes an int32 to the stream\r\n     * @param value the value to write\r\n     */\r\n    public writeInt32(value: number): void {\r\n        this._flushIfNecessary(1);\r\n        this._int32s[this._position++] = value;\r\n    }\r\n\r\n    /**\r\n     * Writes a float32 to the stream\r\n     * @param value the value to write\r\n     */\r\n    public writeFloat32(value: number): void {\r\n        this._flushIfNecessary(1);\r\n        this._float32s[this._position++] = value;\r\n    }\r\n\r\n    /**\r\n     * Writes a uint32 array to the stream\r\n     * @param values the values to write\r\n     */\r\n    public writeUint32Array(values: Uint32Array): void {\r\n        this._flushIfNecessary(1 + values.length);\r\n        this._uint32s[this._position++] = values.length;\r\n        this._uint32s.set(values, this._position);\r\n        this._position += values.length;\r\n    }\r\n\r\n    /**\r\n     * Writes an int32 array to the stream\r\n     * @param values the values to write\r\n     */\r\n    public writeInt32Array(values: Int32Array): void {\r\n        this._flushIfNecessary(1 + values.length);\r\n        this._uint32s[this._position++] = values.length;\r\n        this._int32s.set(values, this._position);\r\n        this._position += values.length;\r\n    }\r\n\r\n    /**\r\n     * Writes a float32 array to the stream\r\n     * @param values the values to write\r\n     */\r\n    public writeFloat32Array(values: Float32Array): void {\r\n        this._flushIfNecessary(1 + values.length);\r\n        this._uint32s[this._position++] = values.length;\r\n        this._float32s.set(values, this._position);\r\n        this._position += values.length;\r\n    }\r\n\r\n    /**\r\n     * Writes native data to the stream\r\n     * @param handle the handle to the native data\r\n     */\r\n    public writeNativeData(handle: NativeData) {\r\n        this._flushIfNecessary(handle.length);\r\n        this._uint32s.set(handle, this._position);\r\n        this._position += handle.length;\r\n    }\r\n\r\n    /**\r\n     * Writes a boolean to the stream\r\n     * @param value the value to write\r\n     */\r\n    public writeBoolean(value: boolean) {\r\n        this.writeUint32(value ? 1 : 0);\r\n    }\r\n\r\n    private _flushIfNecessary(required: number): void {\r\n        if (this._position + required > this._length) {\r\n            this._flush();\r\n        }\r\n    }\r\n\r\n    private _flush(): void {\r\n        this._nativeDataStream.writeBuffer(this._uint32s.buffer, this._position);\r\n        this._position = 0;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { NativeEngine } from \"../nativeEngine\";\r\nimport type { NativeProgram } from \"./nativeInterfaces\";\r\n\r\nexport class NativePipelineContext implements IPipelineContext {\r\n    public isCompiled: boolean = false;\r\n    public compilationError?: Error;\r\n\r\n    public readonly isAsync: boolean;\r\n\r\n    public program: NativeProgram;\r\n\r\n    public get isReady(): boolean {\r\n        if (this.compilationError) {\r\n            const message = this.compilationError.message;\r\n            throw new Error(\"SHADER ERROR\" + (typeof message === \"string\" ? \"\\n\" + message : \"\"));\r\n        }\r\n        return this.isCompiled;\r\n    }\r\n\r\n    public onCompiled?: () => void;\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return null;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return null;\r\n    }\r\n\r\n    private _engine: NativeEngine;\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> };\r\n\r\n    constructor(engine: NativeEngine, isAsync: boolean) {\r\n        this._engine = engine;\r\n        this.isAsync = isAsync;\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this._engine;\r\n        if (engine.supportsUniformBuffers) {\r\n            for (const name in uniformBuffersNames) {\r\n                effect.bindUniformBlock(name, uniformBuffersNames[name]);\r\n            }\r\n        }\r\n\r\n        const effectAvailableUniforms = this._engine.getUniforms(this, uniformsNames);\r\n        effectAvailableUniforms.forEach((uniform, index) => {\r\n            uniforms[uniformsNames[index]] = uniform;\r\n        });\r\n        this._uniforms = uniforms;\r\n\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const sampler = effect.getUniform(samplerList[index]);\r\n            if (sampler == null) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n\r\n        samplerList.forEach((name, index) => {\r\n            samplers[name] = index;\r\n        });\r\n\r\n        attributes.push(...engine.getAttributes(this, attributesNames));\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        this._uniforms = {};\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean {\r\n        const cache = this._valueCache[uniformName];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[uniformName] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat2(uniformName: string, x: number, y: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache) {\r\n            cache = [x, y];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache) {\r\n            cache = [x, y, z];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache) {\r\n            cache = [x, y, z, w];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n        if (cache[3] !== w) {\r\n            cache[3] = w;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setInt(this._uniforms[uniformName]!, value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setUInt(this._uniforms[uniformName]!, value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a unsigned int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setUInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a unsigned int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setUInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a unsigned int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!matrices) {\r\n            return;\r\n        }\r\n\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrices(this._uniforms[uniformName]!, matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (this._cacheMatrix(uniformName, matrix)) {\r\n            if (!this._engine.setMatrices(this._uniforms[uniformName]!, matrix.toArray() as Float32Array)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrix3x3(this._uniforms[uniformName]!, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrix2x2(this._uniforms[uniformName]!, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setFloat(this._uniforms[uniformName]!, value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === bool) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setInt(this._uniforms[uniformName]!, bool ? 1 : 0)) {\r\n            this._valueCache[uniformName] = bool ? 1 : 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\r\n            if (!this._engine.setFloat2(this._uniforms[uniformName]!, vector2.x, vector2.y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setFloat2(this._uniforms[uniformName]!, x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName]!, vector3.x, vector3.y, vector3.z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName]!, x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName]!, color3.r, color3.g, color3.b)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, color3.r, color3.g, color3.b, alpha)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, color4.r, color4.g, color4.b, color4.a)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { NativeEngine } from \"../nativeEngine\";\r\nimport type { NativeFramebuffer } from \"./nativeInterfaces\";\r\n\r\nexport class NativeRenderTargetWrapper extends RenderTargetWrapper {\r\n    public override readonly _engine: NativeEngine;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __framebuffer: Nullable<NativeFramebuffer> = null;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __framebufferDepthStencil: Nullable<NativeFramebuffer> = null;\r\n\r\n    public get _framebuffer(): Nullable<NativeFramebuffer> {\r\n        return this.__framebuffer;\r\n    }\r\n\r\n    public set _framebuffer(framebuffer: Nullable<NativeFramebuffer>) {\r\n        if (this.__framebuffer) {\r\n            this._engine._releaseFramebufferObjects(this.__framebuffer);\r\n        }\r\n        this.__framebuffer = framebuffer;\r\n    }\r\n\r\n    public get _framebufferDepthStencil(): Nullable<NativeFramebuffer> {\r\n        return this.__framebufferDepthStencil;\r\n    }\r\n\r\n    public set _framebufferDepthStencil(framebufferDepthStencil: Nullable<NativeFramebuffer>) {\r\n        if (this.__framebufferDepthStencil) {\r\n            this._engine._releaseFramebufferObjects(this.__framebufferDepthStencil);\r\n        }\r\n        this.__framebufferDepthStencil = framebufferDepthStencil;\r\n    }\r\n\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: NativeEngine) {\r\n        super(isMulti, isCube, size, engine);\r\n        this._engine = engine;\r\n    }\r\n\r\n    public dispose(disposeOnlyFramebuffers = false): void {\r\n        this._framebuffer = null;\r\n        this._framebufferDepthStencil = null;\r\n\r\n        super.dispose(disposeOnlyFramebuffers);\r\n    }\r\n}\r\n", "import type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { INativeEngine, NativeTexture } from \"./nativeInterfaces\";\r\n\r\n/** @internal */\r\nexport class NativeHardwareTexture implements HardwareTextureWrapper {\r\n    private readonly _engine: INativeEngine;\r\n    private _nativeTexture: Nullable<NativeTexture>;\r\n\r\n    public get underlyingResource(): Nullable<NativeTexture> {\r\n        return this._nativeTexture;\r\n    }\r\n\r\n    constructor(existingTexture: NativeTexture, engine: INativeEngine) {\r\n        this._engine = engine;\r\n        this.set(existingTexture);\r\n    }\r\n\r\n    public setUsage(): void {}\r\n\r\n    public set(hardwareTexture: NativeTexture) {\r\n        this._nativeTexture = hardwareTexture;\r\n    }\r\n\r\n    public reset() {\r\n        this._nativeTexture = null;\r\n    }\r\n\r\n    public release() {\r\n        if (this._nativeTexture) {\r\n            this._engine.deleteTexture(this._nativeTexture);\r\n        }\r\n\r\n        this.reset();\r\n    }\r\n}\r\n", "import { ErrorCodes, RuntimeError } from \"core/Misc/error\";\r\nimport { Constants } from \"../constants\";\r\nimport type { INative } from \"./nativeInterfaces\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\n\r\ndeclare const _native: INative;\r\n\r\nexport function getNativeTextureFormat(format: number, type: number): number {\r\n    switch (format) {\r\n        // Depth (type is ignored)\r\n        case Constants.TEXTUREFORMAT_DEPTH16:\r\n            return _native.Engine.TEXTURE_FORMAT_D16;\r\n        case Constants.TEXTUREFORMAT_DEPTH24:\r\n            return _native.Engine.TEXTURE_FORMAT_D24;\r\n        case Constants.TEXTUREFORMAT_DEPTH24_STENCIL8:\r\n            return _native.Engine.TEXTURE_FORMAT_D24S8;\r\n        case Constants.TEXTUREFORMAT_DEPTH32_FLOAT:\r\n            return _native.Engine.TEXTURE_FORMAT_D32F;\r\n\r\n        // Compressed (type is ignored)\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n            return _native.Engine.TEXTURE_FORMAT_BC7;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n            return _native.Engine.TEXTURE_FORMAT_BC6H;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n            return _native.Engine.TEXTURE_FORMAT_BC3;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n            return _native.Engine.TEXTURE_FORMAT_BC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n            return _native.Engine.TEXTURE_FORMAT_BC1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n            return _native.Engine.TEXTURE_FORMAT_BC1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n            return _native.Engine.TEXTURE_FORMAT_ASTC4x4;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n            return _native.Engine.TEXTURE_FORMAT_ETC1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n            return _native.Engine.TEXTURE_FORMAT_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n            return _native.Engine.TEXTURE_FORMAT_ETC2A;\r\n\r\n        case Constants.TEXTUREFORMAT_RGB: {\r\n            switch (type) {\r\n                case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGB8;\r\n                case Constants.TEXTURETYPE_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGB8S;\r\n                case Constants.TEXTURETYPE_INT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGB8I;\r\n                case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGB8U;\r\n            }\r\n            break;\r\n        }\r\n        case Constants.TEXTUREFORMAT_RGBA: {\r\n            switch (type) {\r\n                case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA8;\r\n                case Constants.TEXTURETYPE_FLOAT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA32F;\r\n                case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA16F;\r\n                case Constants.TEXTURETYPE_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA8S;\r\n                case Constants.TEXTURETYPE_SHORT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA16I;\r\n                case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA16U;\r\n                case Constants.TEXTURETYPE_INT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA32I;\r\n                case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n                    return _native.Engine.TEXTURE_FORMAT_RGBA32U;\r\n            }\r\n            break;\r\n        }\r\n        case Constants.TEXTUREFORMAT_R: {\r\n            switch (type) {\r\n                case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_R8;\r\n                case Constants.TEXTURETYPE_FLOAT:\r\n                    return _native.Engine.TEXTURE_FORMAT_R32F;\r\n                case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                    return _native.Engine.TEXTURE_FORMAT_R16F;\r\n                case Constants.TEXTURETYPE_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_R8S;\r\n                case Constants.TEXTURETYPE_SHORT:\r\n                    return _native.Engine.TEXTURE_FORMAT_R16S;\r\n                case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                    return _native.Engine.TEXTURE_FORMAT_R16U;\r\n                case Constants.TEXTURETYPE_INT:\r\n                    return _native.Engine.TEXTURE_FORMAT_R32I;\r\n                case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n                    return _native.Engine.TEXTURE_FORMAT_R32U;\r\n            }\r\n            break;\r\n        }\r\n        case Constants.TEXTUREFORMAT_RG: {\r\n            switch (type) {\r\n                case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG8;\r\n                case Constants.TEXTURETYPE_FLOAT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG32F;\r\n                case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG16F;\r\n                case Constants.TEXTURETYPE_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG8S;\r\n                case Constants.TEXTURETYPE_SHORT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG16S;\r\n                case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG16U;\r\n                case Constants.TEXTURETYPE_INT:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG32I;\r\n                case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n                    return _native.Engine.TEXTURE_FORMAT_RG32U;\r\n            }\r\n            break;\r\n        }\r\n        case Constants.TEXTUREFORMAT_BGRA: {\r\n            switch (type) {\r\n                case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                    return _native.Engine.TEXTURE_FORMAT_BGRA8;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    throw new RuntimeError(`Unsupported texture format or type: format ${format}, type ${type}.`, ErrorCodes.UnsupportedTextureError);\r\n}\r\n\r\nexport function getNativeSamplingMode(samplingMode: number): number {\r\n    switch (samplingMode) {\r\n        case Constants.TEXTURE_NEAREST_NEAREST:\r\n            return _native.Engine.TEXTURE_NEAREST_NEAREST;\r\n        case Constants.TEXTURE_LINEAR_LINEAR:\r\n            return _native.Engine.TEXTURE_LINEAR_LINEAR;\r\n        case Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR:\r\n            return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n        case Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\r\n            return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n        case Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\r\n            return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n        case Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\r\n            return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n        case Constants.TEXTURE_NEAREST_LINEAR:\r\n            return _native.Engine.TEXTURE_NEAREST_LINEAR;\r\n        case Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR:\r\n            return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR;\r\n        case Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\r\n            return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n        case Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\r\n            return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n        case Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST:\r\n            return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n        case Constants.TEXTURE_LINEAR_NEAREST:\r\n            return _native.Engine.TEXTURE_LINEAR_NEAREST;\r\n        default:\r\n            throw new Error(`Unsupported sampling mode: ${samplingMode}.`);\r\n    }\r\n}\r\n\r\nexport function getNativeAddressMode(wrapMode: number): number {\r\n    switch (wrapMode) {\r\n        case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n            return _native.Engine.ADDRESS_MODE_WRAP;\r\n        case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n            return _native.Engine.ADDRESS_MODE_CLAMP;\r\n        case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n            return _native.Engine.ADDRESS_MODE_MIRROR;\r\n        default:\r\n            throw new Error(\"Unexpected wrap mode: \" + wrapMode + \".\");\r\n    }\r\n}\r\n\r\nexport function getNativeStencilFunc(func: number): number {\r\n    switch (func) {\r\n        case Constants.LESS:\r\n            return _native.Engine.STENCIL_TEST_LESS;\r\n        case Constants.LEQUAL:\r\n            return _native.Engine.STENCIL_TEST_LEQUAL;\r\n        case Constants.EQUAL:\r\n            return _native.Engine.STENCIL_TEST_EQUAL;\r\n        case Constants.GEQUAL:\r\n            return _native.Engine.STENCIL_TEST_GEQUAL;\r\n        case Constants.GREATER:\r\n            return _native.Engine.STENCIL_TEST_GREATER;\r\n        case Constants.NOTEQUAL:\r\n            return _native.Engine.STENCIL_TEST_NOTEQUAL;\r\n        case Constants.NEVER:\r\n            return _native.Engine.STENCIL_TEST_NEVER;\r\n        case Constants.ALWAYS:\r\n            return _native.Engine.STENCIL_TEST_ALWAYS;\r\n        default:\r\n            throw new Error(`Unsupported stencil func mode: ${func}.`);\r\n    }\r\n}\r\n\r\nexport function getNativeStencilOpFail(opFail: number): number {\r\n    switch (opFail) {\r\n        case Constants.KEEP:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_KEEP;\r\n        case Constants.ZERO:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_ZERO;\r\n        case Constants.REPLACE:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_REPLACE;\r\n        case Constants.INCR:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_INCR;\r\n        case Constants.DECR:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_DECR;\r\n        case Constants.INVERT:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_INVERT;\r\n        case Constants.INCR_WRAP:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_INCRSAT;\r\n        case Constants.DECR_WRAP:\r\n            return _native.Engine.STENCIL_OP_FAIL_S_DECRSAT;\r\n        default:\r\n            throw new Error(`Unsupported stencil OpFail mode: ${opFail}.`);\r\n    }\r\n}\r\n\r\nexport function getNativeStencilDepthFail(depthFail: number): number {\r\n    switch (depthFail) {\r\n        case Constants.KEEP:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_KEEP;\r\n        case Constants.ZERO:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_ZERO;\r\n        case Constants.REPLACE:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_REPLACE;\r\n        case Constants.INCR:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_INCR;\r\n        case Constants.DECR:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_DECR;\r\n        case Constants.INVERT:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_INVERT;\r\n        case Constants.INCR_WRAP:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_INCRSAT;\r\n        case Constants.DECR_WRAP:\r\n            return _native.Engine.STENCIL_OP_FAIL_Z_DECRSAT;\r\n        default:\r\n            throw new Error(`Unsupported stencil depthFail mode: ${depthFail}.`);\r\n    }\r\n}\r\n\r\nexport function getNativeStencilDepthPass(opPass: number): number {\r\n    switch (opPass) {\r\n        case Constants.KEEP:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_KEEP;\r\n        case Constants.ZERO:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_ZERO;\r\n        case Constants.REPLACE:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_REPLACE;\r\n        case Constants.INCR:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_INCR;\r\n        case Constants.DECR:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_DECR;\r\n        case Constants.INVERT:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_INVERT;\r\n        case Constants.INCR_WRAP:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_INCRSAT;\r\n        case Constants.DECR_WRAP:\r\n            return _native.Engine.STENCIL_OP_PASS_Z_DECRSAT;\r\n        default:\r\n            throw new Error(`Unsupported stencil opPass mode: ${opPass}.`);\r\n    }\r\n}\r\n\r\nexport function getNativeAlphaMode(mode: number): number {\r\n    switch (mode) {\r\n        case Constants.ALPHA_DISABLE:\r\n            return _native.Engine.ALPHA_DISABLE;\r\n        case Constants.ALPHA_ADD:\r\n            return _native.Engine.ALPHA_ADD;\r\n        case Constants.ALPHA_COMBINE:\r\n            return _native.Engine.ALPHA_COMBINE;\r\n        case Constants.ALPHA_SUBTRACT:\r\n            return _native.Engine.ALPHA_SUBTRACT;\r\n        case Constants.ALPHA_MULTIPLY:\r\n            return _native.Engine.ALPHA_MULTIPLY;\r\n        case Constants.ALPHA_MAXIMIZED:\r\n            return _native.Engine.ALPHA_MAXIMIZED;\r\n        case Constants.ALPHA_ONEONE:\r\n            return _native.Engine.ALPHA_ONEONE;\r\n        case Constants.ALPHA_PREMULTIPLIED:\r\n            return _native.Engine.ALPHA_PREMULTIPLIED;\r\n        case Constants.ALPHA_PREMULTIPLIED_PORTERDUFF:\r\n            return _native.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n        case Constants.ALPHA_INTERPOLATE:\r\n            return _native.Engine.ALPHA_INTERPOLATE;\r\n        case Constants.ALPHA_SCREENMODE:\r\n            return _native.Engine.ALPHA_SCREENMODE;\r\n        default:\r\n            throw new Error(`Unsupported alpha mode: ${mode}.`);\r\n    }\r\n}\r\n\r\nexport function getNativeAttribType(type: number): number {\r\n    switch (type) {\r\n        case VertexBuffer.BYTE:\r\n            return _native.Engine.ATTRIB_TYPE_INT8;\r\n        case VertexBuffer.UNSIGNED_BYTE:\r\n            return _native.Engine.ATTRIB_TYPE_UINT8;\r\n        case VertexBuffer.SHORT:\r\n            return _native.Engine.ATTRIB_TYPE_INT16;\r\n        case VertexBuffer.UNSIGNED_SHORT:\r\n            return _native.Engine.ATTRIB_TYPE_UINT16;\r\n        case VertexBuffer.FLOAT:\r\n            return _native.Engine.ATTRIB_TYPE_FLOAT;\r\n        default:\r\n            throw new Error(`Unsupported attribute type: ${type}.`);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable, IndicesArray, DataArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../Materials/Textures/internalTextureLoader\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { EnvironmentTextureSpecularInfoV1 } from \"../Misc/environmentTextureTools\";\r\nimport { CreateImageDataArrayBufferViews, GetEnvInfo, UploadEnvSpherical } from \"../Misc/environmentTextureTools\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { RenderTargetCreationOptions, TextureSize, DepthTextureCreationOptions, InternalTextureCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { IColor3Like, IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"./constants\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { ThinEngine } from \"./thinEngine\";\r\nimport type { IWebRequest } from \"../Misc/interfaces/iWebRequest\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport { WebGL2ShaderProcessor } from \"../Engines/WebGL/webGL2ShaderProcessors\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { ICanvas, IImage } from \"./ICanvas\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { NativeData } from \"./Native/nativeDataStream\";\r\nimport { NativeDataStream } from \"./Native/nativeDataStream\";\r\nimport type { INative, INativeCamera, INativeEngine, NativeFramebuffer, NativeProgram, NativeTexture, NativeUniform, NativeVertexArrayObject } from \"./Native/nativeInterfaces\";\r\nimport { NativePipelineContext } from \"./Native/nativePipelineContext\";\r\nimport { NativeRenderTargetWrapper } from \"./Native/nativeRenderTargetWrapper\";\r\nimport { NativeHardwareTexture } from \"./Native/nativeHardwareTexture\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport {\r\n    getNativeAlphaMode,\r\n    getNativeAttribType,\r\n    getNativeSamplingMode,\r\n    getNativeTextureFormat,\r\n    getNativeStencilDepthFail,\r\n    getNativeStencilDepthPass,\r\n    getNativeStencilFunc,\r\n    getNativeStencilOpFail,\r\n    getNativeAddressMode,\r\n} from \"./Native/nativeHelpers\";\r\n\r\ndeclare const _native: INative;\r\n\r\nconst onNativeObjectInitialized = new Observable<INative>();\r\nif (typeof self !== \"undefined\" && !Object.prototype.hasOwnProperty.call(self, \"_native\")) {\r\n    let __native: INative;\r\n    Object.defineProperty(self, \"_native\", {\r\n        get: () => __native,\r\n        set: (value: INative) => {\r\n            __native = value;\r\n            if (__native) {\r\n                onNativeObjectInitialized.notifyObservers(__native);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Returns _native only after it has been defined by BabylonNative.\r\n * @internal\r\n */\r\nexport function AcquireNativeObjectAsync(): Promise<INative> {\r\n    return new Promise((resolve) => {\r\n        if (typeof _native === \"undefined\") {\r\n            onNativeObjectInitialized.addOnce((nativeObject) => resolve(nativeObject));\r\n        } else {\r\n            resolve(_native);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Registers a constructor on the _native object. See NativeXRFrame for an example.\r\n * @internal\r\n */\r\nexport async function RegisterNativeTypeAsync<Type>(typeName: string, constructor: Type) {\r\n    ((await AcquireNativeObjectAsync()) as any)[typeName] = constructor;\r\n}\r\n\r\n/**\r\n * Container for accessors for natively-stored mesh data buffers.\r\n */\r\nclass NativeDataBuffer extends DataBuffer {\r\n    /**\r\n     * Accessor value used to identify/retrieve a natively-stored index buffer.\r\n     */\r\n    public nativeIndexBuffer?: NativeData;\r\n\r\n    /**\r\n     * Accessor value used to identify/retrieve a natively-stored vertex buffer.\r\n     */\r\n    public nativeVertexBuffer?: NativeData;\r\n}\r\n\r\n/**\r\n * Options to create the Native engine\r\n */\r\nexport interface NativeEngineOptions {\r\n    /**\r\n     * defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n}\r\n\r\n/** @internal */\r\nclass CommandBufferEncoder {\r\n    private readonly _commandStream: NativeDataStream;\r\n    private readonly _pending = new Array<NativeData>();\r\n    private _isCommandBufferScopeActive = false;\r\n\r\n    public constructor(private readonly _engine: INativeEngine) {\r\n        this._commandStream = NativeEngine._createNativeDataStream();\r\n        this._engine.setCommandDataStream(this._commandStream);\r\n    }\r\n\r\n    public beginCommandScope() {\r\n        if (this._isCommandBufferScopeActive) {\r\n            throw new Error(\"Command scope already active.\");\r\n        }\r\n\r\n        this._isCommandBufferScopeActive = true;\r\n    }\r\n\r\n    public endCommandScope() {\r\n        if (!this._isCommandBufferScopeActive) {\r\n            throw new Error(\"Command scope is not active.\");\r\n        }\r\n\r\n        this._isCommandBufferScopeActive = false;\r\n        this._submit();\r\n    }\r\n\r\n    public startEncodingCommand(command: NativeData) {\r\n        this._commandStream.writeNativeData(command);\r\n    }\r\n\r\n    public encodeCommandArgAsUInt32(commandArg: number) {\r\n        this._commandStream.writeUint32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsUInt32s(commandArg: Uint32Array) {\r\n        this._commandStream.writeUint32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsInt32(commandArg: number) {\r\n        this._commandStream.writeInt32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsInt32s(commandArg: Int32Array) {\r\n        this._commandStream.writeInt32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsFloat32(commandArg: number) {\r\n        this._commandStream.writeFloat32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsFloat32s(commandArg: Float32Array) {\r\n        this._commandStream.writeFloat32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsNativeData(commandArg: NativeData) {\r\n        this._commandStream.writeNativeData(commandArg);\r\n        this._pending.push(commandArg);\r\n    }\r\n\r\n    public finishEncodingCommand() {\r\n        if (!this._isCommandBufferScopeActive) {\r\n            this._submit();\r\n        }\r\n    }\r\n\r\n    private _submit() {\r\n        this._engine.submitCommands();\r\n        this._pending.length = 0;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class NativeEngine extends Engine {\r\n    // This must match the protocol version in NativeEngine.cpp\r\n    private static readonly PROTOCOL_VERSION = 8;\r\n\r\n    private readonly _engine: INativeEngine = new _native.Engine();\r\n    private readonly _camera: Nullable<INativeCamera> = _native.Camera ? new _native.Camera() : null;\r\n\r\n    private readonly _commandBufferEncoder = new CommandBufferEncoder(this._engine);\r\n\r\n    private _boundBuffersVertexArray: any = null;\r\n    private _currentDepthTest: number = _native.Engine.DEPTH_TEST_LEQUAL;\r\n    private _stencilTest = false;\r\n    private _stencilMask: number = 255;\r\n    private _stencilFunc: number = Constants.ALWAYS;\r\n    private _stencilFuncRef: number = 0;\r\n    private _stencilFuncMask: number = 255;\r\n    private _stencilOpStencilFail: number = Constants.KEEP;\r\n    private _stencilOpDepthFail: number = Constants.KEEP;\r\n    private _stencilOpStencilDepthPass: number = Constants.REPLACE;\r\n    private _zOffset: number = 0;\r\n    private _zOffsetUnits: number = 0;\r\n    private _depthWrite: boolean = true;\r\n\r\n    public setHardwareScalingLevel(level: number): void {\r\n        super.setHardwareScalingLevel(level);\r\n        this._engine.setHardwareScalingLevel(level);\r\n    }\r\n\r\n    public constructor(options: NativeEngineOptions = {}) {\r\n        super(null, false, undefined, options.adaptToDeviceRatio);\r\n\r\n        if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {\r\n            throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);\r\n        }\r\n\r\n        this._webGLVersion = 2;\r\n        this.disableUniformBuffers = true;\r\n        this._shaderPlatformName = \"NATIVE\";\r\n\r\n        // TODO: Initialize this more correctly based on the hardware capabilities.\r\n        // Init caps\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,\r\n            maxCubemapTextureSize: 512,\r\n            maxRenderTextureSize: 512,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 16,\r\n            maxFragmentUniformVectors: 16,\r\n            maxVertexUniformVectors: 16,\r\n            standardDerivatives: true,\r\n            astc: null,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: null,\r\n            bptc: null,\r\n            maxAnisotropy: 16, // TODO: Retrieve this smartly. Currently set to D3D11 maximum allowable value.\r\n            uintIndices: true,\r\n            fragmentDepthSupported: false,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: false,\r\n            supportFloatTexturesResolve: false,\r\n            rg11b10ufColorRenderable: false,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: false,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            texelFetch: false,\r\n            drawBuffersExtension: false,\r\n            depthTextureExtension: false,\r\n            vertexArrayObject: true,\r\n            instancedArrays: true,\r\n            supportOcclusionQuery: false,\r\n            canUseTimestampForTimerQuery: false,\r\n            blendMinMax: false,\r\n            maxMSAASamples: 16,\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: false,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: false,\r\n            texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS,\r\n            disableMorphTargetTexture: false,\r\n            parallelShaderCompile: { COMPLETION_STATUS_KHR: 0 },\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: true,\r\n            supportRenderAndCopyToLodForFloatTextures: false,\r\n            supportDepthStencilTexture: false,\r\n            supportShadowSamplers: false,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: false,\r\n            trackUbosInFrame: false,\r\n            checkUbosContentBeforeUpload: false,\r\n            supportCSM: false,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: false,\r\n            needTypeSuffixInShaderConstants: false,\r\n            supportMSAA: true,\r\n            supportSSAO2: false,\r\n            supportExtendedTextureFormats: false,\r\n            supportSwitchCaseInShader: false,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: true,\r\n            useUBOBindingCache: true,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: false,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: false,\r\n            forceVertexBufferStrideMultiple4Bytes: false,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n\r\n        Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\r\n\r\n        Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\r\n            Tools.LoadFile(\r\n                scriptUrl,\r\n                (data) => {\r\n                    Function(data as string).apply(null);\r\n                    if (onSuccess) {\r\n                        onSuccess();\r\n                    }\r\n                },\r\n                undefined,\r\n                undefined,\r\n                false,\r\n                (request, exception) => {\r\n                    if (onError) {\r\n                        onError(\"LoadScript Error\", exception);\r\n                    }\r\n                }\r\n            );\r\n        };\r\n\r\n        // Wrappers\r\n        if (typeof URL === \"undefined\") {\r\n            (window.URL as any) = {\r\n                createObjectURL: function () {},\r\n                revokeObjectURL: function () {},\r\n            };\r\n        }\r\n\r\n        if (typeof Blob === \"undefined\") {\r\n            (window.Blob as any) = function (v: any) {\r\n                return v;\r\n            };\r\n        }\r\n\r\n        // polyfill for Chakra\r\n        if (!Array.prototype.flat) {\r\n            Object.defineProperty(Array.prototype, \"flat\", {\r\n                configurable: true,\r\n                value: function flat() {\r\n                    const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\r\n\r\n                    return depth\r\n                        ? Array.prototype.reduce.call(\r\n                              this,\r\n                              function (acc: any, cur: any) {\r\n                                  if (Array.isArray(cur)) {\r\n                                      acc.push.apply(acc, flat.call(cur, depth - 1));\r\n                                  } else {\r\n                                      acc.push(cur);\r\n                                  }\r\n                                  return acc;\r\n                              },\r\n                              []\r\n                          )\r\n                        : Array.prototype.slice.call(this);\r\n                },\r\n                writable: true,\r\n            });\r\n        }\r\n\r\n        // Currently we do not fully configure the ThinEngine on construction of NativeEngine.\r\n        // Setup resolution scaling based on display settings.\r\n        const devicePixelRatio = window ? window.devicePixelRatio || 1.0 : 1.0;\r\n        this._hardwareScalingLevel = options.adaptToDeviceRatio ? 1.0 / devicePixelRatio : 1.0;\r\n        this._engine.setHardwareScalingLevel(this._hardwareScalingLevel);\r\n        this._lastDevicePixelRatio = devicePixelRatio;\r\n        this.resize();\r\n\r\n        const currentDepthFunction = this.getDepthFunction();\r\n        if (currentDepthFunction) {\r\n            this.setDepthFunction(currentDepthFunction);\r\n        }\r\n\r\n        // Shader processor\r\n        this._shaderProcessor = new WebGL2ShaderProcessor();\r\n\r\n        this.onNewSceneAddedObservable.add((scene) => {\r\n            const originalRender = scene.render;\r\n            scene.render = (...args: Parameters<typeof originalRender>) => {\r\n                this._commandBufferEncoder.beginCommandScope();\r\n                originalRender.apply(scene, args);\r\n                this._commandBufferEncoder.endCommandScope();\r\n            };\r\n        });\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        if (this._boundBuffersVertexArray) {\r\n            this._deleteVertexArray(this._boundBuffersVertexArray);\r\n        }\r\n        this._engine.dispose();\r\n    }\r\n\r\n    /** @internal */\r\n    public static _createNativeDataStream(): NativeDataStream {\r\n        return new NativeDataStream();\r\n    }\r\n\r\n    /**\r\n     * Can be used to override the current requestAnimationFrame requester.\r\n     * @internal\r\n     */\r\n    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number {\r\n        // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\r\n        if (requester.requestAnimationFrame && requester !== window) {\r\n            requester.requestAnimationFrame(bindedRenderFunction);\r\n        } else {\r\n            this._engine.requestAnimationFrame(bindedRenderFunction);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Override default engine behavior.\r\n     * @param framebuffer\r\n     */\r\n    public _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>) {\r\n        if (this._currentFramebuffer !== framebuffer) {\r\n            if (this._currentFramebuffer) {\r\n                this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);\r\n                this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer as NativeFramebuffer);\r\n                this._commandBufferEncoder.finishEncodingCommand();\r\n            }\r\n\r\n            if (framebuffer) {\r\n                this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);\r\n                this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer as NativeFramebuffer);\r\n                this._commandBufferEncoder.finishEncodingCommand();\r\n            }\r\n\r\n            this._currentFramebuffer = framebuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets host document\r\n     * @returns the host document object\r\n     */\r\n    public getHostDocument(): Nullable<Document> {\r\n        return null;\r\n    }\r\n\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        if (this.useReverseDepthBuffer) {\r\n            throw new Error(\"reverse depth buffer is not currently implemented\");\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(1);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public createIndexBuffer(indices: IndicesArray, updateable?: boolean, _label?: string): NativeDataBuffer {\r\n        const data = this._normalizeIndexData(indices);\r\n        const buffer = new NativeDataBuffer();\r\n        buffer.references = 1;\r\n        buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        if (data.byteLength) {\r\n            buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable ?? false);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    public createVertexBuffer(vertices: DataArray, updateable?: boolean, _label?: string): NativeDataBuffer {\r\n        const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);\r\n        const buffer = new NativeDataBuffer();\r\n        buffer.references = 1;\r\n        if (data.byteLength) {\r\n            buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable ?? false);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    protected _recordVertexArrayObject(\r\n        vertexArray: any,\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<NativeDataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        if (indexBuffer) {\r\n            this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer!);\r\n        }\r\n\r\n        const attributes = effect.getAttributesNames();\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = effect.getAttributeLocation(index);\r\n            if (location >= 0) {\r\n                const kind = attributes[index];\r\n                let vertexBuffer: Nullable<VertexBuffer> = null;\r\n\r\n                if (overrideVertexBuffers) {\r\n                    vertexBuffer = overrideVertexBuffers[kind];\r\n                }\r\n                if (!vertexBuffer) {\r\n                    vertexBuffer = vertexBuffers[kind];\r\n                }\r\n\r\n                if (vertexBuffer) {\r\n                    const buffer = vertexBuffer.getBuffer() as Nullable<NativeDataBuffer>;\r\n                    if (buffer && buffer.nativeVertexBuffer) {\r\n                        this._engine.recordVertexBuffer(\r\n                            vertexArray,\r\n                            buffer.nativeVertexBuffer!,\r\n                            location,\r\n                            vertexBuffer.byteOffset,\r\n                            vertexBuffer.byteStride,\r\n                            vertexBuffer.getSize(),\r\n                            getNativeAttribType(vertexBuffer.type),\r\n                            vertexBuffer.normalized,\r\n                            vertexBuffer.getInstanceDivisor()\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public bindBuffers(vertexBuffers: { [key: string]: VertexBuffer }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void {\r\n        if (this._boundBuffersVertexArray) {\r\n            this._deleteVertexArray(this._boundBuffersVertexArray);\r\n        }\r\n        this._boundBuffersVertexArray = this._engine.createVertexArray();\r\n        this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\r\n        this.bindVertexArrayObject(this._boundBuffersVertexArray);\r\n    }\r\n\r\n    public recordVertexArrayObject(\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<NativeDataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): WebGLVertexArrayObject {\r\n        const vertexArray = this._engine.createVertexArray();\r\n        this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);\r\n        return vertexArray;\r\n    }\r\n\r\n    private _deleteVertexArray(vertexArray: NativeVertexArrayObject) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public bindVertexArrayObject(vertexArray: WebGLVertexArrayObject): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray as NativeVertexArrayObject);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public releaseVertexArrayObject(vertexArray: WebGLVertexArrayObject) {\r\n        this._deleteVertexArray(vertexArray as NativeVertexArrayObject);\r\n    }\r\n\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        return this._engine.getAttributes(nativePipelineContext.program, attributesNames);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this._drawCalls.addCount(1, false);\r\n\r\n        if (instancesCount && _native.Engine.COMMAND_DRAWINDEXEDINSTANCED) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXEDINSTANCED);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\r\n        } else {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\r\n        }\r\n\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this._drawCalls.addCount(1, false);\r\n\r\n        if (instancesCount && _native.Engine.COMMAND_DRAWINSTANCED) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINSTANCED);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\r\n        } else {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\r\n        }\r\n\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        // }\r\n    }\r\n\r\n    public createPipelineContext(): IPipelineContext {\r\n        const isAsync = !!(this._caps.parallelShaderCompile && this._engine.createProgramAsync);\r\n        return new NativePipelineContext(this, isAsync);\r\n    }\r\n\r\n    public createMaterialContext(): IMaterialContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    public createDrawContext(): IDrawContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        _rawVertexSourceCode: string,\r\n        _rawFragmentSourceCode: string,\r\n        _rebuildRebind: any,\r\n        defines: Nullable<string>\r\n    ) {\r\n        if (createAsRaw) {\r\n            this.createRawShaderProgram();\r\n        } else {\r\n            this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        if (nativePipelineContext.isAsync) {\r\n            if (nativePipelineContext.onCompiled) {\r\n                const oldHandler = nativePipelineContext.onCompiled;\r\n                nativePipelineContext.onCompiled = () => {\r\n                    oldHandler();\r\n                    action();\r\n                };\r\n            } else {\r\n                nativePipelineContext.onCompiled = action;\r\n            }\r\n        } else {\r\n            action();\r\n        }\r\n    }\r\n\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        throw new Error(\"Not Supported\");\r\n    }\r\n\r\n    public createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>): WebGLProgram {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const vertexInliner = new ShaderCodeInliner(vertexCode);\r\n        vertexInliner.processCode();\r\n        vertexCode = vertexInliner.code;\r\n\r\n        const fragmentInliner = new ShaderCodeInliner(fragmentCode);\r\n        fragmentInliner.processCode();\r\n        fragmentCode = fragmentInliner.code;\r\n\r\n        vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\r\n        fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\r\n\r\n        const onSuccess = () => {\r\n            nativePipelineContext.isCompiled = true;\r\n            nativePipelineContext.onCompiled?.();\r\n            this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (pipelineContext.isAsync) {\r\n            nativePipelineContext.program = this._engine.createProgramAsync(vertexCode, fragmentCode, onSuccess, (error: Error) => {\r\n                nativePipelineContext.compilationError = error;\r\n            });\r\n        } else {\r\n            try {\r\n                nativePipelineContext.program = this._engine.createProgram(vertexCode, fragmentCode);\r\n                onSuccess();\r\n            } catch (e) {\r\n                const message = e?.message;\r\n                throw new Error(\"SHADER ERROR\" + (typeof message === \"string\" ? \"\\n\" + message : \"\"));\r\n            }\r\n        }\r\n\r\n        return nativePipelineContext.program as WebGLProgram;\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    protected _setProgram(program: WebGLProgram): void {\r\n        if (this._currentProgram !== program) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(program as NativeProgram);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            this._currentProgram = program;\r\n        }\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        if (nativePipelineContext && nativePipelineContext.program) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.program);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): WebGLUniformLocation[] {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        return this._engine.getUniforms(nativePipelineContext.program, uniformsNames);\r\n    }\r\n\r\n    public bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n        // TODO\r\n        throw new Error(\"Not Implemented\");\r\n    }\r\n\r\n    public bindSamplers(effect: Effect): void {\r\n        const nativePipelineContext = effect.getPipelineContext() as NativePipelineContext;\r\n        this._setProgram(nativePipelineContext.program as WebGLProgram);\r\n\r\n        // TODO: share this with engine?\r\n        const samplers = effect.getSamplers();\r\n        for (let index = 0; index < samplers.length; index++) {\r\n            const uniform = effect.getUniform(samplers[index]);\r\n\r\n            if (uniform) {\r\n                this._boundUniforms[index] = uniform;\r\n            }\r\n        }\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._engine.getRenderWidth();\r\n    }\r\n\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._engine.getRenderHeight();\r\n    }\r\n\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        this._cachedViewport = viewport;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.width);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.height);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(width);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(height);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        this._zOffset = zOffset;\r\n        this._zOffsetUnits = zOffsetUnits;\r\n        if (this._zOffset !== 0) {\r\n            Tools.Warn(\"zOffset is not supported in Native engine.\");\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets the client rect of native canvas.  Needed for InputManager.\r\n     * @returns a client rectangle\r\n     */\r\n    public getInputElementClientRect(): Nullable<DOMRect> {\r\n        const rect = {\r\n            bottom: this.getRenderHeight(),\r\n            height: this.getRenderHeight(),\r\n            left: 0,\r\n            right: this.getRenderWidth(),\r\n            top: 0,\r\n            width: this.getRenderWidth(),\r\n            x: 0,\r\n            y: 0,\r\n            toJSON: () => {},\r\n        };\r\n        return rect;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Factor to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffset(value: number): void {\r\n        if (value !== this._zOffset) {\r\n            this._zOffset = value;\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);\r\n            this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Factor\r\n     * @returns the current zOffset Factor state\r\n     */\r\n    public getZOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Units to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffsetUnits(value: number): void {\r\n        if (value !== this._zOffsetUnits) {\r\n            this._zOffsetUnits = value;\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);\r\n            this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Units\r\n     * @returns the current zOffset Units state\r\n     */\r\n    public getZOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth buffering\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthBuffer(enable: boolean): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if depth writing is enabled\r\n     * @returns the current depth writing state\r\n     */\r\n    public getDepthWrite(): boolean {\r\n        return this._depthWrite;\r\n    }\r\n\r\n    public getDepthFunction(): Nullable<number> {\r\n        switch (this._currentDepthTest) {\r\n            case _native.Engine.DEPTH_TEST_NEVER:\r\n                return Constants.NEVER;\r\n            case _native.Engine.DEPTH_TEST_ALWAYS:\r\n                return Constants.ALWAYS;\r\n            case _native.Engine.DEPTH_TEST_GREATER:\r\n                return Constants.GREATER;\r\n            case _native.Engine.DEPTH_TEST_GEQUAL:\r\n                return Constants.GEQUAL;\r\n            case _native.Engine.DEPTH_TEST_NOTEQUAL:\r\n                return Constants.NOTEQUAL;\r\n            case _native.Engine.DEPTH_TEST_EQUAL:\r\n                return Constants.EQUAL;\r\n            case _native.Engine.DEPTH_TEST_LESS:\r\n                return Constants.LESS;\r\n            case _native.Engine.DEPTH_TEST_LEQUAL:\r\n                return Constants.LEQUAL;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public setDepthFunction(depthFunc: number) {\r\n        let nativeDepthFunc = 0;\r\n        switch (depthFunc) {\r\n            case Constants.NEVER:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;\r\n                break;\r\n            case Constants.ALWAYS:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;\r\n                break;\r\n            case Constants.GREATER:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;\r\n                break;\r\n            case Constants.GEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;\r\n                break;\r\n            case Constants.NOTEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;\r\n                break;\r\n            case Constants.EQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;\r\n                break;\r\n            case Constants.LESS:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;\r\n                break;\r\n            case Constants.LEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;\r\n                break;\r\n        }\r\n\r\n        this._currentDepthTest = nativeDepthFunc;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthWrite(enable: boolean): void {\r\n        this._depthWrite = enable;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        this._colorWrite = enable;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWrite;\r\n    }\r\n\r\n    private applyStencil(): void {\r\n        this._setStencil(\r\n            this._stencilMask,\r\n            getNativeStencilOpFail(this._stencilOpStencilFail),\r\n            getNativeStencilDepthFail(this._stencilOpDepthFail),\r\n            getNativeStencilDepthPass(this._stencilOpStencilDepthPass),\r\n            getNativeStencilFunc(this._stencilFunc),\r\n            this._stencilFuncRef\r\n        );\r\n    }\r\n\r\n    private _setStencil(mask: number, stencilOpFail: number, depthOpFail: number, depthOpPass: number, func: number, ref: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(func);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the stencil buffer\r\n     * @param enable defines if the stencil buffer must be enabled or disabled\r\n     */\r\n    public setStencilBuffer(enable: boolean): void {\r\n        this._stencilTest = enable;\r\n        if (enable) {\r\n            this.applyStencil();\r\n        } else {\r\n            this._setStencil(\r\n                255,\r\n                _native.Engine.STENCIL_OP_FAIL_S_KEEP,\r\n                _native.Engine.STENCIL_OP_FAIL_Z_KEEP,\r\n                _native.Engine.STENCIL_OP_PASS_Z_KEEP,\r\n                _native.Engine.STENCIL_TEST_ALWAYS,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if stencil buffer is enabled\r\n     * @returns the current stencil buffer state\r\n     */\r\n    public getStencilBuffer(): boolean {\r\n        return this._stencilTest;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when stencil passes\r\n     * @returns a number defining stencil operation to use when stencil passes\r\n     */\r\n    public getStencilOperationPass(): number {\r\n        return this._stencilOpStencilDepthPass;\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when stencil passes\r\n     * @param operation defines the stencil operation to use when stencil passes\r\n     */\r\n    public setStencilOperationPass(operation: number): void {\r\n        this._stencilOpStencilDepthPass = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil mask\r\n     * @param mask defines the new stencil mask to use\r\n     */\r\n    public setStencilMask(mask: number): void {\r\n        this._stencilMask = mask;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil function\r\n     * @param stencilFunc defines the new stencil function to use\r\n     */\r\n    public setStencilFunction(stencilFunc: number) {\r\n        this._stencilFunc = stencilFunc;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil reference\r\n     * @param reference defines the new stencil reference to use\r\n     */\r\n    public setStencilFunctionReference(reference: number) {\r\n        this._stencilFuncRef = reference;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil mask\r\n     * @param mask defines the new stencil mask to use\r\n     */\r\n    public setStencilFunctionMask(mask: number) {\r\n        this._stencilFuncMask = mask;\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when stencil fails\r\n     * @param operation defines the stencil operation to use when stencil fails\r\n     */\r\n    public setStencilOperationFail(operation: number): void {\r\n        this._stencilOpStencilFail = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when depth fails\r\n     * @param operation defines the stencil operation to use when depth fails\r\n     */\r\n    public setStencilOperationDepthFail(operation: number): void {\r\n        this._stencilOpDepthFail = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil mask\r\n     * @returns a number defining the new stencil mask to use\r\n     */\r\n    public getStencilMask(): number {\r\n        return this._stencilMask;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil function\r\n     * @returns a number defining the stencil function to use\r\n     */\r\n    public getStencilFunction(): number {\r\n        return this._stencilFunc;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil reference value\r\n     * @returns a number defining the stencil reference value to use\r\n     */\r\n    public getStencilFunctionReference(): number {\r\n        return this._stencilFuncRef;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil mask\r\n     * @returns a number defining the stencil mask to use\r\n     */\r\n    public getStencilFunctionMask(): number {\r\n        return this._stencilFuncMask;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when stencil fails\r\n     * @returns a number defining stencil operation to use when stencil fails\r\n     */\r\n    public getStencilOperationFail(): number {\r\n        return this._stencilOpStencilFail;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when depth fails\r\n     * @returns a number defining stencil operation to use when depth fails\r\n     */\r\n    public getStencilOperationDepthFail(): number {\r\n        return this._stencilOpDepthFail;\r\n    }\r\n\r\n    /**\r\n     * Sets alpha constants used by some alpha blending modes\r\n     * @param r defines the red component\r\n     * @param g defines the green component\r\n     * @param b defines the blue component\r\n     * @param a defines the alpha component\r\n     */\r\n    public setAlphaConstants(r: number, g: number, b: number, a: number) {\r\n        throw new Error(\"Setting alpha blend constant color not yet implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the BABYLON.Constants.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     */\r\n    public setAlphaMode(mode: number, noDepthWriteChange: boolean = false): void {\r\n        if (this._alphaMode === mode) {\r\n            return;\r\n        }\r\n\r\n        const nativeMode = getNativeAlphaMode(mode);\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n\r\n        if (!noDepthWriteChange) {\r\n            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        this._alphaMode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets the current alpha mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     * @returns the current alpha mode\r\n     */\r\n    public getAlphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    public setInt(uniform: WebGLUniformLocation, int: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32(int);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setArray(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray2(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray2(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray3(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray3(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray4(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray4(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n\r\n        return true;\r\n    }\r\n\r\n    public setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat(uniform: WebGLUniformLocation, value: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(value);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(w);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setColor3(uniform: WebGLUniformLocation, color3: IColor3Like): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this.setFloat3(uniform, color3.r, color3.g, color3.b);\r\n        return true;\r\n    }\r\n\r\n    public setColor4(uniform: WebGLUniformLocation, color3: IColor3Like, alpha: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\r\n        return true;\r\n    }\r\n\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames) {\r\n            return;\r\n        }\r\n        this.resetTextureCache();\r\n        this._currentEffect = null;\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n\r\n            this._stencilStateComposer.reset();\r\n            this._depthCullingState.reset();\r\n            this._alphaState.reset();\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    protected _createTexture(): WebGLTexture {\r\n        return this._engine.createTexture();\r\n    }\r\n\r\n    protected _deleteTexture(texture: Nullable<WebGLTexture>): void {\r\n        if (texture) {\r\n            this._engine.deleteTexture(texture as NativeTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param canvas defines the canvas containing the source\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     */\r\n    public updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: any, invertY: boolean, premulAlpha: boolean = false, format?: number): void {\r\n        if (premulAlpha === void 0) {\r\n            premulAlpha = false;\r\n        }\r\n\r\n        if (!!texture && !!texture._hardwareTexture) {\r\n            const source = canvas.getCanvasTexture();\r\n            const destination = texture._hardwareTexture.underlyingResource;\r\n            this._engine.copyTexture(destination, source);\r\n            texture.isReady = true;\r\n        }\r\n    }\r\n\r\n    public createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n        // it's not possible to create 0x0 texture sized. Many bgfx methods assume texture size is at least 1x1(best case).\r\n        // Worst case is getting a crash/assert.\r\n        width = Math.max(width, 1);\r\n        height = Math.max(height, 1);\r\n        return this.createRawTexture(new Uint8Array(width * height * 4), width, height, Constants.TEXTUREFORMAT_RGBA, false, false, samplingMode);\r\n    }\r\n\r\n    public createVideoElement(constraints: MediaTrackConstraints): any {\r\n        // create native object depending on stream. Only NativeCamera is supported for now.\r\n        if (this._camera) {\r\n            return this._camera.createVideo(constraints);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n        if (texture && texture._hardwareTexture && this._camera) {\r\n            const webGLTexture = texture._hardwareTexture.underlyingResource;\r\n            this._camera.updateVideoTexture(webGLTexture, video, invertY);\r\n        }\r\n    }\r\n\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n\r\n        texture.format = format;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = texture.baseWidth;\r\n        texture.height = texture.baseHeight;\r\n        texture._compression = compression;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n        this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n\r\n        if (texture._hardwareTexture) {\r\n            const webGLTexture = texture._hardwareTexture.underlyingResource;\r\n            const filter = getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(webGLTexture, filter);\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n        return texture;\r\n    }\r\n\r\n    public createRawTexture2DArray(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.is2DArray = true;\r\n\r\n        if (texture._hardwareTexture) {\r\n            const nativeTexture = texture._hardwareTexture.underlyingResource;\r\n            this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, getNativeTextureFormat(format, textureType), generateMipMaps, invertY);\r\n\r\n            const filter = getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(nativeTexture, filter);\r\n        }\r\n\r\n        texture.isReady = true;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n        return texture;\r\n    }\r\n\r\n    public updateRawTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        bufferView: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): void {\r\n        if (!texture) {\r\n            return;\r\n        }\r\n\r\n        if (bufferView && texture._hardwareTexture) {\r\n            const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n            this._engine.loadRawTexture(\r\n                underlyingResource,\r\n                bufferView,\r\n                texture.width,\r\n                texture.height,\r\n                getNativeTextureFormat(format, type),\r\n                texture.generateMipMaps,\r\n                texture.invertY\r\n            );\r\n        }\r\n\r\n        texture.isReady = true;\r\n    }\r\n\r\n    // TODO: Refactor to share more logic with babylon.engine.ts version.\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a NativeTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        url = url || \"\";\r\n        const fromData = url.substr(0, 5) === \"data:\";\r\n        //const fromBlob = url.substr(0, 5) === \"blob:\";\r\n        const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\r\n\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\r\n\r\n        const originalUrl = url;\r\n        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\r\n            url = this._transformTextureUrl(url);\r\n        }\r\n\r\n        // establish the file extension, if possible\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        let loader: Nullable<IInternalTextureLoader> = null;\r\n        for (const availableLoader of Engine._TextureLoaders) {\r\n            if (availableLoader.canLoad(extension)) {\r\n                loader = availableLoader;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (scene) {\r\n            scene.addPendingData(texture);\r\n        }\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);\r\n\r\n        if (!this.doNotHandleContextLost) {\r\n            // Keep a link to the buffer only if we plan to handle context lost\r\n            texture._buffer = buffer;\r\n        }\r\n\r\n        let onLoadObserver: Nullable<Observer<InternalTexture>> = null;\r\n        if (onLoad && !fallback) {\r\n            onLoadObserver = texture.onLoadedObservable.add(onLoad);\r\n        }\r\n\r\n        if (!fallback) {\r\n            this._internalTexturesCache.push(texture);\r\n        }\r\n\r\n        const onInternalError = (message?: string, exception?: any) => {\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            if (url === originalUrl) {\r\n                if (onLoadObserver) {\r\n                    texture.onLoadedObservable.remove(onLoadObserver);\r\n                }\r\n\r\n                if (EngineStore.UseFallbackTexture) {\r\n                    this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\r\n                }\r\n\r\n                if (onError) {\r\n                    onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\r\n                }\r\n            } else {\r\n                // fall back to the original url if the transformed url fails to load\r\n                Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\r\n                this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\r\n            }\r\n        };\r\n\r\n        // processing for non-image formats\r\n        if (loader) {\r\n            throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\r\n        } else {\r\n            const onload = (data: ArrayBufferView) => {\r\n                if (!texture._hardwareTexture) {\r\n                    if (scene) {\r\n                        scene.removePendingData(texture);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n\r\n                this._engine.loadTexture(\r\n                    underlyingResource,\r\n                    data,\r\n                    !noMipmap,\r\n                    invertY,\r\n                    texture._useSRGBBuffer,\r\n                    () => {\r\n                        texture.baseWidth = this._engine.getTextureWidth(underlyingResource);\r\n                        texture.baseHeight = this._engine.getTextureHeight(underlyingResource);\r\n                        texture.width = texture.baseWidth;\r\n                        texture.height = texture.baseHeight;\r\n                        texture.isReady = true;\r\n\r\n                        const filter = getNativeSamplingMode(samplingMode);\r\n                        this._setTextureSampling(underlyingResource, filter);\r\n\r\n                        if (scene) {\r\n                            scene.removePendingData(texture);\r\n                        }\r\n\r\n                        texture.onLoadedObservable.notifyObservers(texture);\r\n                        texture.onLoadedObservable.clear();\r\n                    },\r\n                    () => {\r\n                        throw new Error(\"Could not load a native texture.\");\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (fromData && buffer) {\r\n                if (buffer instanceof ArrayBuffer) {\r\n                    onload(new Uint8Array(buffer));\r\n                } else if (ArrayBuffer.isView(buffer)) {\r\n                    onload(buffer);\r\n                } else if (typeof buffer === \"string\") {\r\n                    onload(new Uint8Array(Tools.DecodeBase64(buffer)));\r\n                } else {\r\n                    throw new Error(\"Unsupported buffer type\");\r\n                }\r\n            } else {\r\n                if (isBase64) {\r\n                    onload(new Uint8Array(Tools.DecodeBase64(url)));\r\n                } else {\r\n                    this._loadFile(\r\n                        url,\r\n                        (data) => onload(new Uint8Array(data as ArrayBuffer)),\r\n                        undefined,\r\n                        undefined,\r\n                        true,\r\n                        (request?: IWebRequest, exception?: any) => {\r\n                            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external native texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @param hasMipMaps defines whether the external texture has mip maps\r\n     * @param samplingMode defines the sampling mode for the external texture (default: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE)\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapNativeTexture(texture: NativeTexture, hasMipMaps: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE): InternalTexture {\r\n        const hardwareTexture = new NativeHardwareTexture(texture, this._engine);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.baseWidth = this._engine.getTextureWidth(texture);\r\n        internalTexture.baseHeight = this._engine.getTextureHeight(texture);\r\n        internalTexture.width = internalTexture.baseWidth;\r\n        internalTexture.height = internalTexture.baseHeight;\r\n        internalTexture.isReady = true;\r\n        internalTexture.useMipMaps = hasMipMaps;\r\n        this.updateTextureSamplingMode(samplingMode, internalTexture);\r\n        return internalTexture;\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapNativeTexture instead.\");\r\n    }\r\n\r\n    public _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n        // TODO: handle other options?\r\n        const generateStencil = options.generateStencil || false;\r\n        const samples = options.samples || 1;\r\n\r\n        const nativeRTWrapper = rtWrapper as NativeRenderTargetWrapper;\r\n        const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n\r\n        const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture!.underlyingResource, width, height, generateStencil, true, samples);\r\n        nativeRTWrapper._framebufferDepthStencil = framebuffer;\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseFramebufferObjects(framebuffer: Nullable<NativeFramebuffer>): void {\r\n        if (framebuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer as NativeData);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        const promise = new Promise<ImageBitmap>((resolve, reject) => {\r\n            const image = this.createCanvasImage();\r\n            image.onload = () => {\r\n                try {\r\n                    const imageBitmap = this._engine.createImageBitmap(image);\r\n                    resolve(imageBitmap);\r\n                } catch (error) {\r\n                    reject(`Error loading image ${image.src} with exception: ${error}`);\r\n                }\r\n            };\r\n            image.onerror = (error) => {\r\n                reject(`Error loading image ${image.src} with exception: ${error}`);\r\n            };\r\n\r\n            image.src = imageSource;\r\n        });\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for createImageBitmap\r\n     * @param image source for image\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return new Promise((resolve, reject) => {\r\n            if (Array.isArray(image)) {\r\n                const arr = <Array<ArrayBufferView>>image;\r\n                if (arr.length) {\r\n                    const image = this._engine.createImageBitmap(arr[0]);\r\n                    if (image) {\r\n                        resolve(image);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            reject(`Unsupported data for createImageBitmap.`);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\r\n     */\r\n    public resizeImageBitmap(image: ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture\r\n     * @param rootUrl defines the url where the files to load is located\r\n     * @param scene defines the current scene\r\n     * @param files defines the list of files to load (1 per face)\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public createCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        files: Nullable<string[]>,\r\n        noMipmap?: boolean,\r\n        onLoad: Nullable<(data?: any) => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format?: number,\r\n        forcedExtension: any = null,\r\n        createPolynomials = false,\r\n        lodScale: number = 0,\r\n        lodOffset: number = 0,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n        texture.isCube = true;\r\n        texture.url = rootUrl;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture._lodGenerationScale = lodScale;\r\n        texture._lodGenerationOffset = lodOffset;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !!noMipmap);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._extension = forcedExtension;\r\n            texture._files = files;\r\n        }\r\n\r\n        const lastDot = rootUrl.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        // TODO: use texture loader to load env files?\r\n        if (extension === \".env\") {\r\n            const onloaddata = (data: ArrayBufferView) => {\r\n                const info = GetEnvInfo(data)!;\r\n                texture.width = info.width;\r\n                texture.height = info.width;\r\n\r\n                UploadEnvSpherical(texture, info);\r\n\r\n                const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n                if (!specularInfo) {\r\n                    throw new Error(`Nothing else parsed so far`);\r\n                }\r\n\r\n                texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n                const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n                texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                texture.generateMipMaps = true;\r\n                texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\r\n                texture._isRGBD = true;\r\n                texture.invertY = true;\r\n\r\n                this._engine.loadCubeTextureWithMips(\r\n                    texture._hardwareTexture!.underlyingResource,\r\n                    imageData,\r\n                    false,\r\n                    texture._useSRGBBuffer,\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    () => {\r\n                        throw new Error(\"Could not load a native cube texture.\");\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (files && files.length === 6) {\r\n                throw new Error(`Multi-file loading not allowed on env files.`);\r\n            } else {\r\n                const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n                    if (onError && request) {\r\n                        onError(request.status + \" \" + request.statusText, exception);\r\n                    }\r\n                };\r\n\r\n                this._loadFile(\r\n                    rootUrl,\r\n                    (data) => {\r\n                        onloaddata(new Uint8Array(data as ArrayBuffer, 0, (data as ArrayBuffer).byteLength));\r\n                    },\r\n                    undefined,\r\n                    undefined,\r\n                    true,\r\n                    onInternalError\r\n                );\r\n            }\r\n        } else {\r\n            if (!files || files.length !== 6) {\r\n                throw new Error(\"Cannot load cubemap because 6 files were not defined\");\r\n            }\r\n\r\n            // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\r\n            const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\r\n            Promise.all(reorderedFiles.map((file) => this._loadFileAsync(file, undefined, true).then((data) => new Uint8Array(data, 0, data.byteLength))))\r\n                .then((data) => {\r\n                    return new Promise<void>((resolve, reject) => {\r\n                        this._engine.loadCubeTexture(texture._hardwareTexture!.underlyingResource, data, !noMipmap, true, texture._useSRGBBuffer, resolve, reject);\r\n                    });\r\n                })\r\n                .then(\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    (error) => {\r\n                        if (onError) {\r\n                            onError(`Failed to load cubemap: ${error.message}`, error);\r\n                        }\r\n                    }\r\n                );\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new NativeHardwareTexture(this._createTexture() as NativeTexture, this._engine);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper {\r\n        const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);\r\n        this._renderTargetWrapperCache.push(rtWrapper);\r\n        return rtWrapper;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        _delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        let generateMipMaps = false;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        let samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        let format = Constants.TEXTUREFORMAT_RGBA;\r\n        let useSRGBBuffer = false;\r\n        let samples = 1;\r\n        let label: string | undefined;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateMipMaps = !!options.generateMipMaps;\r\n            type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\r\n            samples = options.samples ?? 1;\r\n            label = options.label;\r\n        } else {\r\n            generateMipMaps = !!options;\r\n        }\r\n\r\n        useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n\r\n        const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n        if (layers !== 0) {\r\n            throw new Error(\"Texture layers are not supported in Babylon Native\");\r\n        }\r\n\r\n        const nativeTexture = texture._hardwareTexture!.underlyingResource;\r\n        const nativeTextureFormat = getNativeTextureFormat(format, type);\r\n        // REVIEW: We are always setting the renderTarget flag as we don't know whether the texture will be used as a render target.\r\n        this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer, samples);\r\n        this._setTextureSampling(nativeTexture, getNativeSamplingMode(samplingMode));\r\n\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = samples;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture.format = format;\r\n        texture.label = label;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    public createRenderTargetTexture(size: number | { width: number; height: number }, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper {\r\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as NativeRenderTargetWrapper;\r\n\r\n        let generateDepthBuffer = true;\r\n        let generateStencilBuffer = false;\r\n        let noColorAttachment = false;\r\n        let colorAttachment: InternalTexture | undefined = undefined;\r\n        let samples = 1;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n            generateStencilBuffer = !!options.generateStencilBuffer;\r\n            noColorAttachment = !!options.noColorAttachment;\r\n            colorAttachment = options.colorAttachment;\r\n            samples = options.samples ?? 1;\r\n        }\r\n\r\n        const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n\r\n        const framebuffer = this._engine.createFrameBuffer(\r\n            texture ? texture._hardwareTexture!.underlyingResource : null,\r\n            width,\r\n            height,\r\n            generateStencilBuffer,\r\n            generateDepthBuffer,\r\n            samples\r\n        );\r\n\r\n        rtWrapper._framebuffer = framebuffer;\r\n        rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n        rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n        rtWrapper._samples = samples;\r\n\r\n        rtWrapper.setTextures(texture);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    public updateRenderTargetTextureSampleCount(rtWrapper: RenderTargetWrapper, samples: number): number {\r\n        Logger.Warn(\"Updating render target sample count is not currently supported\");\r\n        return rtWrapper.samples;\r\n    }\r\n\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void {\r\n        if (texture._hardwareTexture) {\r\n            const filter = getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    public bindFramebuffer(texture: RenderTargetWrapper, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void {\r\n        const nativeRTWrapper = texture as NativeRenderTargetWrapper;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n\r\n        this._currentRenderTarget = texture;\r\n\r\n        if (faceIndex) {\r\n            throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\r\n        }\r\n\r\n        if (requiredWidth || requiredHeight) {\r\n            throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\r\n        }\r\n\r\n        if (forceFullscreenViewport) {\r\n            //Not supported yet but don't stop rendering\r\n        }\r\n\r\n        if (nativeRTWrapper._framebufferDepthStencil) {\r\n            this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);\r\n        } else {\r\n            this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);\r\n        }\r\n    }\r\n\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        // NOTE: Disabling mipmap generation is not yet supported in NativeEngine.\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._bindUnboundFramebuffer(null);\r\n    }\r\n\r\n    public createDynamicVertexBuffer(data: DataArray): DataBuffer {\r\n        return this.createVertexBuffer(data, true);\r\n    }\r\n\r\n    public updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n        const buffer = indexBuffer as NativeDataBuffer;\r\n        const data = this._normalizeIndexData(indices);\r\n        buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer!, data.buffer, data.byteOffset, data.byteLength, offset);\r\n    }\r\n\r\n    public updateDynamicVertexBuffer(vertexBuffer: DataBuffer, verticies: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const buffer = vertexBuffer as NativeDataBuffer;\r\n        const data = ArrayBuffer.isView(verticies) ? verticies : new Float32Array(verticies);\r\n        this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer!, data.buffer, data.byteOffset + (byteOffset ?? 0), byteLength ?? data.byteLength);\r\n    }\r\n\r\n    // TODO: Refactor to share more logic with base Engine implementation.\r\n    protected _setTexture(channel: number, texture: Nullable<BaseTexture>, isPartOfTextureArray = false, depthStencilTexture = false): boolean {\r\n        const uniform = this._boundUniforms[channel] as unknown as NativeUniform;\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        // Not ready?\r\n        if (!texture) {\r\n            if (this._boundTexturesCache[channel] != null) {\r\n                this._activeChannel = channel;\r\n                this._boundTexturesCache[channel] = null;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // Video\r\n        if ((<VideoTexture>texture).video) {\r\n            this._activeChannel = channel;\r\n            (<VideoTexture>texture).update();\r\n        } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            // Delay loading\r\n            texture.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        let internalTexture: InternalTexture;\r\n        if (depthStencilTexture) {\r\n            internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n        } else if (texture.isReady()) {\r\n            internalTexture = <InternalTexture>texture.getInternalTexture();\r\n        } else if (texture.isCube) {\r\n            internalTexture = this.emptyCubeTexture;\r\n        } else if (texture.is3D) {\r\n            internalTexture = this.emptyTexture3D;\r\n        } else if (texture.is2DArray) {\r\n            internalTexture = this.emptyTexture2DArray;\r\n        } else {\r\n            internalTexture = this.emptyTexture;\r\n        }\r\n\r\n        this._activeChannel = channel;\r\n\r\n        if (!internalTexture || !internalTexture._hardwareTexture) {\r\n            return false;\r\n        }\r\n\r\n        this._setTextureWrapMode(\r\n            internalTexture._hardwareTexture.underlyingResource,\r\n            getNativeAddressMode(texture.wrapU),\r\n            getNativeAddressMode(texture.wrapV),\r\n            getNativeAddressMode(texture.wrapR)\r\n        );\r\n        this._updateAnisotropicLevel(texture);\r\n\r\n        this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);\r\n\r\n        return true;\r\n    }\r\n\r\n    // filter is a NativeFilter.XXXX value.\r\n    private _setTextureSampling(texture: NativeTexture, filter: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    // addressModes are NativeAddressMode.XXXX values.\r\n    private _setTextureWrapMode(texture: NativeTexture, addressModeU: number, addressModeV: number, addressModeW: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    private _setTextureCore(uniform: NativeUniform, texture: NativeTexture) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    // TODO: Share more of this logic with the base implementation.\r\n    // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\r\n    private _updateAnisotropicLevel(texture: BaseTexture) {\r\n        const internalTexture = texture.getInternalTexture();\r\n        const value = texture.anisotropicFilteringLevel;\r\n\r\n        if (!internalTexture || !internalTexture._hardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            internalTexture._cachedAnisotropicFilteringLevel = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture): void {\r\n        const uniform = this._boundUniforms[channel] as unknown as NativeUniform;\r\n        if (!uniform) {\r\n            return;\r\n        }\r\n        if (texture && texture._hardwareTexture) {\r\n            const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n            this._setTextureCore(uniform, underlyingResource);\r\n        }\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: NativeDataBuffer): void {\r\n        if (buffer.nativeIndexBuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            delete buffer.nativeIndexBuffer;\r\n        }\r\n\r\n        if (buffer.nativeVertexBuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            delete buffer.nativeVertexBuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a canvas\r\n     * @param width width\r\n     * @param height height\r\n     * @returns ICanvas interface\r\n     */\r\n    public createCanvas(width: number, height: number): ICanvas {\r\n        if (!_native.Canvas) {\r\n            throw new Error(\"Native Canvas plugin not available.\");\r\n        }\r\n        const canvas = new _native.Canvas();\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Create an image to use with canvas\r\n     * @returns IImage interface\r\n     */\r\n    public createCanvasImage(): IImage {\r\n        if (!_native.Canvas) {\r\n            throw new Error(\"Native Canvas plugin not available.\");\r\n        }\r\n        const image = new _native.Image();\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        throw new Error(\"updateTextureData not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex: number = 0, lod: number = 0) {\r\n        throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\r\n    }\r\n\r\n    public getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        // TODO\r\n        const result = { ascent: 0, height: 0, descent: 0 };\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * No equivalent for native. Do nothing.\r\n     */\r\n    public flushFramebuffer(): void {}\r\n\r\n    public _readTexturePixels(\r\n        texture: InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        faceIndex?: number,\r\n        level?: number,\r\n        buffer?: Nullable<ArrayBufferView>,\r\n        _flushRenderer?: boolean,\r\n        _noDataConversion?: boolean,\r\n        x?: number,\r\n        y?: number\r\n    ): Promise<ArrayBufferView> {\r\n        if (faceIndex !== undefined && faceIndex !== -1) {\r\n            throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);\r\n        }\r\n\r\n        return this._engine\r\n            .readTexture(\r\n                texture._hardwareTexture?.underlyingResource,\r\n                level ?? 0,\r\n                x ?? 0,\r\n                y ?? 0,\r\n                width,\r\n                height,\r\n                buffer?.buffer ?? null,\r\n                buffer?.byteOffset ?? 0,\r\n                buffer?.byteLength ?? 0\r\n            )\r\n            .then((rawBuffer) => {\r\n                if (!buffer) {\r\n                    buffer = new Uint8Array(rawBuffer);\r\n                }\r\n\r\n                return buffer;\r\n            });\r\n    }\r\n}\r\n", "import { RegisterNativeTypeAsync } from \"../../Engines/nativeEngine\";\r\n\r\n/** @internal */\r\ninterface INativeXRFrame extends XRFrame {\r\n    // Native-only helper functions\r\n    getPoseData: (space: XRSpace, baseSpace: XRReferenceSpace, vectorBuffer: ArrayBuffer, matrixBuffer: ArrayBuffer) => XRPose;\r\n    _imageTrackingResults?: XRImageTrackingResult[];\r\n}\r\n\r\n/** @internal */\r\nexport class NativeXRFrame implements XRFrame {\r\n    private readonly _xrTransform = new XRRigidTransform();\r\n    private readonly _xrPose: XRPose = {\r\n        transform: this._xrTransform,\r\n        emulatedPosition: false,\r\n    };\r\n    // Enough space for position, orientation\r\n    private readonly _xrPoseVectorData = new Float32Array(4 + 4);\r\n\r\n    public get session(): XRSession {\r\n        return this._nativeImpl.session;\r\n    }\r\n\r\n    constructor(private _nativeImpl: INativeXRFrame) {}\r\n\r\n    public getPose(space: XRSpace, baseSpace: XRReferenceSpace): XRPose | undefined {\r\n        if (!this._nativeImpl.getPoseData(space, baseSpace, this._xrPoseVectorData.buffer, this._xrTransform.matrix.buffer)) {\r\n            return undefined;\r\n        }\r\n        const position = this._xrTransform.position as DOMPoint;\r\n        position.x = this._xrPoseVectorData[0];\r\n        position.y = this._xrPoseVectorData[1];\r\n        position.z = this._xrPoseVectorData[2];\r\n        position.w = this._xrPoseVectorData[3];\r\n\r\n        const orientation = this._xrTransform.orientation as DOMPoint;\r\n        orientation.x = this._xrPoseVectorData[4];\r\n        orientation.y = this._xrPoseVectorData[5];\r\n        orientation.z = this._xrPoseVectorData[6];\r\n        orientation.w = this._xrPoseVectorData[7];\r\n        return this._xrPose;\r\n    }\r\n\r\n    public readonly fillPoses = this._nativeImpl.fillPoses!.bind(this._nativeImpl);\r\n\r\n    public readonly getViewerPose = this._nativeImpl.getViewerPose.bind(this._nativeImpl);\r\n\r\n    public readonly getHitTestResults = this._nativeImpl.getHitTestResults.bind(this._nativeImpl);\r\n\r\n    public readonly getHitTestResultsForTransientInput = () => {\r\n        throw new Error(\"XRFrame.getHitTestResultsForTransientInput not supported on native.\");\r\n    };\r\n\r\n    public get trackedAnchors(): XRAnchorSet | undefined {\r\n        return this._nativeImpl.trackedAnchors;\r\n    }\r\n\r\n    public readonly createAnchor = this._nativeImpl.createAnchor!.bind(this._nativeImpl);\r\n\r\n    public get worldInformation(): XRWorldInformation | undefined {\r\n        return this._nativeImpl.worldInformation;\r\n    }\r\n\r\n    public get detectedPlanes(): XRPlaneSet | undefined {\r\n        return this._nativeImpl.detectedPlanes;\r\n    }\r\n\r\n    public readonly getJointPose = this._nativeImpl.getJointPose!.bind(this._nativeImpl);\r\n\r\n    public readonly fillJointRadii = this._nativeImpl.fillJointRadii!.bind(this._nativeImpl);\r\n\r\n    public readonly getLightEstimate = () => {\r\n        throw new Error(\"XRFrame.getLightEstimate not supported on native.\");\r\n    };\r\n\r\n    public get featurePointCloud(): number[] | undefined {\r\n        return this._nativeImpl.featurePointCloud;\r\n    }\r\n\r\n    public readonly getImageTrackingResults = (): XRImageTrackingResult[] => {\r\n        return this._nativeImpl._imageTrackingResults ?? [];\r\n    };\r\n\r\n    public getDepthInformation(view: XRView): XRCPUDepthInformation | undefined {\r\n        throw new Error(\"This function is not available in Babylon Native\");\r\n        // return this._nativeImpl.getDepthInformation(view);\r\n    }\r\n}\r\n\r\nRegisterNativeTypeAsync(\"NativeXRFrame\", NativeXRFrame);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDM,IAAO,qBAAP,MAAO,4BAA2B,qBAAoB;;;;;;EAgCxD,YACI,mBAIgB,UAAsC,CAAA,GAAE;AAExD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAnCZ,SAAA,aAAa,IAAI,QAAQ,GAAG,GAAG,EAAE;AACjC,SAAA,OAAO,IAAI,OAAM;AACjB,SAAA,mBAAmB;AACnB,SAAA,UAAU,IAAI,QAAQ,GAAG,GAAG,CAAC;AAgB9B,SAAA,yBAAwC,CAAA;AAIxC,SAAA,4BAAiE,IAAI,WAAU;AAiH9E,SAAA,oBAAoB,CAAC,cAA4B;AACrD,YAAM,OAAO,UAAU,IAAI,CAAC,WAAU;AAClC,cAAM,MAAM,OAAO,UAAU,OAAO,SAAS;AAC7C,YAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,cAAI,6BAA4B;;AAGpC,YAAI,KAAK,QAAQ,iBAAiB;AAC9B,cAAI,cAAc,KAAK,QAAQ,gBAAgB,eAAc,GAAI,GAAG;;AAExE,eAAO;UACH,aAAa;UACb,sBAAsB;;MAE9B,CAAC;AAED,WAAK,yBAAyB;AAC9B,WAAK,0BAA0B,gBAAgB,IAAI;IACvD;AAGQ,SAAA,YAAY,CAAC,UAA6B;AAC9C,UAAI,CAAC,KAAK,kBAAkB;AACxB;;AAEJ,0BAAmB,yBAAyB,OAAO,KAAK,kBAAkB,cAAc;IAC5F;AA5HI,SAAK,sBAAsB;AAC3B,UAAM,KAAK,6CAA6C;EAC5D;;;;;;;;;;EAWO,OAAO,iBAAiB,WAAsB,OAAc,gBAAkC,QAAyC;AAC1I,WAAO,UAAU,eAAgB,OAAO,cAAc,EAAE,KAAK,CAAC,YAAW;AACrE,YAAM,iBAAiB,WAAW,CAAC,WAAW,CAAC,CAAC,OAAO;AACvD,aAAO,QAAQ,OAAO,cAAc;IACxC,CAAC;EACL;;;;;;;EAQO,OAAO,yBAAyB,OAA2B,gBAAgC;AAC9F,UAAM,gBAAgB,MAAM,MAAM,QAAQ,MAAM,YAAY,gBAAgB,cAAc;AAC1F,QAAI,CAAC,eAAe;AAChB,aAAO,QAAQ,QAAQ,CAAA,CAAE;;AAE7B,UAAM,YAAY,IAAI,MAAM,cAAc,SAAS;AAEnD,WAAO,KAAK,iBAAiB,MAAM,MAAM,SAAS,WAAW,cAAc;EAC/E;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAEX,QAAI,KAAK,QAAQ,uBAAuB;AACpC,WAAK,kBAAkB,QAAQ,iBAAiB,UAAU,KAAK,WAAW,KAAK;;AAGnF,WAAO;EACX;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,SAAK,mBAAmB;AACxB,SAAK,kBAAkB,QAAQ,oBAAoB,UAAU,KAAK,SAAS;AAC3E,WAAO;EACX;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,0BAA0B,MAAK;EACxC;EAEU,WAAW,OAAc;AAE/B,QAAI,CAAC,KAAK,YAAY,KAAK,QAAQ,uBAAuB;AACtD;;AAEJ,UAAM,OAAO,MAAM,cAAc,KAAK,kBAAkB,cAAc;AACtE,QAAI,CAAC,MAAM;AACP;;AAEJ,WAAO,eAAe,KAAK,UAAU,QAAQ,GAAG,KAAK,IAAI;AACzD,YAAQ,oCAAoC,GAAG,GAAG,GAAG,KAAK,MAAM,KAAK,OAAO;AAC5E,YAAQ,oCAAoC,GAAG,GAAG,IAAI,KAAK,MAAM,KAAK,UAAU;AAChF,SAAK,WAAW,gBAAgB,KAAK,OAAO;AAC5C,SAAK,WAAW,UAAS;AACzB,UAAM,MAAM,IAAI,MACM,EAAE,GAAG,KAAK,QAAQ,GAAG,GAAG,KAAK,QAAQ,GAAG,GAAG,KAAK,QAAQ,GAAG,GAAG,EAAC,GAC/D,EAAE,GAAG,KAAK,WAAW,GAAG,GAAG,KAAK,WAAW,GAAG,GAAG,KAAK,WAAW,GAAG,GAAG,EAAC,CAAE;AAEhG,wBAAmB,iBAAiB,KAAK,kBAAkB,SAAS,KAAK,KAAK,kBAAkB,cAAc,EAAE,KAAK,KAAK,iBAAiB;EAC/I;;AA9HuB,mBAAA,OAAO,iBAAiB;AAMxB,mBAAA,UAAU;AAwJrC,qBAAqB,gBACjB,mBAAmB,MACnB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,mBAAmB,kBAAkB,OAAO;AACjE,GACA,mBAAmB,SACnB,KAAK;;;ACjJT,IAAI,mBAAmB;AAMjB,IAAO,oBAAP,cAAiC,qBAAoB;;;;;EAsCvD,IAAW,8BAA8B,gBAAgC;AACrE,SAAK,iCAAiC;EAC1C;;;;;;EAOA,YACI,mBACQ,WAAsC,CAAA,GAAE;AAEhD,UAAM,iBAAiB;AAFf,SAAA,WAAA;AAhDJ,SAAA,qBAAkC,oBAAI,IAAG;AAEzC,SAAA,kBAAuC,CAAA;AAIvC,SAAA,iBAAuC,CAAA;AAgBxC,SAAA,0BAAoD,IAAI,WAAU;AAIlE,SAAA,4BAAsD,IAAI,WAAU;AAKpE,SAAA,4BAAsD,IAAI,WAAU;AAuBnE,SAAA,aAAa,IAAI,QAAO;AACxB,SAAA,iBAAiB,IAAI,WAAU;AAJnC,SAAK,sBAAsB;EAC/B;EAKQ,2BAA2B,UAAmB,oBAA8B;AAChF,SAAK,WAAW,SAAS,QAAQ;AACjC,SAAK,eAAe,SAAS,kBAAkB;AAC/C,QAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,WAAK,WAAW,KAAK;AACrB,WAAK,eAAe,KAAK;AACzB,WAAK,eAAe,KAAK;;AAE7B,WAAO;MACH,UAAU,KAAK;MACf,oBAAoB,KAAK;;EAEjC;;;;;;;;;;;EAYO,MAAM,sCACT,eACA,WAAoB,IAAI,QAAO,GAC/B,qBAAiC,IAAI,WAAU,GAAE;AAGjD,SAAK,2BAA2B,UAAU,kBAAkB;AAE5D,UAAM,IAAI,IAAI,iBACV,EAAE,GAAG,KAAK,WAAW,GAAG,GAAG,KAAK,WAAW,GAAG,GAAG,KAAK,WAAW,EAAC,GAClE,EAAE,GAAG,KAAK,eAAe,GAAG,GAAG,KAAK,eAAe,GAAG,GAAG,KAAK,eAAe,GAAG,GAAG,KAAK,eAAe,EAAC,CAAE;AAE9G,QAAI,CAAC,cAAc,YAAY,cAAc;AACzC,WAAK,OAAM;AACX,YAAM,IAAI,MAAM,iDAAiD;WAC9D;AACH,UAAI;AACA,cAAM,eAAe,MAAM,cAAc,YAAY,aAAa,CAAC;AACnE,eAAO,IAAI,QAAsB,CAAC,SAAS,WAAU;AACjD,eAAK,eAAe,KAAK;YACrB;YACA,UAAU;YACV,WAAW;YACX,kBAAkB;YAClB;YACA;WACH;QACL,CAAC;eACI,OAAO;AACZ,cAAM,IAAI,MAAM,KAAK;;;EAGjC;;;;;;;;;;;;;EAcO,MAAM,oCACT,UACA,qBAAiC,IAAI,WAAU,GAC/C,4BAA4B,OAAK;AAGjC,SAAK,2BAA2B,UAAU,kBAAkB;AAE5D,UAAM,mBAAmB,IAAI,iBACzB,EAAE,GAAG,KAAK,WAAW,GAAG,GAAG,KAAK,WAAW,GAAG,GAAG,KAAK,WAAW,EAAC,GAClE,EAAE,GAAG,KAAK,eAAe,GAAG,GAAG,KAAK,eAAe,GAAG,GAAG,KAAK,eAAe,GAAG,GAAG,KAAK,eAAe,EAAC,CAAE;AAE9G,UAAM,WACF,6BAA6B,KAAK,YAAY,KAAK,kBAAkB,eAC/D,MAAM,KAAK,8BAA8B,kBAAkB,KAAK,kBAAkB,YAAY,IAC9F;AAEV,WAAO,IAAI,QAAsB,CAAC,SAAS,WAAU;AACjD,WAAK,eAAe,KAAK;QACrB,cAAc;QACd,UAAU;QACV,WAAW;QACX;QACA;QACA;OACH;IACL,CAAC;EACL;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK;EAChB;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,QAAI,CAAC,KAAK,SAAS,kCAAkC;AACjD,aAAO,KAAK,gBAAgB,QAAQ;AAChC,cAAM,WAAW,KAAK,gBAAgB,IAAG;AACzC,YAAI,UAAU;AACV,cAAI;AAEA,qBAAS,OAAM;mBACV,GAAG;;AAIZ,eAAK,0BAA0B,gBAAgB,QAAQ;;;;AAKnE,WAAO;EACX;;;;EAKO,UAAO;AACV,SAAK,eAAe,SAAS;AAC7B,UAAM,QAAO;AACb,SAAK,wBAAwB,MAAK;AAClC,SAAK,0BAA0B,MAAK;AACpC,SAAK,0BAA0B,MAAK;EACxC;EAEU,WAAW,OAAc;AAC/B,QAAI,CAAC,KAAK,YAAY,CAAC,OAAO;AAC1B;;AAGJ,UAAM,iBAAiB,MAAM;AAC7B,QAAI,gBAAgB;AAChB,YAAM,WAAW,KAAK,gBACjB,OAAO,CAAC,WAAW,CAAC,eAAe,IAAI,OAAO,QAAQ,CAAC,EACvD,IAAI,CAAC,WAAU;AACZ,cAAM,QAAQ,KAAK,gBAAgB,QAAQ,MAAM;AACjD,eAAO;MACX,CAAC;AACL,UAAI,aAAa;AACjB,eAAS,QAAQ,CAAC,UAAS;AACvB,cAAM,SAAS,KAAK,gBAAgB,OAAO,QAAQ,YAAY,CAAC,EAAE,CAAC;AACnE,aAAK,0BAA0B,gBAAgB,MAAM;AACrD;MACJ,CAAC;AAED,qBAAe,QAAQ,CAAC,aAAY;AAChC,YAAI,CAAC,KAAK,mBAAmB,IAAI,QAAQ,GAAG;AACxC,gBAAM,YAAmC;YACrC,IAAI;YACJ;YACA,QAAQ,MAAM,SAAS,OAAM;;AAEjC,gBAAM,SAAS,KAAK,yBAAyB,UAAU,WAAW,KAAK;AACvE,eAAK,gBAAgB,KAAK,MAAM;AAChC,eAAK,wBAAwB,gBAAgB,MAAM;AAEnD,gBAAM,UAAU,KAAK,eAAe,OAAO,CAAC,iBAAiB,aAAa,iBAAiB,QAAQ;AACnG,gBAAM,SAAS,QAAQ,CAAC;AACxB,cAAI,QAAQ;AACR,mBAAO,QAAQ,MAAM;AACrB,mBAAO,WAAW;;eAEnB;AACH,gBAAM,QAAQ,KAAK,wBAAwB,QAAQ;AACnD,gBAAM,SAAS,KAAK,gBAAgB,KAAK;AACzC,cAAI;AAEA,iBAAK,yBAAyB,UAAU,QAAQ,KAAK;AACrD,gBAAI,OAAO,cAAc;AACrB,qBAAO,aAAa,qBAAqB,OAAO,aAAa,sBAAsB,IAAI,WAAU;AACjG,qBAAO,qBAAqB,UAAU,OAAO,aAAa,SAAS,OAAO,aAAa,oBAAoB,OAAO,aAAa,QAAQ;;AAE3I,iBAAK,0BAA0B,gBAAgB,MAAM;mBAChD,GAAG;AACR,kBAAM,KAAK,6BAA6B;;;MAGpD,CAAC;AACD,WAAK,qBAAqB;;AAI9B,SAAK,eAAe,QAAQ,CAAC,iBAAgB;AACzC,UAAI,CAAC,aAAa,YAAY,CAAC,aAAa,WAAW;AACnD,aAAK,8BAA8B,aAAa,kBAAkB,KAAK,EAAE,KACrE,CAAC,iBAAgB;AACb,uBAAa,eAAe;QAChC,GACA,CAAC,UAAS;AACN,uBAAa,WAAW;AACxB,uBAAa,OAAO,KAAK;QAC7B,CAAC;AAEL,qBAAa,YAAY;;IAEjC,CAAC;EACL;;;;;;EAOQ,wBAAwB,UAAkB;AAC9C,aAAS,IAAI,GAAG,IAAI,KAAK,gBAAgB,QAAQ,EAAE,GAAG;AAClD,UAAI,KAAK,gBAAgB,CAAC,EAAE,aAAa,UAAU;AAC/C,eAAO;;;AAGf,WAAO;EACX;EAEQ,yBAAyB,UAAoB,QAA+B,SAAgB;AAEhG,UAAM,OAAO,QAAQ,QAAQ,SAAS,aAAa,KAAK,kBAAkB,cAAc;AACxF,QAAI,MAAM;AACN,YAAM,MAAM,OAAO,wBAAwB,IAAI,OAAM;AACrD,aAAO,eAAe,KAAK,UAAU,QAAQ,GAAG,GAAG;AACnD,UAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,YAAI,6BAA4B;;AAEpC,aAAO,uBAAuB;AAC9B,UAAI,CAAC,KAAK,SAAS,iBAAiB;aAE7B;AACH,YAAI,cAAc,KAAK,SAAS,gBAAgB,eAAc,GAAI,GAAG;;;AAI7E,WAAqB;EACzB;EAEQ,MAAM,8BAA8B,kBAAoC,SAAgB;AAC5F,QAAI,QAAQ,cAAc;AACtB,UAAI;AACA,eAAO,QAAQ,aAAa,kBAAkB,KAAK,kCAAkC,KAAK,kBAAkB,cAAc;eACrH,OAAO;AACZ,cAAM,IAAI,MAAM,KAAK;;WAEtB;AACH,WAAK,OAAM;AACX,YAAM,IAAI,MAAM,yCAAyC;;EAEjE;;AAvTuB,kBAAA,OAAO,iBAAiB;AAMxB,kBAAA,UAAU;AAqTrC,qBAAqB,gBACjB,kBAAkB,MAClB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,kBAAkB,kBAAkB,OAAO;AAChE,GACA,kBAAkB,OAAO;;;AC/W7B,IAAI,kBAAkB;AAMhB,IAAO,qBAAP,cAAkC,qBAAoB;;;;;;EAmCxD,YACI,mBACQ,WAAuC,CAAA,GAAE;AAEjD,UAAM,iBAAiB;AAFf,SAAA,WAAA;AApCJ,SAAA,kBAAsC,CAAA;AACtC,SAAA,WAAoB;AACpB,SAAA,qBAAiC,oBAAI,IAAG;AAgBzC,SAAA,yBAAkD,IAAI,WAAU;AAIhE,SAAA,2BAAoD,IAAI,WAAU;AAKlE,SAAA,2BAAoD,IAAI,WAAU;AAYrE,SAAK,sBAAsB;AAC3B,QAAI,KAAK,kBAAkB,SAAS;AAChC,WAAK,MAAK;WACP;AACH,WAAK,kBAAkB,gBAAgB,QAAQ,MAAK;AAChD,aAAK,MAAK;MACd,CAAC;;EAET;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,QAAI,CAAC,KAAK,SAAS,iCAAiC;AAChD,aAAO,KAAK,gBAAgB,QAAQ;AAChC,cAAM,WAAW,KAAK,gBAAgB,IAAG;AACzC,YAAI,UAAU;AACV,eAAK,yBAAyB,gBAAgB,QAAQ;;;;AAKlE,WAAO;EACX;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,uBAAuB,MAAK;AACjC,SAAK,yBAAyB,MAAK;AACnC,SAAK,yBAAyB,MAAK;EACvC;;;;;;EAOO,eAAY;AACf,WAAO,OAAO,YAAY;EAC9B;;;;;;;;EASO,MAAM,sBAAmB;AAC5B,QAAI,KAAK,kBAAkB,QAAQ,qBAAqB;AACpD,aAAO,KAAK,kBAAkB,QAAQ,oBAAmB;;AAE7D,WAAO,QAAQ,OAAO,sDAAsD;EAChF;EAEU,WAAW,OAAc;AAtKvC;AAuKQ,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,YAAY,CAAC,OAAO;AAC5C;;AAGJ,UAAM,iBAAiB,MAAM,oBAAkB,WAAM,qBAAN,mBAAwB;AACvE,QAAI,gBAAgB;AAEhB,eAAS,WAAW,GAAG,WAAW,KAAK,gBAAgB,QAAQ,YAAY;AACvE,cAAM,QAAQ,KAAK,gBAAgB,QAAQ;AAC3C,YAAI,CAAC,eAAe,IAAI,MAAM,OAAO,GAAG;AACpC,eAAK,gBAAgB,OAAO,YAAY,CAAC;AACzC,eAAK,yBAAyB,gBAAgB,KAAK;;;AAK3D,qBAAe,QAAQ,CAAC,YAAW;AAC/B,YAAI,CAAC,KAAK,mBAAmB,IAAI,OAAO,GAAG;AACvC,gBAAM,WAAiC;YACnC,IAAI;YACJ;YACA,mBAAmB,CAAA;;AAEvB,gBAAM,QAAQ,KAAK,wBAAwB,SAAS,UAAU,KAAK;AACnE,eAAK,gBAAgB,KAAK,KAAK;AAC/B,eAAK,uBAAuB,gBAAgB,KAAK;eAC9C;AAEH,cAAI,QAAQ,oBAAoB,KAAK,kBAAkB,kBAAkB;AACrE,kBAAM,QAAQ,KAAK,uBAAuB,OAAO;AACjD,kBAAM,QAAQ,KAAK,gBAAgB,KAAK;AACxC,iBAAK,wBAAwB,SAAS,OAAO,KAAK;AAClD,iBAAK,yBAAyB,gBAAgB,KAAK;;;MAG/D,CAAC;AACD,WAAK,qBAAqB;;EAElC;EAEQ,QAAK;AACT,UAAM,eAAe,MAAK;AACtB,WAAK,WAAW;AAChB,UAAI,KAAK,gBAAgB,QAAQ;AAC7B,aAAK,gBAAgB,SAAS;;IAEtC;AAGA,QAAI,CAAC,CAAC,KAAK,kBAAkB,YAAY,CAAC,CAAC,KAAK,SAAS,4BAA4B,CAAC,CAAC,KAAK,kBAAkB,QAAQ,qCAAqC;AACvJ,WAAK,kBAAkB,QAAQ,oCAAoC,KAAK,SAAS,wBAAwB;;AAG7G,QAAI,CAAC,KAAK,kBAAkB,QAAQ,0BAA0B;AAC1D,mBAAY;AACZ;;AAEJ,SAAK,kBAAkB,QAAQ,yBAAyB,EAAE,qBAAqB,EAAE,SAAS,KAAI,EAAE,CAAE;AAClG,iBAAY;EAChB;EAEQ,wBAAwB,SAAkB,OAA6B,SAAgB;AAC3F,UAAM,oBAAoB,QAAQ,QAAQ,IAAI,CAAC,YAAW;AACtD,YAAM,oBAAoB,KAAK,kBAAkB,MAAM,uBAAuB,IAAI;AAClF,aAAO,IAAI,QAAQ,QAAQ,GAAG,QAAQ,GAAG,QAAQ,IAAI,iBAAiB;IAC1E,CAAC;AAED,UAAM,OAAO,QAAQ,QAAQ,QAAQ,YAAY,KAAK,kBAAkB,cAAc;AACtF,QAAI,MAAM;AACN,YAAM,MAAM,MAAM,wBAAwB,IAAI,OAAM;AACpD,aAAO,eAAe,KAAK,UAAU,QAAQ,GAAG,GAAG;AACnD,UAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,YAAI,6BAA4B;;AAEpC,YAAM,uBAAuB;AAC7B,UAAI,KAAK,SAAS,iBAAiB;AAC/B,YAAI,cAAc,KAAK,SAAS,gBAAgB,eAAc,GAAI,GAAG;;;AAI7E,WAAoB;EACxB;;;;;;EAOQ,uBAAuB,SAAgB;AAC3C,aAAS,IAAI,GAAG,IAAI,KAAK,gBAAgB,QAAQ,EAAE,GAAG;AAClD,UAAI,KAAK,gBAAgB,CAAC,EAAE,YAAY,SAAS;AAC7C,eAAO;;;AAGf,WAAO;EACX;;AAlMuB,mBAAA,OAAO,iBAAiB;AAMxB,mBAAA,UAAU;AAgMrC,qBAAqB,gBACjB,mBAAmB,MACnB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,mBAAmB,kBAAkB,OAAO;AACjE,GACA,mBAAmB,OAAO;;;AC1OxB,IAAO,yBAAP,cAAsC,qBAAoB;;;;;;EAsB5D,YACI,mBAIgB,UAA0C,CAAA,GAAE;AAE5D,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAZb,SAAA,qCAA0D,IAAI,WAAU;EAe/E;;;;;;;EAQO,SAAM;AACT,SAAK,oBAAoB,KAAK;AAC9B,WAAO,MAAM,OAAM;EACvB;;;;;;;EAQO,SAAM;AACT,SAAK,oBAAoB,IAAI;AAC7B,WAAO,MAAM,OAAM;EACvB;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,mCAAmC,MAAK;EACjD;EAEU,WAAW,UAAiB;EAEtC;EAEQ,oBAAoB,UAAiB;AACzC,UAAM,QAAQ,KAAK,kBAAkB;AACrC,QAAI,CAAC,KAAK,QAAQ,yBAAyB;AACvC,UAAI,KAAK,QAAQ,+BAA+B;AAC5C,YAAI,KAAK,QAAQ,8BAA8B,QAAQ;AACnD,gBAAM,mBAAmB,MAAM,cAAc,kBAAkB;AAC/D,cAAI,kBAAkB;AAClB,6BAAiB,WAAW,QAAQ;;;AAG5C,YAAI,KAAK,QAAQ,8BAA8B,QAAQ;AACnD,gBAAM,kBAAkB,MAAM,cAAc,iBAAiB;AAC7D,cAAI,iBAAiB;AACjB,4BAAgB,WAAW,QAAQ;;;aAGxC;AACH,cAAM,mBAAmB,MAAM,cAAc,kBAAkB;AAC/D,YAAI,kBAAkB;AAClB,2BAAiB,WAAW,QAAQ;;;;AAKhD,QAAI,KAAK,QAAQ,kBAAkB;AAC/B,WAAK,QAAQ,iBAAiB,QAAQ,CAAC,SAAS,KAAK,WAAW,QAAQ,CAAC;;AAG7E,SAAK,mCAAmC,gBAAgB,QAAQ;EACpE;;AA3FuB,uBAAA,OAAO,iBAAiB;AAMxB,uBAAA,UAAU;AAyFrC,qBAAqB,gBACjB,uBAAuB,MACvB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,uBAAuB,kBAAkB,OAAO;AACrE,GACA,uBAAuB,SACvB,IAAI;;;AC/HF,IAAO,iCAAP,MAAqC;;AA8DrC,IAAO,yBAAP,cAAsC,qBAAoB;EAqCpD,uBAAuB,cAA8B;AACzD,UAAM,eAAuB,KAAK,SAAS,kBAAmB,gBAAgB,gBAAgB;AAC9F,UAAM,eAA0E,KAAK,SAAS,kBAAmB,gBAAgB;AACjI,UAAM,eAAe,aAAa,mBAAmB,aAAa,UAAU;MACxE,WAAW,OAAO,iBAAiB,WAAW,eAAe,aAAa;MAC1E,WAAW,OAAO,iBAAiB,WAAW,eAAe,aAAa;MAC1E,WAAW,OAAO,iBAAiB,WAAW,eAAe,aAAa;KAC7E;AACD,iBAAa,YAAY,KAAK;AAC9B,iBAAa,aAAa;AAC1B,iBAAa,qBAAqB,IAAI,WAAU;AAChD,UAAM,iBAAiB,aAAa,QAAQ,aAAa;AACzD,iBAAa,SAAS,SAAS,eAAe,QAAQ;AACtD,iBAAa,mBAAoB,SAAS,eAAe,kBAAmB;AAC5E,UAAM,WAAW,IAAI,gBAAgB,cAAc,cAAc;MAC7D,MAAM;MACN,GAAG,KAAK,SAAS;KACpB;AACD,SAAK,aAAa,aAAa,QAAQ,IAAI;MACvC;MACA;MACA;;EAER;;;;;;EAoCA,YACI,mBACiB,UAAwC;AAEzD,UAAM,iBAAiB;AAFN,SAAA,WAAA;AAjGb,SAAA,oBAAoB,CAAC,iBAAkC;AAC3D,UAAI,KAAK,aAAa,aAAa,QAAQ,GAAG;AAE1C;;AAEJ,UAAI,CAAC,KAAK,kBAAkB,MAAM,iBAAgB,GAAI;AAClD,eAAO,KAAK,2EAA2E;;AAG3F,UAAI,KAAK,SAAS,kBAAmB,qBAAqB,aAAa,YAAY,SAAS;AACxF,qBAAa,iCAAiC,QAAQ,CAAC,qBAAoB;AACvE,cAAI,CAAC,iBAAiB,0BAA0B;AAC5C,6BAAiB,wBAAwB,QAAQ,MAAK;AAClD,oBAAM,WAAW,IAAI,gBAAgB,iBAAiB,UAAW,gBAAgB,cAAc;gBAC3F,MAAM;gBACN,GAAG,KAAK,SAAS;eACpB;AAED,oBAAM,iBAAiB,aAAa,QAAQ,aAAa;AACzD,mBAAK,aAAa,aAAa,QAAQ,IAAI;gBACvC;gBACA;gBACA,QAAQ,eAAe,SAAS,MAAK;gBACrC,aAAa,eAAe,mBAAoB,MAAK;;YAE7D,CAAC;iBACE;AAEH,iBAAK,uBAAuB,YAAY;;QAEhD,CAAC;aACE;AACH,aAAK,uBAAuB,YAAY;;IAEhD;AA2BQ,SAAA,eASJ,CAAA;AACI,SAAA,aAAa;AACb,SAAA,SAAiB;AAGjB,SAAA,iBAAyB;AACzB,SAAA,iBAA6B,IAAI,WAAU;AAC3C,SAAA,aAAsB,IAAI,QAAO;AAuBrC,QAAI,CAAC,KAAK,SAAS,mBAAmB;AAClC,WAAK,SAAS,oBAAoB,CAAA;;EAE1C;;;;;EAMO,sBAAmB;AACtB,SAAK,aAAa;AAClB,WAAO,KAAK,KAAK,YAAY,EAAE,QAAQ,CAAC,iBAAgB;AACpD,YAAM,iBAAiB,KAAK,aAAa,YAAY;AACrD,UAAI,eAAe,cAAc;AAC7B,uBAAe,aAAa,YAAY;;IAEhD,CAAC;EACL;;;;;EAMO,cAAc,cAA8B;AAC/C,SAAK,kBAAkB,YAAY;EACvC;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,QAAI,CAAC,KAAK,SAAS,SAAS;AACxB,aAAO;;AAGX,SAAK,SAAS,QAAQ,YAAY,QAAQ,KAAK,iBAAiB;AAChE,SAAK,sBAAsB,KAAK,SAAS,QAAQ,6BAA6B,KAAK,iBAAiB;AACpG,SAAK,sBAAsB,KAAK,SAAS,QAAQ,+BAA+B,CAAC,eAAc;AAE3F,WAAK,kBAAkB,WAAW,QAAQ;IAC9C,CAAC;AAED,QAAI,KAAK,SAAS,uBAAuB;AACrC,YAAM,SAAS,KAAK,SAAS,yBAAyB;QAClD,cAAc,gBAAgB;QAC9B,aAAa;QACb,cAAc;;AAElB,YAAM,eAAe,OAAO,gBAAgB;AAC5C,WAAK,eAAe,aAAa,gBAAgB;QAC7C,WAAW,OAAO,iBAAiB,WAAW,eAAe,aAAa;QAC1E,WAAW,OAAO,iBAAiB,WAAW,eAAe,aAAa;QAC1E,WAAW,OAAO,iBAAiB,WAAW,eAAe,aAAa;OAC7E;AACD,WAAK,aAAa,qBAAqB,IAAI,WAAU;AACrD,WAAK,aAAa,YAAY;AAC9B,WAAK,mBAAmB,IAAI,gBAAgB,KAAK,cAAc,OAAO,cAAc,EAAE,MAAM,GAAG,GAAG,OAAM,CAAE;;AAG9G,WAAO;EACX;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,WAAO,KAAK,KAAK,YAAY,EAAE,QAAQ,CAAC,iBAAgB;AACpD,WAAK,kBAAkB,YAAY;IACvC,CAAC;AAED,QAAI,KAAK,cAAc;AACnB,WAAK,aAAa,QAAO;;AAG7B,WAAO;EACX;;;;;EAMO,qBAAkB;AACrB,WAAO,KAAK;EAChB;;;;;;;EAQO,yBAAyB,YAAqC;AACjE,UAAM,KAAK,OAAO,eAAe,WAAW,aAAa,WAAW;AACpE,QAAI,KAAK,aAAa,EAAE,GAAG;AACvB,aAAO,KAAK,aAAa,EAAE,EAAE;WAC1B;AACH,aAAO;;EAEf;;;;;;;;;EAUO,qBAAqB,eAK3B;AACG,SAAK,SAAS,oBAAoB;MAC9B,GAAG,KAAK,SAAS;MACjB,GAAG;;EAEX;EAEU,WAAW,UAAa;AAxTtC;AAyTQ,SAAK,SAAS,KAAK,kBAAkB,mBAAmB,KAAK;AAC7D,SAAK,iBAAiB,KAAK,kBAAkB;AAC7C,QAAI,KAAK,gBAAgB,KAAK,kBAAkB;AAC5C,WAAK,aAAa,SAAS,SAAS,KAAK,SAAS,QAAQ,SAAS,cAAc;AACjF,WAAK,aAAa,mBAAoB,SAAS,KAAK,SAAS,QAAQ,SAAS,gBAAgB;AAC9F,WAAI,UAAK,SAAS,QAAQ,SAAS,sBAA/B,mBAAkD,gBAAgB;AAClE,cAAM,KAAK,KAAK,SAAS,QAAQ,SAAS,kBAAkB;AAC5D,aAAK,WAAW,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACpC,aAAK,iBAAiB,kBAAkB,KAAK,UAAU;;AAE3D,WAAI,UAAK,SAAS,QAAQ,SAAS,sBAA/B,mBAAkD,iBAAiB;AACnE,cAAM,KAAK,KAAK,SAAS,QAAQ,SAAS,kBAAkB;AAC5D,aAAK,WAAW,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACpC,aAAK,iBAAiB,mBAAmB,KAAK,UAAU;;;AAGhE,WAAO,KAAK,KAAK,YAAY,EAAE,QAAQ,CAAC,iBAAgB;AAzUhE,UAAAA,KAAAC;AA0UY,YAAM,iBAAiB,KAAK,aAAa,YAAY;AACrD,YAAM,iBAAiB,eAAe,aAAa,QAAQ,eAAe,aAAa;AACvF,YAAM,mBAAmB,eAAe,UAAU,eAAe,aAAc;AAC/E,WAAID,MAAA,eAAe,aAAa,gBAA5B,gBAAAA,IAAyC,gBAAgB;AACzD,cAAM,KAAK,eAAe,aAAa,YAAY;AACnD,aAAK,WAAW,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACpC,uBAAe,SAAS,kBAAkB,KAAK,UAAU;aACtD;AACH,uBAAe,SAAS,cAAc,kBAAkB,KAAK,UAAU;AACvE,aAAK,WAAW,aAAa,MAAO,KAAK,MAAM;AAC/C,uBAAe,SAAS,kBAAkB,KAAK,UAAU;;AAE7D,uBAAiB,SAAS,eAAe,QAAQ;AACjD,UAAI,KAAK,YAAY;AACjB,eAAO,IAAI,CAAC,KAAK,YAAY,QAAQ,CAAC;;AAG1C,YAAM,qBAAqB,eAAe,eAAe,eAAe,aAAc;AACtF,WAAIC,MAAA,eAAe,aAAa,gBAA5B,gBAAAA,IAAyC,iBAAiB;AAC1D,cAAM,KAAK,eAAe,aAAa,YAAY;AACnD,aAAK,WAAW,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACpC,uBAAe,SAAS,mBAAmB,KAAK,UAAU;aACvD;AACH,YAAI,CAAC,mBAAmB,kBAAkB,eAAe,kBAAmB,GAAG;AAE3E,6BAAmB,iBAAgB,EAAG,cAAc,eAAe,oBAAqB,KAAK,cAAc;AAC3G,gBAAM,MAAM,KAAK,KACb,KAAK,eAAe,IAAI,KAAK,eAAe,IAAI,KAAK,eAAe,IAAI,KAAK,eAAe,IAAI,KAAK,eAAe,IAAI,KAAK,eAAe,CAAC;AAEjJ,eAAK,WAAW,IAAI,KAAK,eAAe,GAAG,KAAK,eAAe,GAAG,KAAK,eAAe,CAAC;AAEvF,cAAI,MAAM,MAAO;AACb,iBAAK,WAAW,aAAa,CAAC;iBAC3B;AACH,kBAAM,QAAQ,IAAI,KAAK,MAAM,KAAK,KAAK,eAAe,CAAC;AACvD,iBAAK,WAAW,aAAa,SAAS,OAAO,KAAK,SAAS,KAAM;;AAErE,yBAAe,SAAS,mBAAmB,KAAK,UAAU;;;AAGlE,yBAAmB,SAAS,eAAe,kBAAmB;AAC9D,UAAI,KAAK,YAAY;AACjB,eAAO,IAAI,CAAC,KAAK,YAAY,KAAK,gBAAgB,SAAS,CAAC;;IAEpE,CAAC;EACL;EAEQ,kBAAkB,sBAA4B;AAClD,UAAM,iBAAiB,KAAK,aAAa,oBAAoB;AAC7D,QAAI,CAAC,gBAAgB;AACjB;;AAEJ,QAAI,eAAe,cAAc;AAC7B,qBAAe,aAAa,QAAO;;AAGvC,WAAO,KAAK,aAAa,oBAAoB;EACjD;;AAnOuB,uBAAA,OAAO,iBAAiB;AAMxB,uBAAA,UAAU;AAiOrC,qBAAqB,gBACjB,uBAAuB,MACvB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,uBAAuB,kBAAkB,OAAO;AACrE,GACA,uBAAuB,SACvB,IAAI;;;AC9TF,IAAO,eAAP,cAA4B,qBAAoB;;;;;;EA+DlD,YACI,mBAIgB,UAAgC,CAAA,GAAE;AAElD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAnEZ,SAAA,UAAkB,IAAI,OAAM;AAC5B,SAAA,UAAmB,IAAI,QAAO;AAC9B,SAAA,WAAuB,IAAI,WAAU;AAIrC,SAAA,qBAAqB,CAAC,mBAAoC;AAC9D,UAAI,CAAC,gBAAgB;AACjB;;AAEJ,YAAM,YAAY,IAAI,MAAM,KAAK,QAAQ,aAAa,CAAA,CAAE;AACxD,YAAM,iBAAuC;QACzC,OAAO,KAAK,QAAQ,oBAAoB,iBAAiB,KAAK,kBAAkB;QAChF;;AAEJ,UAAI,KAAK,QAAQ,aAAa;AAC1B,uBAAe,cAAc,KAAK,QAAQ;;AAE9C,UAAI,CAAC,eAAe,OAAO;AACvB,cAAM,KAAK,kDAAkD;AAC7D;;AAEJ,WAAK,kBAAkB,QAAQ,qBAAsB,cAAc,EAAE,KAAK,CAAC,kBAAiB;AACxF,YAAI,KAAK,kBAAkB;AACvB,eAAK,iBAAiB,OAAM;;AAEhC,aAAK,mBAAmB;MAC5B,CAAC;IACL;AAkBO,SAAA,0BAAmC;AAKnC,SAAA,4BAA2D,IAAI,WAAU;AAIzE,SAAA,SAAkB;AAerB,SAAK,sBAAsB;AAC3B,UAAM,KAAK,mDAAmD;EAClE;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAIX,QAAI,CAAC,KAAK,kBAAkB,QAAQ,sBAAsB;AACtD,aAAO;;AAGX,QAAI,CAAC,KAAK,QAAQ,yBAAyB;AACvC,UAAI,KAAK,kBAAkB,gBAAgB;AACvC,aAAK,mBAAmB,KAAK,kBAAkB,cAAc;;AAEjE,WAAK,kBAAkB,0BAA0B,IAAI,KAAK,kBAAkB;;AAEhF,QAAI,KAAK,QAAQ,wBAAwB;AACrC,YAAM,YAAY,IAAI,MAAM,KAAK,QAAQ,sBAAsB,CAAA,CAAE;AACjE,WAAK,kBAAkB,QAAQ,sCAAuC;QAClE,SAAS,KAAK,QAAQ,2BAA2B;QACjD;QACA,aAAa,KAAK,QAAQ;OAC7B,EAAE,KAAK,CAAC,cAAa;AAClB,aAAK,4BAA4B;MACrC,CAAC;;AAGL,WAAO;EACX;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAEX,QAAI,KAAK,kBAAkB;AACvB,WAAK,iBAAiB,OAAM;AAC5B,WAAK,mBAAmB;;AAE5B,SAAK,kBAAkB,0BAA0B,eAAe,KAAK,kBAAkB;AACvF,QAAI,KAAK,2BAA2B;AAChC,WAAK,0BAA0B,OAAM;AACrC,WAAK,4BAA4B;;AAErC,WAAO;EACX;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,0BAA0B,MAAK;EACxC;EAEU,WAAW,OAAc;AAE/B,QAAI,CAAC,KAAK,YAAY,KAAK,QAAQ;AAC/B;;AAGJ,QAAI,KAAK,kBAAkB;AACvB,YAAM,UAAU,MAAM,kBAAkB,KAAK,gBAAgB;AAC7D,WAAK,2BAA2B,OAAO;;AAE3C,QAAI,KAAK,2BAA2B;AAChC,YAAM,+BAA+B,MAAM,mCAAmC,KAAK,yBAAyB;AAE5G,mCAA6B,QAAQ,CAAC,0BAAyB;AAC3D,aAAK,2BAA2B,sBAAsB,SAAS,sBAAsB,WAAW;MACpG,CAAC;;EAET;EAEQ,2BAA2B,gBAA4C,aAA2B;AACtG,UAAM,UAA6B,CAAA;AACnC,mBAAe,QAAQ,CAAC,kBAAiB;AACrC,YAAM,OAAO,cAAc,QAAQ,KAAK,kBAAkB,cAAc;AACxE,UAAI,CAAC,MAAM;AACP;;AAEJ,YAAM,MAAM,KAAK,UAAU;AAC3B,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,QAAQ,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,EAAE,aAAa,KAAK,kBAAkB,kBAAkB;AAC5F,WAAK,SAAS,IAAI,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAChD,aAAO,4BAA4B,KAAK,UAAU,QAAQ,GAAG,GAAG,KAAK,OAAO;AAC5E,UAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,aAAK,QAAQ,KAAK;AAClB,aAAK,SAAS,KAAK;AACnB,aAAK,SAAS,KAAK;AACnB,aAAK,QAAQ,6BAA4B;;AAG7C,YAAM,SAA0B;QAC5B,UAAU,KAAK,0BAA0B,KAAK,QAAQ,MAAK,IAAK,KAAK;QACrE,oBAAoB,KAAK,0BAA0B,KAAK,SAAS,MAAK,IAAK,KAAK;QAChF,sBAAsB,KAAK,0BAA0B,KAAK,QAAQ,MAAK,IAAK,KAAK;QACjF;QACA,aAAa,CAAC,CAAC;QACf,aAAa;;AAEjB,cAAQ,KAAK,MAAM;IACvB,CAAC;AAED,SAAK,0BAA0B,gBAAgB,OAAO;EAC1D;;AA7JuB,aAAA,OAAO,iBAAiB;AAMxB,aAAA,UAAU;AA2JrC,qBAAqB,gBACjB,aAAa,MACb,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,aAAa,kBAAkB,OAAO;AAC3D,GACA,aAAa,SACb,KAAK;;;AC9PH,IAAO,0BAAP,cAAuC,qBAAoB;;;;EA2B7D,IAAW,oBAAiB;AACxB,WAAO,KAAK;EAChB;;;;;EAMA,YAAY,mBAAsC;AAC9C,UAAM,iBAAiB;AAnCnB,SAAA,WAAoB;AACpB,SAAA,qBAAgD,CAAA;AAgBxC,SAAA,iCAAuD,IAAI,WAAU;AAKrE,SAAA,mCAAyD,IAAI,WAAU;AAcnF,SAAK,sBAAsB;AAC3B,QAAI,KAAK,kBAAkB,SAAS;AAChC,WAAK,MAAK;WACP;AACH,WAAK,kBAAkB,gBAAgB,QAAQ,MAAK;AAChD,aAAK,MAAK;MACd,CAAC;;EAET;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,SAAK,kBAAkB,SAAS;AAChC,WAAO;EACX;;;;EAKO,UAAO;AACV,UAAM,QAAO;AAEb,SAAK,mBAAmB,SAAS;AACjC,SAAK,iCAAiC,MAAK;AAC3C,SAAK,+BAA+B,MAAK;EAC7C;;;;;EAMU,WAAW,OAAc;AAC/B,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,YAAY,CAAC,OAAO;AAC5C;;AAGJ,UAAM,sBAA4C,MAAM;AACxD,QAAI,CAAC,uBAAuB,oBAAoB,WAAW,GAAG;AAC1D;WACG;AACH,UAAI,oBAAoB,SAAS,MAAM,GAAG;AACtC,cAAM,IAAI,MAAM,uDAAuD,oBAAoB,MAAM;;AAGrG,YAAM,wBAAgC,oBAAoB,SAAS;AACnE,YAAM,uBAAuB,CAAA;AAC7B,YAAM,qBAAqB,CAAA;AAC3B,eAAS,IAAI,GAAG,IAAI,uBAAuB,KAAK;AAC5C,cAAM,WAAmB,IAAI;AAC7B,cAAM,KAAK,oBAAoB,WAAW,CAAC;AAG3C,YAAI,CAAC,KAAK,mBAAmB,EAAE,GAAG;AAC9B,eAAK,mBAAmB,EAAE,IAAI,EAAE,UAAU,IAAI,QAAO,GAAI,iBAAiB,EAAC;AAC3E,6BAAmB,KAAK,EAAE;eACvB;AACH,+BAAqB,KAAK,EAAE;;AAIhC,aAAK,mBAAmB,EAAE,EAAE,SAAS,IAAI,oBAAoB,QAAQ;AACrE,aAAK,mBAAmB,EAAE,EAAE,SAAS,IAAI,oBAAoB,WAAW,CAAC;AACzE,aAAK,mBAAmB,EAAE,EAAE,SAAS,IAAI,oBAAoB,WAAW,CAAC;AACzE,aAAK,mBAAmB,EAAE,EAAE,kBAAkB,oBAAoB,WAAW,CAAC;;AAIlF,UAAI,mBAAmB,SAAS,GAAG;AAC/B,aAAK,+BAA+B,gBAAgB,kBAAkB;;AAI1E,UAAI,qBAAqB,SAAS,GAAG;AACjC,aAAK,iCAAiC,gBAAgB,oBAAoB;;;EAGtF;;;;EAKQ,QAAK;AACT,QAAI,CAAC,KAAK,kBAAkB,QAAQ,kCAAkC,CAAC,KAAK,kBAAkB,QAAQ,+BAA+B,IAAI,GAAG;AAExI;;AAGJ,SAAK,WAAW;EACpB;;AA/HuB,wBAAA,OAAO,iBAAiB;AAMxB,wBAAA,UAAU;AA6HrC,qBAAqB,gBACjB,wBAAwB,MACxB,CAAC,qBAAoB;AACjB,SAAO,MAAM,IAAI,wBAAwB,gBAAgB;AAC7D,GACA,wBAAwB,OAAO;;;AC9EnC,IAAI,iBAAiB;AAKf,IAAO,oBAAP,cAAiC,qBAAoB;EA2BvD,YACI,mBACQ,WAAsC,CAAA,GAAE;AAEhD,UAAM,iBAAiB;AAFf,SAAA,WAAA;AA5BJ,SAAA,kBAAiD,oBAAI,IAAG;AAgBzD,SAAA,wBAAsD,IAAI,WAAU;AAIpE,SAAA,0BAAwD,IAAI,WAAU;AAItE,SAAA,0BAAwD,IAAI,WAAU;AAOzE,SAAK,sBAAsB;AAC3B,QAAI,KAAK,SAAS,gBAAgB;AAC9B,WAAK,SAAS,2BAA2B;;AAE7C,QAAI,KAAK,kBAAkB,SAAS;AAChC,WAAK,MAAK;WACP;AACH,WAAK,kBAAkB,gBAAgB,QAAQ,MAAK;AAChD,aAAK,MAAK;MACd,CAAC;;EAET;EAEO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAIX,QAAI,CAAC,CAAC,KAAK,kBAAkB,YAAY,CAAC,CAAC,KAAK,kBAAkB,QAAQ,2BAA2B;AACjG,WAAK,kBAAkB,QAAQ,0BAA0B,KAAK;;AAGlE,QAAI,CAAC,KAAK,SAAS,iCAAiC;AAChD,WAAK,gBAAgB,QAAQ,CAAC,SAAQ;AAClC,aAAK,wBAAwB,gBAAgB,IAAI;MACrD,CAAC;AAED,WAAK,gBAAgB,MAAK;;AAG9B,WAAO;EACX;EAEO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,sBAAsB,MAAK;AAChC,SAAK,wBAAwB,MAAK;AAClC,SAAK,wBAAwB,MAAK;EACtC;EAEU,WAAW,OAAc;AAzKvC;AA2KQ,QAAI;AACA,UAAI,CAAC,KAAK,YAAY,CAAC,OAAO;AAC1B;;AAIJ,YAAM,iBAAiB,MAAM,oBAAkB,WAAM,qBAAN,mBAAwB;AACvE,UAAI,gBAAgB;AAChB,cAAM,WAAW,oBAAI,IAAG;AACxB,aAAK,gBAAgB,QAAQ,CAAC,YAAY,WAAU;AAChD,cAAI,CAAC,eAAe,IAAI,MAAM,GAAG;AAC7B,qBAAS,IAAI,MAAM;;QAE3B,CAAC;AACD,iBAAS,QAAQ,CAAC,WAAU;AACxB,gBAAM,aAAa,KAAK,gBAAgB,IAAI,MAAM;AAClD,cAAI,YAAY;AACZ,iBAAK,wBAAwB,gBAAgB,UAAU;AACvD,iBAAK,gBAAgB,OAAO,MAAM;;QAE1C,CAAC;AAGD,uBAAe,QAAQ,CAAC,WAAU;AAC9B,cAAI,CAAC,KAAK,gBAAgB,IAAI,MAAM,GAAG;AACnC,kBAAM,oBAA+C;cACjD,IAAI;cACJ;;AAEJ,kBAAM,aAAa,KAAK,4BAA4B,QAAQ,mBAAmB,KAAK;AACpF,iBAAK,gBAAgB,IAAI,QAAQ,UAAU;AAC3C,iBAAK,sBAAsB,gBAAgB,UAAU;iBAClD;AAEH,gBAAI,OAAO,oBAAoB,KAAK,kBAAkB,kBAAkB;AACpE,oBAAM,aAAa,KAAK,gBAAgB,IAAI,MAAM;AAClD,kBAAI,YAAY;AACZ,qBAAK,4BAA4B,QAAQ,YAAY,KAAK;AAC1D,qBAAK,wBAAwB,gBAAgB,UAAU;;;;QAIvE,CAAC;;aAEA,OAAO;AACZ,aAAO,IAAI,MAAM,KAAK;;EAE9B;EAEQ,QAAK;AAET,QAAI,KAAK,kBAAkB,UAAU;AACjC,UAAI,KAAK,kBAAkB,QAAQ,2BAA2B;AAC1D,aAAK,kBAAkB,QAAQ,0BAA0B,IAAI;;AAGjE,UAAI,CAAC,CAAC,KAAK,SAAS,4BAA4B,CAAC,CAAC,KAAK,kBAAkB,QAAQ,oCAAoC;AACjH,aAAK,kBAAkB,QAAQ,mCAAmC,KAAK,SAAS,wBAAwB;;;EAGpH;EAEQ,4BAA4B,QAAgB,MAAiC,SAAgB;AAzOzG;AA0OQ,SAAK,SAAS;AACd,SAAK,kBAAkB,KAAK,SAAS;AACrC,UAAM,YAAY,OAAO,YAAY,OAAO;AAE5C,QAAI,KAAK,SAAS,0BAA0B;AACxC,UAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,aAAK,YAAY,IAAI,aAAa,UAAU,MAAM;AAClD,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAAG;AAC1C,eAAK,UAAU,CAAC,IAAI,UAAU,CAAC;AAC/B,eAAK,UAAU,IAAI,CAAC,IAAI,UAAU,IAAI,CAAC;AACvC,eAAK,UAAU,IAAI,CAAC,IAAI,KAAK,UAAU,IAAI,CAAC;;AAGhD,YAAI,OAAO,SAAS;AAChB,eAAK,UAAU,IAAI,aAAa,OAAO,QAAQ,MAAM;AACrD,mBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,QAAQ,KAAK,GAAG;AAC/C,iBAAK,QAAQ,CAAC,IAAI,OAAO,QAAQ,CAAC;AAClC,iBAAK,QAAQ,IAAI,CAAC,IAAI,OAAO,QAAQ,IAAI,CAAC;AAC1C,iBAAK,QAAQ,IAAI,CAAC,IAAI,KAAK,OAAO,QAAQ,IAAI,CAAC;;;aAGpD;AACH,aAAK,YAAY;AACjB,aAAK,UAAU,OAAO;;AAI1B,WAAK,UAAU,OAAO;AAGtB,YAAM,OAAO,QAAQ,QAAQ,OAAO,WAAW,KAAK,kBAAkB,cAAc;AACpF,UAAI,MAAM;AACN,cAAM,MAAM,KAAK,wBAAwB,IAAI,OAAM;AACnD,eAAO,eAAe,KAAK,UAAU,QAAQ,GAAG,GAAG;AACnD,YAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,cAAI,6BAA4B;;AAEpC,aAAK,uBAAuB;AAC5B,YAAI,KAAK,SAAS,iBAAiB;AAC/B,cAAI,cAAc,KAAK,SAAS,gBAAgB,eAAc,GAAI,GAAG;;;AAI7E,UAAI,KAAK,SAAS,gBAAgB;AAC9B,YAAI,CAAC,KAAK,MAAM;AACZ,gBAAM,gBAAgB,IAAI,KAAK,aAAa,KAAK,IAAI,KAAK,kBAAkB,KAAK;AACjF,wBAAc,qBAAqB,IAAI,WAAU;AACjD,wBAAc,gBAAgB,aAAa,cAAc,KAAK,SAAS;AACvE,cAAI,KAAK,SAAS;AACd,0BAAc,gBAAgB,aAAa,YAAY,KAAK,OAAO;iBAChE;AACH,0BAAc,cAAc,IAAI;;AAEpC,wBAAc,WAAW,KAAK,SAAS,QAAW,IAAI;AACtD,eAAK,OAAO;eACT;AACH,gBAAM,gBAAgB,KAAK;AAC3B,wBAAc,mBAAmB,aAAa,cAAc,KAAK,SAAS;AAC1E,cAAI,KAAK,SAAS;AACd,0BAAc,mBAAmB,aAAa,YAAY,KAAK,OAAO;iBACnE;AACH,0BAAc,cAAc,IAAI;;AAEpC,wBAAc,cAAc,KAAK,OAAO;;AAE5C,mBAAK,yBAAL,mBAA2B,UAAU,KAAK,KAAK,SAAS,KAAK,KAAK,oBAAqB,KAAK,KAAK;;;AAIzG,WAAyB;EAC7B;;AA1MuB,kBAAA,OAAO,iBAAiB;AAMxB,kBAAA,UAAU;AAuMrC,qBAAqB,gBACjB,kBAAkB,MAClB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,kBAAkB,kBAAkB,OAAO;AAChE,GACA,kBAAkB,SAClB,KAAK;;;ACzPT,IAAK;CAAL,SAAKC,2BAAwB;AAEzB,EAAAA,0BAAAA,0BAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,0BAAAA,0BAAA,SAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,0BAAAA,0BAAA,UAAA,IAAA,CAAA,IAAA;AACJ,GAPK,6BAAA,2BAAwB,CAAA,EAAA;AAavB,IAAO,qBAAP,cAAkC,qBAAoB;;;;;;EAoCxD,YACI,mBAIgB,SAAmC;AAEnD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAzBb,SAAA,oCAAwD,IAAI,WAAU;AAItE,SAAA,kCAAkE,IAAI,WAAU;AAIhF,SAAA,kCAAkE,IAAI,WAAU;AAE/E,SAAA,wBAAkD,yBAAyB;AAC3E,SAAA,iBAAuC,CAAA;AAiB3C,SAAK,sBAAsB;EAC/B;;;;;;;EAQO,SAAM;AACT,WAAO,MAAM,OAAM;EACvB;;;;;;;EAQO,SAAM;AACT,WAAO,MAAM,OAAM;EACvB;;;;;;;EAQO,oBAAoB,IAAU;AACjC,WAAO,KAAK,eAAe,EAAE,KAAK;EACtC;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,eAAe,QAAQ,CAAC,iBAAgB;AACzC,mBAAa,eAAe,MAAK;IACrC,CAAC;AACD,SAAK,eAAe,SAAS;AAC7B,SAAK,gCAAgC,MAAK;AAC1C,SAAK,kCAAkC,MAAK;AAC5C,SAAK,gCAAgC,MAAK;EAC9C;;;;;EAMO,MAAM,4BAAyB;AAClC,QAAI,CAAC,KAAK,QAAQ,UAAU,CAAC,KAAK,QAAQ,OAAO,QAAQ;AACrD,aAAO,CAAA;;AAEX,UAAM,WAAW,KAAK,QAAQ,OAAO,IAAI,CAAC,UAAS;AAC/C,UAAI,OAAO,MAAM,QAAQ,UAAU;AAC/B,eAAO,KAAK,kBAAkB,MAAM,UAAS,EAAG,6BAA6B,MAAM,GAAG;aACnF;AACH,eAAO,QAAQ,QAAQ,MAAM,GAAG;;IAExC,CAAC;AAED,QAAI;AACA,YAAM,SAAS,MAAM,QAAQ,IAAI,QAAQ;AAEzC,WAAK,2BAA2B,OAAO,IAAI,CAAC,OAAO,QAAO;AACtD,eAAO;UACH;UACA,eAAe,KAAK,QAAQ,OAAO,GAAG,EAAE;;MAEhD,CAAC;AAED,aAAO;QACH,eAAe,KAAK;;aAEnB,IAAI;AACT,YAAM,MAAM,kFAAkF;AAC9F,aAAO,CAAA;;EAEf;EAEU,WAAW,UAAiB;AAClC,QAAI,CAAC,SAAS,2BAA2B,KAAK,0BAA0B,yBAAyB,SAAS;AACtG;;AAKJ,QAAI,KAAK,0BAA0B,yBAAyB,aAAa;AACrE,WAAK,kBAAiB;AACtB;;AAGJ,UAAM,sBAAsB,SAAS,wBAAuB;AAC5D,eAAW,UAAU,qBAAqB;AACtC,UAAI,UAAU;AACd,YAAM,aAAa,OAAO;AAE1B,YAAM,cAAc,KAAK,eAAe,UAAU;AAClD,UAAI,CAAC,aAAa;AAEd;;AAGJ,kBAAY,mBAAmB;AAC/B,UAAI,YAAY,mBAAmB,OAAO,uBAAuB;AAC7D,oBAAY,iBAAiB,OAAO;AACpC,kBAAU;;AAId,YAAM,OAAO,SAAS,QAAQ,OAAO,YAAY,KAAK,kBAAkB,cAAc;AAEtF,UAAI,MAAM;AACN,cAAM,MAAM,YAAY;AACxB,eAAO,eAAe,KAAK,UAAU,QAAQ,GAAG,GAAG;AACnD,YAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,cAAI,6BAA4B;;AAEpC,kBAAU;;AAGd,YAAM,QAAQ,OAAO;AACrB,YAAM,WAAW,UAAU;AAE3B,UAAI,YAAY,aAAa,UAAU;AACnC,oBAAY,WAAW;AACvB,kBAAU;;AAEd,UAAI,SAAS;AACT,aAAK,gCAAgC,gBAAgB,WAAW;;;EAG5E;EAEQ,MAAM,oBAAiB;AAC3B,QAAI,CAAC,KAAK,kBAAkB,QAAQ,yBAAyB,KAAK,0BAA0B,yBAAyB,aAAa;AAC9H;;AAGJ,SAAK,wBAAwB,yBAAyB;AACtD,UAAM,cAAc,MAAM,KAAK,kBAAkB,QAAQ,sBAAqB;AAC9E,QAAI,CAAC,eAAe,YAAY,WAAW,GAAG;AAC1C,WAAK,wBAAwB,yBAAyB;AACtD;;AAIJ,aAAS,MAAM,GAAG,MAAM,YAAY,QAAQ,EAAE,KAAK;AAC/C,UAAI,YAAY,GAAG,KAAK,eAAe;AACnC,aAAK,kCAAkC,gBAAgB,GAAG;aACvD;AACH,cAAM,iBAAiB,KAAK,yBAAyB,GAAG,EAAE;AAC1D,cAAM,cAAkC;UACpC,IAAI;UACJ;UACA,sBAAsB,IAAI,OAAM;UAChC,OAAO,eAAe,QAAQ,eAAe;;AAEjD,aAAK,eAAe,GAAG,IAAI;AAC3B,aAAK,gCAAgC,gBAAgB,WAAW;;;AAIxE,SAAK,wBAAwB,YAAY,SAAS,IAAI,yBAAyB,WAAW,yBAAyB;EACvH;;AA9MuB,mBAAA,OAAO,iBAAiB;AAMxB,mBAAA,UAAU;AA4MrC,qBAAqB,gBACjB,mBAAmB,MACnB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,mBAAmB,kBAAkB,OAAO;AACjE,GACA,mBAAmB,SACnB,KAAK;;;AC7PH,IAAO,kBAAP,cAA+B,qBAAoB;;;;;;EAgCrD,YACI,mBAIgB,SAAgC;AAEhD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAjCZ,SAAA,kBAAiD;AAKjD,SAAA,0BAAwE;AAKxE,SAAA,WAA8B;AA0BlC,SAAK,sBAAsB;AAG3B,UAAM,KAAK,sDAAsD;EACrE;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAIX,QAAI,CAAC,KAAK,kBAAkB,QAAQ,mBAAmB,KAAK,kBAAkB,QAAQ,gBAAgB,SAAS,MAAM;AACjH,aAAO;;AAGX,SAAK,kBAAkB,KAAK,kBAAkB,QAAQ,gBAAgB;AAEtE,QAAI,KAAK,aAAa,QAAQ,KAAK,QAAQ,0BAA0B,MAAM;AACvE,WAAK,0BAA0B,CAAC,OAAM;AAClC,WAAG,eAAc;MACrB;AACA,WAAK,SAAS,iBAAiB,kBAAkB,KAAK,uBAAuB;;AAGjF,WAAO;EACX;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK;EAChB;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,QAAI,KAAK,aAAa,QAAQ,KAAK,yBAAyB;AACxD,WAAK,SAAS,oBAAoB,kBAAkB,KAAK,uBAAuB;;EAExF;EAEU,WAAW,UAAiB;EAEtC;;;;;EAMO,MAAM,4BAAyB;AAClC,QAAI,KAAK,QAAQ,YAAY,QAAW;AACpC,YAAM,KAAK,qEAAqE;AAChF,aAAO,CAAA;eACA,OAAO,KAAK,QAAQ,YAAY,UAAU;AACjD,YAAM,kBAAkB,SAAS,cAAc,KAAK,QAAQ,OAAO;AACnE,UAAI,oBAAoB,MAAM;AAC1B,cAAM,KAAK,sBAAsB,KAAK,QAAQ,OAAO,mCAAmC;AACxF,eAAO,CAAA;;AAEX,WAAK,WAAW;WACb;AACH,WAAK,WAAW,KAAK,QAAQ;;AAGjC,WAAO;MACH,YAAY;QACR,MAAM,KAAK;;;EAGvB;;AApGuB,gBAAA,OAAO,iBAAiB;AAMxB,gBAAA,UAAU;AAkGrC,qBAAqB,gBACjB,gBAAgB,MAChB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,gBAAgB,kBAAkB,OAAO;AAC9D,GACA,gBAAgB,SAChB,KAAK;;;ACtCH,IAAO,0BAAP,MAAO,iCAAgC,qBAAoB;;;;EA6D7D,IAAW,oBAAiB;AACxB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,kBAAe;AACtB,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,gBAAgB,SAAgB;AACvC,SAAK,gBAAgB,kBAAkB;EAC3C;;;;EAKA,IAAW,uCAAoC;AAC3C,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,qCAAqC,aAAoB;AAChE,SAAK,gBAAgB,uCAAuC;EAChE;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,cAAc,eAAqB;AAC1C,SAAK,gBAAgB,gBAAgB;EACzC;;;;EAKA,IAAW,oBAAiB;AACxB,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,kBAAkB,mBAAyB;AAClD,SAAK,gBAAgB,oBAAoB;EAC7C;;;;EAKA,IAAW,kBAAe;AACtB,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,gBAAgB,SAAgB;AACvC,SAAK,gBAAgB,kBAAkB;EAC3C;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,cAAc,eAAqB;AAC1C,SAAK,gBAAgB,gBAAgB;EACzC;;;;EAKA,IAAW,oBAAiB;AACxB,WAAO,KAAK,gBAAgB;EAChC;;;;;EAMA,IAAW,kBAAkB,WAAiB;AAC1C,SAAK,gBAAgB,oBAAoB;EAC7C;;;;;;EAMA,YAAY,mBAAwC,SAAwC;AACxF,UAAM,iBAAiB;AA9KnB,SAAA,eAKJ,CAAA;AAEI,SAAA,qCAAyF,CAAA;AAIzF,SAAA,qBAAiC,IAAI,WAAU;AAK/C,SAAA,qBAA6B,OAAO,SAAQ;AAC5C,SAAA,2BAAoC,IAAI,QAAO;AAC/C,SAAA,0BAAmC,IAAI,QAAO;AAC9C,SAAA,uBAAmC,IAAI,WAAU;AAkQjD,SAAA,oBAAoB,CAAC,iBAAkC;AAC3D,UAAI,KAAK,aAAa,aAAa,QAAQ,GAAG;AAE1C;;AAGJ,WAAK,aAAa,aAAa,QAAQ,IAAI;QACvC;QACA,sBAAsB,CAAA;;AAE1B,YAAM,iBAAiB,KAAK,aAAa,aAAa,QAAQ;AAG9D,UAAI,eAAe,aAAa,YAAY,kBAAkB,qBAAqB,eAAe,aAAa,YAAY,SAAS;AAEhI,cAAM,iBAAiB,MAAK;AACxB,cAAI,aAAa,kBAAkB;AAC/B,uBAAW,gBAAgB,KAAK,oCAAoC;AAChE,kBAAI,YAAgD;AAEpD,kBAAI,aAAa,uBAAuB;AACpC,2BAAW,iBAAiB,aAAa,uBAAuB;AAC5D,wBAAM,kBAAkB,aAAa,iBAAiB,mBAAmB,aAAa;AACtF,sBAAI,oBAAoB,MAAM;AAC1B,gCAAY;AACZ;;;;AAKZ,kBAAI,aAAa,mBAAmB;AAChC,sBAAM,gBAAgB,aAAa,iBAAiB,iBAAgB;AACpE,oBAAI,kBAAkB,MAAM;AACxB;;AAEJ,4BAAY;;AAGhB,kBAAI,OAAO,aAAa,gCAAgC,YAAY;AAEhE,4BAAY,aAAa,4BAA4B,YAAY;;AAGrE,kBAAI,aAAa,aAAa,iBAAiB;AAC3C,oBAAI,aAAa,YAAY,eAAe,aAAa,iBAAiB;AACtE;;;AAIR,kBAAI,cAAc,MAAM;AACpB;;AAGJ,oBAAM,sBAA2C;gBAC7C,2BAA2B;gBAC3B;;AAEJ,6BAAe,qBAAqB,KAAK,mBAAmB;AAE5D,kBAAI,wBAAwB,cAAc;AACtC,oCAAoB,wBAAwB,UAAU,6BAA6B,IAAI,CAAC,aAAY;AAChG,+BAAa,mBAAmB,UAAU,KAAK,gBAAgB,KAAK,iBAAiB,KAAK,QAAQ;gBACtG,CAAC;;AAGL,kBAAI,0BAA0B,cAAc;AACxC,oCAAoB,0BAA0B,UAAU,+BAA+B,IAAI,MAAK;AAC5F,sBAAI,UAAW,QAAQ,SAAS;AAC5B,iCAAa,qBAAqB,UAAW,QAAQ,SAAS,KAAK,gBAAgB,KAAK,iBAAiB,KAAK,QAAQ;;gBAE9H,CAAC;;;;QAIjB;AAEA,YAAI,aAAa,kBAAkB;AAC/B,yBAAc;eACX;AACH,uBAAa,iCAAiC,QAAQ,MAAK;AACvD,2BAAc;UAClB,CAAC;;;IAGb;AAzLI,QAAI,CAAC,WAAW,QAAQ,YAAY,QAAW;AAC3C,YAAM,MAAM,4DAA4D;AACxE;;AAGJ,QAAI,MAAM,QAAQ,QAAQ,gCAAgC,GAAG;AACzD,WAAK,qCAAqC,QAAQ;WAC/C;AACH,WAAK,qCAAqC,yBAAwB,cAAc;;AAIpF,SAAK,kBAAkB;MACnB,iBAAiB,QAAQ,mBAAmB;MAC5C,sCAAsC,QAAQ,wCAAwC;MACtF,eAAe,QAAQ,iBAAiB;MACxC,mBAAmB,QAAQ,qBAAqB;MAChD,iBAAiB,QAAQ,mBAAmB;MAC5C,eAAe,QAAQ,iBAAiB;MACxC,mBAAmB,QAAQ,qBAAqB;;AAGpD,SAAK,iBAAiB;MAClB,OAAO;MACP,OAAO;MACP,SAAS;MACT,SAAS;;AAGb,SAAK,WAAW,QAAQ;EAC5B;EAEO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,SAAK,SAAS,YAAY,QAAQ,KAAK,iBAAiB;AACxD,SAAK,sBAAsB,KAAK,SAAS,6BAA6B,KAAK,iBAAiB;AAC5F,SAAK,sBAAsB,KAAK,SAAS,+BAA+B,CAAC,eAAgC;AAErG,WAAK,kBAAkB,WAAW,QAAQ;IAC9C,CAAC;AAED,WAAO;EACX;EAEO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,WAAO,KAAK,KAAK,YAAY,EAAE,QAAQ,CAAC,iBAAgB;AACpD,WAAK,kBAAkB,YAAY;IACvC,CAAC;AAED,SAAK,eAAe,CAAA;AAEpB,WAAO;EACX;;;;;EAMU,WAAW,UAAiB;AAClC,QAAI,CAAC,KAAK,UAAU;AAChB;;AAGJ,QAAI,KAAK,eAAe,YAAY,KAAK,KAAK,gBAAgB,iBAAiB;AAE3E,YAAM,cAAc,KAAK,kBAAkB,MAAM,UAAS,EAAG,aAAY;AACzE,YAAM,YAAY,cAAc,OAAQ,KAAK,gBAAgB,gBAAgB,KAAK,eAAe,WAAW,KAAK,kBAAkB,MAAM,uBAAuB,KAAK;AAErK,UAAI,KAAK,gBAAgB,sCAAsC;AAC3D,aAAK,SAAS,SAAS,eAAe,KAAK;AAC3C,mBAAW,0BAA0B,WAAW,GAAG,GAAG,KAAK,oBAAoB;AAC/E,aAAK,SAAS,SAAS,mBAAmB,cAAc,KAAK,sBAAsB,KAAK,kBAAkB;aACvG;AAIH,mBAAW,0BAA0B,YAAY,GAAK,GAAG,GAAG,KAAK,oBAAoB;AACrF,aAAK,mBAAmB,gBAAgB,KAAK,oBAAoB;;eAE9D,KAAK,gBAAgB,sCAAsC;AAClE,WAAK,mBAAmB,SAAS,KAAK,SAAS,SAAS,kBAAkB;;AAG9E,SAAK,KAAK,eAAe,SAAS,KAAK,eAAe,UAAU,KAAK,gBAAgB,iBAAiB;AAClG,aAAO,oBAAoB,KAAK,oBAAoB,KAAK,kBAAkB;AAC3E,WAAK,yBAAyB,IAAI,KAAK,eAAe,OAAO,GAAG,KAAK,eAAe,SAAS,KAAK,kBAAkB,MAAM,uBAAuB,IAAM,GAAK;AAE5J,cAAQ,0BAA0B,KAAK,0BAA0B,KAAK,oBAAoB,KAAK,uBAAuB;AACtH,WAAK,wBAAwB,aAAa,KAAK,SAAS,SAAS,yBAAwB,IAAK,KAAK,gBAAgB,aAAa;AAEhI,WAAK,SAAS,SAAS,gBAAgB,WAAW,KAAK,uBAAuB;;EAEtF;EAwFQ,kBAAkB,sBAA4B;AAClD,UAAM,iBAAiB,KAAK,aAAa,oBAAoB;AAC7D,QAAI,CAAC,gBAAgB;AACjB;;AAGJ,eAAW,uBAAuB,eAAe,sBAAsB;AACnE,UAAI,oBAAoB,uBAAuB;AAC3C,4BAAoB,UAAU,6BAA6B,OAAO,oBAAoB,qBAAqB;;AAE/G,UAAI,oBAAoB,yBAAyB;AAC7C,4BAAoB,UAAU,+BAA+B,OAAO,oBAAoB,uBAAuB;;;AAKvH,WAAO,KAAK,aAAa,oBAAoB;EACjD;;AApWuB,wBAAA,OAAO,iBAAiB;AAKxB,wBAAA,gBAAuF;EAC1G,SAAS;IACL;MACI,uBAAuB,CAAC,yBAAyB,iBAAiB,yBAAyB,aAAa;MACxG,iBAAiB;MACjB,oBAAoB,CAAC,MAAuC,eAA6C,mBAAyD;AAC9J,sBAAc,UAAU,KAAK,IAAI,KAAK,CAAC,IAAI,eAAe,oBAAoB,KAAK,IAAI;AACvF,sBAAc,UAAU,KAAK,IAAI,KAAK,CAAC,IAAI,eAAe,oBAAoB,KAAK,IAAI;MAC3F;;IAEJ;MACI,uBAAuB,CAAC,yBAAyB,iBAAiB,yBAAyB,aAAa;MACxG,iBAAiB;MACjB,oBAAoB,CAAC,MAAuC,eAA6C,mBAAyD;AAC9J,sBAAc,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,eAAe,oBAAoB,KAAK,IAAI;AACrF,sBAAc,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,eAAe,oBAAoB,KAAK,IAAI;MACzF;;;;AAUW,wBAAA,UAAU;AAwUrC,qBAAqB,gBACjB,wBAAwB,MACxB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,wBAAwB,kBAAkB,OAAO;AACtE,GACA,wBAAwB,SACxB,IAAI;;;AClZF,IAAgB,cAAhB,cAAoC,MAAK;EAA/C,cAAA;;AA2FY,SAAA,+BAAwC;AA0LtC,SAAA,cAAsB,OAAO,SAAQ;AACrC,SAAA,oBAA4B,OAAO,SAAQ;EAwCzD;EA1Tc,aAAa,OAAc;AACjC,SAAK,YAAY;EACrB;;;;;EAMA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;;;;;EAKA,IAAW,SAAS,OAAc;AAC9B,SAAK,aAAa,KAAK;EAC3B;EAGU,cAAc,OAAc;AAClC,SAAK,aAAa;EACtB;;;;;EAMA,IAAW,YAAS;AAChB,WAAO,KAAK;EAChB;;;;;EAKA,IAAW,UAAU,OAAc;AAC/B,SAAK,cAAc,KAAK;EAC5B;;;;EAOA,IAAW,aAAU;AACjB,WAAO,KAAK;EAChB;;;;EAIA,IAAW,WAAW,OAAa;AAC/B,SAAK,cAAc;AACnB,SAAK,6BAA4B;EACrC;;;;EAOA,IAAW,aAAU;AACjB,WAAO,KAAK;EAChB;;;;EAIA,IAAW,WAAW,OAAa;AAC/B,SAAK,cAAc;AACnB,SAAK,6BAA4B;EACrC;;;;;EAwBO,gCAA6B;AAChC,QAAI,KAAK,UAAU,KAAK,OAAO,gBAAgB;AAC3C,UAAI,CAAC,KAAK,qBAAqB;AAC3B,aAAK,sBAAsB,QAAQ,KAAI;;AAE3C,cAAQ,0BAA0B,KAAK,UAAU,KAAK,OAAO,eAAc,GAAI,KAAK,mBAAmB;AAGvG,UAAI,KAAK,WAAW;AAChB,YAAI,CAAC,KAAK,sBAAsB;AAC5B,eAAK,uBAAuB,QAAQ,KAAI;;AAE5C,gBAAQ,qBAAqB,KAAK,WAAW,KAAK,OAAO,eAAc,GAAI,KAAK,oBAAoB;;AAExG,aAAO;;AAEX,WAAO;EACX;;;;;EAMO,gBAAa;AAChB,WAAO;EACX;;;;;;;EAQO,mBAAmB,WAAkB;AACxC,WAAO,KAAK,uBAAuB,KAAK,uBAAuB,KAAK;EACxE;;;;;EAMO,sBAAmB;AACtB,WAAO,KAAK,sBAAsB,KAAK,sBAAsB,KAAK;EACtE;;;;;;EAOO,qBAAqB,QAAe;AACvC,SAAK,YAAY,QAAQ,UAAU,OAAO,SAAS,KAAK,QAAQ,CAAC;AACjE,WAAO,KAAK;EAChB;;;;;EAMO,cAAW;AACd,SAAK,UAAU,UAAS;AACxB,UAAM,QAAQ,QAAQ,MAAM,KAAK,WAAW,KAAK,CAAC;AAClD,UAAM,QAAQ,QAAQ,MAAM,OAAO,KAAK,SAAS;AACjD,WAAO,QAAQ,iBAAiB,OAAO,OAAO,KAAK,SAAS;EAChE;;;;;EAMO,WAAQ;AACX,WAAO;EACX;;;;;EAMO,8BAA2B;AAC9B,WAAO,KAAK;EAChB;;;;EAKO,+BAA4B;AAC/B,SAAK,+BAA+B;EACxC;;EAGO,aAAU;AACb,UAAM,WAAU;AAEhB,SAAK,OAAO,WAAW,QAAQ,KAAI;EACvC;;EAGO,kBAAe;AAClB,QAAI,CAAC,KAAK,OAAO,SAAS,OAAO,KAAK,QAAQ,GAAG;AAC7C,aAAO;;AAGX,WAAO;EACX;;;;;;EAOO,mBAAmB,OAAe;AACrC,QAAI,CAAC,SAAS,KAAK,eAAc,GAAI;AACjC,WAAK,mBAAmB,KAAK,SAAQ,EAAG,YAAW;AACnD,aAAO,KAAK;;AAGhB,SAAK,aAAY;AACjB,SAAK,OAAO,SAAS,SAAS,KAAK,QAAQ;AAE3C,QAAI,CAAC,KAAK,cAAc;AACpB,WAAK,eAAe,OAAO,SAAQ;;AAGvC,WAAO,iBAAiB,KAAK,SAAS,GAAG,KAAK,SAAS,GAAG,KAAK,SAAS,GAAG,KAAK,YAAY;AAE5F,QAAI,KAAK,UAAU,KAAK,OAAO,gBAAgB;AAC3C,WAAK,aAAa,cAAc,KAAK,OAAO,eAAc,GAAI,KAAK,YAAY;AAE/E,WAAK,sBAAqB;;AAI9B,SAAK,iCAAiC;AAEtC,WAAO,KAAK;EAChB;;;;;;EAOO,aAAa,cAAoB;AACpC,WAAO,KAAK,eAAe,SAAY,KAAK,aAAa,aAAa;EAC1E;;;;;;EAOO,aAAa,cAAoB;AACpC,WAAO,KAAK,eAAe,SAAY,KAAK,aAAa,aAAa;EAC1E;;;;;;;;EASO,0BAA0B,QAAgB,YAAoB,YAA+B;AAChG,QAAI,KAAK,+BAA+B;AACpC,WAAK,8BAA8B,YAAY,YAAY,MAAM;WAC9D;AACH,WAAK,kCAAkC,QAAQ,YAAY,UAAU;;AAEzE,WAAO;EACX;;EAGU,0BAAuB;AAC7B,UAAM,wBAAuB;AAC7B,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,OAAO,gBAAgB;AAC5C,WAAK,sBAA8B;AACnC,WAAK,uBAA+B;;EAE7C;;;;;;EAUO,cAAc,WAAkB;AACnC,UAAM,iBAAiB,WAAW,QAAQ,CAAC;AAE3C,QAAI,gBAAgB,KAAK;AACzB,QAAI,KAAK,8BAA6B,GAAI;AACtC,sBAAgB,KAAK;;AAGzB,YAAQ,eAAe,KAAK,mBAAmB,SAAS,GAAG,cAAc;AACzE,QAAI,KAAK,IAAI,QAAQ,IAAI,gBAAgB,QAAQ,GAAE,CAAE,CAAC,MAAM,GAAK;AAC7D,qBAAe,IAAI;;AAGvB,UAAM,cAAc,WAAW,QAAQ,CAAC;AACxC,kBAAc,SAAS,gBAAgB,WAAW;AAElD,WAAO,cAAc,eAAe,aAAa,QAAQ,GAAE,GAAI,KAAK,WAAW;AAE/E,WAAO,KAAK;EAChB;;;;;;;;EASO,oBAAoB,YAAqB,YAAgC;AAC5E,SAAK,0BAA0B,KAAK,mBAAmB,cAAc,KAAK,aAAa,cAAc,CAAA,CAAE;AAEvG,WAAO,KAAK;EAChB;;AAjTA,WAAA;EADC,mBAAkB;;AAqBnB,WAAA;EADC,mBAAkB;;AAiBnB,WAAA;EADC,UAAS;;AAiBV,WAAA;EADC,UAAS;;;;ACjLd,KAAK,mBAAmB,gBAAgB,CAACC,QAAM,UAAS;AACpD,SAAO,MAAM,IAAI,iBAAiBA,QAAM,QAAQ,KAAI,GAAI,KAAK;AACjE,CAAC;AAQK,IAAO,mBAAP,cAAgC,YAAW;;;;EAM7C,IAAW,oBAAiB;AACxB,WAAO,KAAK;EAChB;;;;EAIA,IAAW,kBAAkB,OAAa;AACtC,SAAK,qBAAqB;AAC1B,SAAK,6BAA4B;EACrC;;;;;;EASA,IAAW,mBAAgB;AACvB,WAAO,KAAK;EAChB;;;;;;EAMA,IAAW,iBAAiB,OAAa;AACrC,SAAK,oBAAoB;AACzB,SAAK,6BAA4B;EACrC;;;;EA6BA,IAAW,YAAS;AAChB,WAAO,KAAK;EAChB;EAEA,IAAW,UAAU,MAAY;AAC7B,SAAK,aAAa;EACtB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK;EAChB;EAEA,IAAW,WAAW,OAAa;AAC/B,SAAK,cAAc;EACvB;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;EAEA,IAAW,SAAS,KAAW;AAC3B,SAAK,YAAY;EACrB;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK;EAChB;EAEA,IAAW,YAAY,QAAc;AACjC,SAAK,eAAe;EACxB;;;;;;;;;;EAWA,YAAYA,QAAc,WAAoB,OAAa;AACvD,UAAMA,QAAM,KAAK;AAlHb,SAAA,qBAAqB;AAgBrB,SAAA,oBAAoB;AAyBrB,SAAA,oBAAoB;AAOpB,SAAA,wBAAwB;AAIvB,SAAA,aAAa,OAAO;AAEpB,SAAA,cAAc,OAAO;AAErB,SAAA,YAAY,OAAO;AAEnB,SAAA,eAAe,OAAO;AAyD1B,SAAK,WAAW,UAAU,MAAM,EAAI;AACpC,SAAK,YAAY;EACrB;;;;;EAMO,eAAY;AACf,WAAO;EACX;;;;;EAMO,YAAS;AACZ,WAAO,MAAM;EACjB;;;;;;;;EASU,kCAAkC,QAAgB,YAAoB,YAA+B;AAC3G,QAAI,KAAK,oBAAoB,GAAG;AAC5B,WAAK,8CAA8C,MAAM;WACtD;AACH,WAAK,4CAA4C,QAAQ,YAAY,UAAU;;EAEvF;;;;;;EAOU,8CAA8C,QAAc;AAClE,UAAM,eAAe,KAAK,SAAQ,EAAG;AAErC,QAAI,CAAC,cAAc;AACf;;AAGJ,WAAO,aACH,KAAK,mBACL,KAAK,mBACL,KAAK,eAAe,SAAY,KAAK,aAAa,aAAa,MAC/D,KAAK,eAAe,SAAY,KAAK,aAAa,aAAa,MAC/D,QACA,KAAK,SAAQ,EAAG,UAAS,EAAG,eAAe;EAEnD;;;;;;;;EASU,4CAA4C,QAAgB,YAAoB,YAA+B;AACrH,UAAM,eAAe,KAAK,SAAQ,EAAG;AAErC,QAAI,CAAC,cAAc;AACf;;AAIJ,QAAI,KAAK,qBAAqB,KAAK,eAAe,OAAO,WAAW;AAChE,YAAM,cAAc,QAAQ,KAAI;AAEhC,WAAK,aAAa,OAAO;AACzB,WAAK,cAAc,CAAC,OAAO;AAC3B,WAAK,YAAY,CAAC,OAAO;AACzB,WAAK,eAAe,OAAO;AAE3B,UAAI,aAAa,OAAO;AACxB,UAAI,aAAa,CAAC,OAAO;AAEzB,eAAS,YAAY,GAAG,YAAY,WAAW,QAAQ,aAAa;AAChE,cAAM,OAAO,WAAW,SAAS;AAEjC,YAAI,CAAC,MAAM;AACP;;AAGJ,cAAM,eAAe,KAAK,gBAAe;AACzC,cAAM,cAAc,aAAa;AAEjC,iBAAS,QAAQ,GAAG,QAAQ,YAAY,aAAa,QAAQ,SAAS;AAClE,kBAAQ,0BAA0B,YAAY,aAAa,KAAK,GAAG,YAAY,WAAW;AAE1F,cAAI,YAAY,IAAI,KAAK,YAAY;AACjC,iBAAK,aAAa,YAAY;;AAElC,cAAI,YAAY,IAAI,KAAK,cAAc;AACnC,iBAAK,eAAe,YAAY;;AAGpC,cAAI,YAAY,IAAI,KAAK,aAAa;AAClC,iBAAK,cAAc,YAAY;;AAEnC,cAAI,YAAY,IAAI,KAAK,WAAW;AAChC,iBAAK,YAAY,YAAY;;AAEjC,cAAI,KAAK,uBAAuB;AAC5B,gBAAI,YAAY,IAAI,YAAY;AAC5B,2BAAa,YAAY;;AAE7B,gBAAI,YAAY,IAAI,YAAY;AAC5B,2BAAa,YAAY;;;;;AAMzC,UAAI,KAAK,uBAAuB;AAC5B,aAAK,cAAc;AACnB,aAAK,cAAc;;;AAI3B,UAAM,UAAU,KAAK,cAAc,KAAK;AACxC,UAAM,UAAU,KAAK,YAAY,KAAK;AAEtC,UAAM,OAAO,KAAK,eAAe,SAAY,KAAK,aAAa,aAAa;AAC5E,UAAM,OAAO,KAAK,eAAe,SAAY,KAAK,aAAa,aAAa;AAE5E,UAAM,wBAAwB,KAAK,SAAQ,EAAG,UAAS,EAAG;AAE1D,WAAO,sBACH,KAAK,aAAa,UAAU,KAAK,kBACjC,KAAK,cAAc,UAAU,KAAK,kBAClC,KAAK,eAAe,UAAU,KAAK,kBACnC,KAAK,YAAY,UAAU,KAAK,kBAChC,wBAAwB,OAAO,MAC/B,wBAAwB,OAAO,MAC/B,QACA,KAAK,SAAQ,EAAG,UAAS,EAAG,eAAe;EAEnD;EAEU,sBAAmB;AACzB,SAAK,eAAe,WAAW,cAAc,CAAC;AAC9C,SAAK,eAAe,WAAW,iBAAiB,CAAC;AACjD,SAAK,eAAe,WAAW,kBAAkB,CAAC;AAClD,SAAK,eAAe,WAAW,eAAe,CAAC;AAC/C,SAAK,eAAe,WAAW,eAAe,CAAC;AAC/C,SAAK,eAAe,OAAM;EAC9B;;;;;;;EAQO,iBAAiB,QAAgB,YAAkB;AACtD,QAAI,KAAK,8BAA6B,GAAI;AACtC,WAAK,eAAe,aAAa,cAAc,KAAK,qBAAqB,GAAG,KAAK,qBAAqB,GAAG,KAAK,qBAAqB,GAAG,GAAG,UAAU;AACnJ,aAAO;;AAEX,SAAK,eAAe,aAAa,cAAc,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,GAAG,UAAU;AAClH,WAAO;EACX;EAEO,6BAA6B,QAAgB,sBAA4B;AAC5E,QAAI,KAAK,8BAA6B,GAAI;AACtC,aAAO,UAAU,sBAAsB,KAAK,qBAAqB,GAAG,KAAK,qBAAqB,GAAG,KAAK,qBAAqB,CAAC;AAC5H,aAAO;;AAGX,WAAO,UAAU,sBAAsB,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,UAAU,CAAC;AAC3F,WAAO;EACX;;;;;;;;;;;EAYO,aAAa,cAAoB;AACpC,UAAM,SAAS,KAAK,OAAO,UAAS;AACpC,WAAO,CAAC,OAAO,yBAAyB,OAAO,kBAAkB,IAAI;EACzE;;;;;;;;;;;EAYO,aAAa,cAAoB;AACpC,UAAM,SAAS,KAAK,OAAO,UAAS;AACpC,WAAO,OAAO,yBAAyB,OAAO,kBAAkB,IAAI;EACxE;;;;;;EAOO,4BAA4B,SAAc,YAAkB;AAC/D,YAAQ,aAAa,UAAU,IAAI;EACvC;;AAvUA,WAAA;EADC,UAAS;;AAmBV,WAAA;EADC,UAAS;;AAmBH,WAAA;EADN,UAAS;;AAQH,WAAA;EADN,UAAS;;AAKF,WAAA;EADP,UAAU,WAAW;;AAGd,WAAA;EADP,UAAU,YAAY;;AAGf,WAAA;EADP,UAAU,UAAU;;AAGb,WAAA;EADP,UAAU,aAAa;;;;ACnC5B,IAAM,uBAAuB;EACzB,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG;EAE3B,CAAC,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG;EAC5B,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG;EAC3B,CAAC,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG;EAE5B,KAAK,KAAK,MAAM,IAAI,KAAK,GAAG;EAC5B,CAAC,KAAK,KAAK,MAAM,IAAI,KAAK,GAAG;EAC7B,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;EAC5B,CAAC,KAAK,KAAK,MAAM,IAAI,KAAK,GAAG;EAC7B,KAAK,KAAK,MAAM,KAAK,KAAK,GAAG;;;AAOjC,IAAM,gCAAgC;EAClC,MAAM;EAEN,CAAC,cAAuB,UAAU;EAClC,CAAC,cAAuB,UAAU;EAClC,CAAC,cAAuB,UAAU;EAElC,CAAC,cAAuB,UAAU,IAAI,UAAU;EAChD,CAAC,cAAuB,UAAU,IAAI,UAAU;EAChD,CAAC,cAAuB,IAAI,UAAU,IAAI,UAAU,IAAI;EACxD,CAAC,cAAuB,UAAU,IAAI,UAAU;EAChD,CAAC,cAAuB,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU;;;AAIhF,IAAM,WAAW,CAAC,IAAY,cAAsB;AAChD,SAAO,qBAAqB,EAAE,IAAI,8BAA8B,EAAE,EAAE,SAAS;AACjF;AAIA,IAAM,yBAAyB,CAAC,KAAK,IAAK,IAAI,KAAK,KAAM,GAAI,IAAI,KAAK,KAAM,GAAI,IAAI,KAAK,KAAM,GAAG,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC;AAK3J,IAAO,qBAAP,MAAO,oBAAkB;EAA/B,cAAA;AAIW,SAAA,YAAY;AAKZ,SAAA,MAAe,QAAQ,KAAI;AAK3B,SAAA,OAAgB,QAAQ,KAAI;AAK5B,SAAA,MAAe,QAAQ,KAAI;AAK3B,SAAA,MAAe,QAAQ,KAAI;AAK3B,SAAA,OAAgB,QAAQ,KAAI;AAK5B,SAAA,OAAgB,QAAQ,KAAI;AAK5B,SAAA,MAAe,QAAQ,KAAI;AAK3B,SAAA,MAAe,QAAQ,KAAI;AAK3B,SAAA,MAAe,QAAQ,KAAI;EAiMtC;;;;;;;EAzLW,SAAS,WAAoB,OAAe,iBAAuB;AACtE,eAAW,QAAQ,CAAC,EAAE,IAAI,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;AACnD,UAAM,cAAc,WAAW,QAAQ,CAAC;AACxC,UAAM,IAAI,WAAW,QAAQ,CAAC;AAC9B,gBAAY,WAAW,iBAAiB,CAAC;AAEzC,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,IAAI,WAAW,WAAW,QAAQ,CAAC,CAAC;AAEzC,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,KAAK,WAAW,WAAW,QAAQ,CAAC,CAAC;AAC1C,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,IAAI,WAAW,WAAW,QAAQ,CAAC,CAAC;AACzC,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,IAAI,WAAW,WAAW,QAAQ,CAAC,CAAC;AAEzC,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,KAAK,WAAW,WAAW,QAAQ,CAAC,CAAC;AAC1C,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,KAAK,WAAW,WAAW,QAAQ,CAAC,CAAC;AAC1C,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,IAAI,WAAW,WAAW,QAAQ,CAAC,CAAC;AACzC,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,IAAI,WAAW,WAAW,QAAQ,CAAC,CAAC;AACzC,MAAE,WAAW,SAAS,GAAG,SAAS,GAAG,WAAW,QAAQ,CAAC,CAAC;AAC1D,SAAK,IAAI,WAAW,WAAW,QAAQ,CAAC,CAAC;EAC7C;;;;;EAMO,aAAa,OAAa;AAC7B,SAAK,IAAI,aAAa,KAAK;AAC3B,SAAK,KAAK,aAAa,KAAK;AAC5B,SAAK,IAAI,aAAa,KAAK;AAC3B,SAAK,IAAI,aAAa,KAAK;AAC3B,SAAK,KAAK,aAAa,KAAK;AAC5B,SAAK,KAAK,aAAa,KAAK;AAC5B,SAAK,IAAI,aAAa,KAAK;AAC3B,SAAK,IAAI,aAAa,KAAK;AAC3B,SAAK,IAAI,aAAa,KAAK;EAC/B;;;;;;;;;;;;EAaO,sCAAmC;AAEtC,SAAK,IAAI,aAAa,uBAAuB,CAAC,CAAC;AAG/C,SAAK,KAAK,aAAa,uBAAuB,CAAC,CAAC;AAChD,SAAK,IAAI,aAAa,uBAAuB,CAAC,CAAC;AAC/C,SAAK,IAAI,aAAa,uBAAuB,CAAC,CAAC;AAG/C,SAAK,KAAK,aAAa,uBAAuB,CAAC,CAAC;AAChD,SAAK,KAAK,aAAa,uBAAuB,CAAC,CAAC;AAChD,SAAK,IAAI,aAAa,uBAAuB,CAAC,CAAC;AAC/C,SAAK,IAAI,aAAa,uBAAuB,CAAC,CAAC;AAC/C,SAAK,IAAI,aAAa,uBAAuB,CAAC,CAAC;EACnD;;;;;;;;;;EAWO,wCAAqC;AACxC,SAAK,aAAa,IAAM,KAAK,EAAE;EAInC;;;;;;;;EASO,uBAAoB;AACvB,SAAK,YAAY;AAEjB,SAAK,IAAI,aAAa,qBAAqB,CAAC,CAAC;AAE7C,SAAK,KAAK,aAAa,qBAAqB,CAAC,CAAC;AAC9C,SAAK,IAAI,aAAa,qBAAqB,CAAC,CAAC;AAC7C,SAAK,IAAI,aAAa,qBAAqB,CAAC,CAAC;AAE7C,SAAK,KAAK,aAAa,qBAAqB,CAAC,CAAC;AAC9C,SAAK,KAAK,aAAa,qBAAqB,CAAC,CAAC;AAC9C,SAAK,IAAI,aAAa,qBAAqB,CAAC,CAAC;AAC7C,SAAK,IAAI,aAAa,qBAAqB,CAAC,CAAC;AAC7C,SAAK,IAAI,aAAa,qBAAqB,CAAC,CAAC;EACjD;;;;;;EAOO,gBAAgB,MAAkC;AACrD,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,GAAG;AAC3C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,IAAI;AAC5C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,GAAG;AAC3C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,GAAG;AAC3C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,IAAI;AAC5C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,IAAI;AAC5C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,GAAG;AAC3C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,GAAG;AAC3C,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,KAAK,GAAG;AAC3C,WAAO;EACX;;;;;;EAOO,sBAAsB,MAAuB;AAChD,YAAQ,gBAAgB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,GAAG;AAC3D,YAAQ,gBAAgB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,IAAI;AAC5D,YAAQ,gBAAgB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,GAAG;AAC3D,YAAQ,gBAAgB,KAAK,CAAC,GAAG,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,GAAG;AAC7D,YAAQ,gBAAgB,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,IAAI;AAC/D,YAAQ,gBAAgB,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,IAAI;AAC/D,YAAQ,gBAAgB,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,GAAG;AAC9D,YAAQ,gBAAgB,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,GAAG;AAC9D,YAAQ,gBAAgB,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,GAAG;AAC9D,WAAO;EACX;;;;;;EAOO,OAAO,UAAU,MAAkC;AACtD,UAAM,KAAK,IAAI,oBAAkB;AACjC,WAAO,GAAG,gBAAgB,IAAI;EAClC;;;;;;;EAQO,OAAO,eAAe,YAA+B;AACxD,UAAM,SAAS,IAAI,oBAAkB;AAErC,WAAO,MAAM,WAAW,GAAG,MAAM,QAAQ,EAAE,IAAI,WAAW,GAAG,MAAM,QAAQ,CAAC,EAAE,IAAI,WAAW,GAAG,MAAM,QAAQ,CAAC;AAC/G,WAAO,OAAO,WAAW,EAAE,MAAM,QAAQ;AACzC,WAAO,MAAM,WAAW,EAAE,MAAM,QAAQ;AACxC,WAAO,MAAM,WAAW,EAAE,MAAM,QAAQ;AACxC,WAAO,OAAO,WAAW,GAAG,MAAM,OAAO;AACzC,WAAO,OAAO,WAAW,GAAG,MAAM,OAAO;AACzC,WAAO,MAAM,WAAW,GAAG,MAAM,OAAO,EAAE,SAAS,WAAW,GAAG,MAAM,QAAQ,CAAC,EAAE,SAAS,WAAW,GAAG,MAAM,QAAQ,CAAC;AACxH,WAAO,MAAM,WAAW,GAAG,MAAM,OAAO;AACxC,WAAO,MAAM,WAAW,GAAG,MAAM,OAAO,EAAE,SAAS,WAAW,GAAG,MAAM,OAAO,CAAC;AAE/E,WAAO,KAAK,aAAa,EAAE;AAC3B,WAAO,IAAI,aAAa,EAAE;AAC1B,WAAO,KAAK,aAAa,EAAE;AAC3B,WAAO,IAAI,aAAa,EAAE;AAE1B,WAAO,aAAa,KAAK,EAAE;AAE3B,WAAO;EACX;;AAME,IAAO,sBAAP,MAAO,qBAAmB;EAAhC,cAAA;AAmBW,SAAA,IAAa,QAAQ,KAAI;AAKzB,SAAA,IAAa,QAAQ,KAAI;AAKzB,SAAA,IAAa,QAAQ,KAAI;AAKzB,SAAA,KAAc,QAAQ,KAAI;AAK1B,SAAA,KAAc,QAAQ,KAAI;AAK1B,SAAA,KAAc,QAAQ,KAAI;AAK1B,SAAA,KAAc,QAAQ,KAAI;AAK1B,SAAA,KAAc,QAAQ,KAAI;AAK1B,SAAA,KAAc,QAAQ,KAAI;EA+FrC;;;;EApJI,IAAW,qBAAkB;AACzB,QAAI,CAAC,KAAK,YAAY;AAClB,WAAK,aAAa,mBAAmB,eAAe,IAAI;;AAE5D,QAAI,CAAC,KAAK,WAAW,WAAW;AAC5B,WAAK,WAAW,qBAAoB;;AAExC,WAAO,KAAK;EAChB;;;;;EAmDO,WAAW,OAAa;AAC3B,eAAW,QAAQ,CAAC,EAAE,eAAe,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;AAC9D,UAAM,cAAc,WAAW,QAAQ,CAAC;AACxC,SAAK,GAAG,WAAW,WAAW;AAC9B,SAAK,GAAG,WAAW,WAAW;AAC9B,SAAK,GAAG,WAAW,WAAW;EAClC;;;;;EAMO,aAAa,OAAa;AAC7B,SAAK,EAAE,aAAa,KAAK;AACzB,SAAK,EAAE,aAAa,KAAK;AACzB,SAAK,EAAE,aAAa,KAAK;AACzB,SAAK,GAAG,aAAa,KAAK;AAC1B,SAAK,GAAG,aAAa,KAAK;AAC1B,SAAK,GAAG,aAAa,KAAK;AAC1B,SAAK,GAAG,aAAa,KAAK;AAC1B,SAAK,GAAG,aAAa,KAAK;AAC1B,SAAK,GAAG,aAAa,KAAK;EAC9B;;;;;;EAOO,oBAAoB,WAA6B;AACpD,SAAK,aAAa;AAElB,SAAK,EAAE,SAAS,UAAU,GAAG;AAC7B,SAAK,EAAE,aAAa,OAAO,EAAE,aAAa,EAAE;AAC5C,SAAK,EAAE,SAAS,UAAU,IAAI;AAC9B,SAAK,EAAE,aAAa,OAAO,EAAE,aAAa,EAAE;AAC5C,SAAK,EAAE,SAAS,UAAU,GAAG;AAC7B,SAAK,EAAE,aAAa,OAAO;AAE3B,SAAK,GAAG,SAAS,UAAU,GAAG;AAC9B,eAAW,QAAQ,CAAC,EAAE,SAAS,UAAU,GAAG,EAAE,aAAa,QAAQ;AACnE,eAAW,QAAQ,CAAC,EAAE,SAAS,UAAU,GAAG,EAAE,aAAa,QAAQ;AACnE,SAAK,GAAG,aAAa,QAAQ,EAAE,gBAAgB,WAAW,QAAQ,CAAC,CAAC,EAAE,WAAW,WAAW,QAAQ,CAAC,CAAC;AACtG,SAAK,GAAG,SAAS,UAAU,GAAG;AAC9B,SAAK,GAAG,aAAa,QAAQ,EAAE,gBAAgB,WAAW,QAAQ,CAAC,CAAC,EAAE,gBAAgB,WAAW,QAAQ,CAAC,CAAC;AAC3G,SAAK,GAAG,SAAS,UAAU,GAAG;AAC9B,eAAW,QAAQ,CAAC,EAAE,SAAS,UAAU,GAAG,EAAE,aAAa,QAAQ;AACnE,SAAK,GAAG,aAAa,QAAQ,EAAE,WAAW,WAAW,QAAQ,CAAC,CAAC;AAE/D,SAAK,GAAG,SAAS,UAAU,IAAI;AAC/B,SAAK,GAAG,aAAa,QAAQ,EAAE,aAAa,EAAE;AAC9C,SAAK,GAAG,SAAS,UAAU,GAAG;AAC9B,SAAK,GAAG,aAAa,QAAQ,EAAE,aAAa,EAAE;AAC9C,SAAK,GAAG,SAAS,UAAU,IAAI;AAC/B,SAAK,GAAG,aAAa,QAAQ;AAE7B,SAAK,aAAa,IAAM,KAAK,EAAE;AAE/B,WAAO;EACX;;;;;;EAOO,OAAO,cAAc,WAA6B;AACrD,UAAM,SAAS,IAAI,qBAAmB;AACtC,WAAO,OAAO,oBAAoB,SAAS;EAC/C;;;;;;EAOO,OAAO,UAAU,MAAkC;AACtD,UAAM,KAAK,IAAI,qBAAmB;AAClC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AACvC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AACvC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AACvC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;AACxC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;AACxC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;AACxC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;AACxC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;AACxC,YAAQ,eAAe,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;AACxC,WAAO;EACX;;;;ACneJ,IAAM,OAAO;AACb,IAAM,SAAS;;;;;;;AAQf,YAAY,aAAa,IAAI,IAAI;;;ACTjC,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;AAKf,YAAY,qBAAqBD,KAAI,IAAIC;;;ACNzC,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoIf,YAAY,qBAAqBD,KAAI,IAAIC;;;ACrIzC,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDf,YAAY,qBAAqBD,KAAI,IAAIC;;;ACpDzC,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;AAMf,YAAY,aAAaD,KAAI,IAAIC;;;ACkB3B,IAAO,eAAP,MAAmB;;;;;;;EAyBrB,YAAY,QAAoB,UAAgC,CAAA,GAAE;AApB1D,SAAA,uBAA+B;AAC/B,SAAA,sBAA8B;AAM/B,SAAA,UAAkB;AAKlB,SAAA,WAAmB;AAUtB,SAAK,UAAU;AACf,SAAK,WAAW,QAAQ,YAAY,KAAK;AACzC,SAAK,UAAU,QAAQ,WAAW,KAAK;EAC3C;EAEQ,oBAAoB,MAAY;AACpC,QAAI,cAAc;AAClB,QAAI,KAAK,QAAQ,QAAO,EAAG,wBAAwB;AAC/C,oBAAc;eACP,KAAK,QAAQ,QAAO,EAAG,oBAAoB;AAClD,oBAAc;;AAGlB,UAAM,YAAY,KAAK,QAAQ,8BAA8B,MAAM;MAC/D,QAAQ;MACR,MAAM;MACN,eAAe;MACf,iBAAiB;MACjB,qBAAqB;MACrB,uBAAuB;MACvB,cAAc;KACjB;AACD,SAAK,QAAQ,0BAA0B,UAAU,SAAU,GAAA,GAAA,CAAA;AAE3D,SAAK,QAAQ,0BAA0B,GAAA,UAAU,SAAA,IAAA;AAEjD,WAAO;EACX;EAEQ,mBAAmB,SAAoB;AAC3C,UAAM,QAAQ,QAAQ,QAAO,EAAG;AAChC,UAAM,eAAe,OAAO,MAAM,KAAK,IAAI;AAE3C,UAAM,SAAS,KAAK,eAAe;AACnC,UAAM,gBAAgB,KAAK,oBAAoB,KAAK;AACpD,SAAK,gBAAgB,WAAU;AAC/B,SAAK,gBAAgB,YAAW;AAEhC,UAAM,aAAa,QAAQ,mBAAkB;AAC7C,QAAI,YAAY;AAEZ,WAAK,QAAQ,0BAA0B,GAAA,YAAU,IAAA;;AAGrD,SAAK,gBAAgB,mBAAmB,KAAK,cAAc;AAE3D,UAAM,aAAa;MACf,CAAC,IAAI,QAAQ,GAAG,GAAG,EAAE,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,CAAC;MACnE,CAAC,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,IAAI,QAAQ,IAAI,GAAG,CAAC,CAAC;MACnE,CAAC,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,CAAC;MACjE,CAAC,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,EAAE,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;MACnE,CAAC,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,CAAC;MAClE,CAAC,IAAI,QAAQ,IAAI,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,EAAE,CAAC;;;AAGxE,WAAO,SAAS,YAAY,KAAK,QAAQ;AACzC,WAAO,UAAU,kBAAkB,QAAQ,QAAO,EAAG,OAAO,YAAY;AACxE,WAAO,WAAW,gBAAgB,OAAO;AAEzC,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,aAAO,WAAW,MAAM,WAAW,IAAI,EAAE,CAAC,CAAC;AAC3C,aAAO,WAAW,SAAS,WAAW,IAAI,EAAE,CAAC,CAAC;AAC9C,aAAO,WAAW,SAAS,WAAW,IAAI,EAAE,CAAC,CAAC;AAE9C,eAAS,MAAM,GAAG,MAAM,cAAc,OAAO;AACzC,aAAK,QAAQ,gBAAgB,eAAe,MAAM,QAAW,QAAW,MAAM,GAAG;AACjF,aAAK,gBAAgB,mBAAmB,KAAK,cAAc;AAE3D,YAAI,QAAQ,KAAK,IAAI,IAAI,MAAM,KAAK,wBAAwB,KAAK,mBAAmB,IAAI;AACxF,YAAI,QAAQ,GAAG;AACX,kBAAQ;;AAGZ,eAAO,SAAS,UAAU,KAAK;AAE/B,aAAK,gBAAgB,KAAI;;;AAKjC,SAAK,gBAAgB,cAAa;AAClC,SAAK,QAAQ,0BAAyB;AACtC,SAAK,QAAQ,gBAAgB,QAAQ,QAAS;AAG9C,UAAM,OAAO,cAAc,QAAS;AACpC,UAAM,SAAS,cAAc,QAAS;AAEtC,kBAAc,YAAY,QAAQ,QAAS;AAE3C,YAAQ,SAAU,OAAO;AACzB,YAAQ,SAAU,SAAS;AAG3B,YAAQ,aAAa;AACrB,YAAQ,sBAAsB,KAAK;AACnC,YAAQ,qBAAqB,KAAK;AAClC,YAAQ,eAAe;AAEvB,WAAO;EACX;EAEQ,cAAc,SAAsB,YAA+C;AACvF,UAAM,UAAU,CAAA;AAChB,QAAI,QAAQ,YAAY;AACpB,cAAQ,KAAK,qBAAqB;;AAGtC,YAAQ,KAAK,yBAAyB,KAAK,UAAU,GAAG;AAExD,UAAM,gBAAgB,IAAI,cAAc;MACpC,QAAQ,KAAK;MACb,MAAM;MACN,cAAc;MACd,gBAAgB;MAChB,cAAc,CAAC,cAAc;MAC7B,cAAc,CAAC,qBAAqB,YAAY,MAAM,SAAS,SAAS,kBAAkB,YAAY,QAAQ;MAC9G,gBAAgB;MAChB;MACA;KACH;AAED,WAAO;EACX;;;;;;EAOO,QAAQ,SAAoB;AAC/B,WAAO,QAAQ,QAAO,KAAM,KAAK,eAAe,OAAO,QAAO;EAClE;;;;;;;;;;EAWO,UAAU,SAAsB,aAAmC,MAAI;AAC1E,QAAI,CAAC,KAAK,QAAQ,UAAU,0BAA0B;AAClD,aAAO,KAAK,yFAAyF;AACrG,aAAO,QAAQ,OAAO,yFAAyF;;AAGnH,WAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,WAAK,kBAAkB,IAAI,eAAe,KAAK,OAAO;AACtD,WAAK,iBAAiB,KAAK,cAAc,OAAO;AAChD,WAAK,eAAe,OAAO,oBAAoB,MAAK;AAChD,aAAK,mBAAmB,OAAO;AAC/B,aAAK,gBAAgB,QAAO;AAC5B,aAAK,eAAe,QAAO;AAC3B,gBAAO;AACP,YAAI,YAAY;AACZ,qBAAU;;MAElB,CAAC;IACL,CAAC;EACL;;;;AChIE,IAAO,uBAAP,cAAoC,qBAAoB;;;;;;EAkD1D,YACI,mBAIgB,SAAqC;AAErD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAtDZ,SAAA,iBAA2E;AAC3E,SAAA,qBAA4C;AAC5C,SAAA,mBAA8C;AAC9C,SAAA,gBAAwC;AACxC,SAAA,kBAA4C;AAC5C,SAAA,kBAA2B,QAAQ,GAAE,EAAG,cAAa;AACrD,SAAA,cAAsB,OAAO,MAAK;AAClC,SAAA,aAAqB;AACrB,SAAA,sBAA0C,IAAI,mBAAkB;AAChE,SAAA,mBAAmB,KAAK,IAAG;AAC3B,SAAA,2BAA2B,KAAK,IAAG;AAkBnC,SAAA,gCAAwC;AASzC,SAAA,mBAA+C;AAK/C,SAAA,uCAAgE,IAAI,WAAU;AAyE7E,SAAA,2BAA2B,MAAW;AAjNlD;AAkNQ,UAAI,CAAC,KAAK,eAAe;AACrB;;AAGJ,UAAI,KAAK,QAAQ,qBAAqB;AAClC,cAAM,MAAM,KAAK,IAAG;AACpB,YAAI,MAAM,KAAK,mBAAmB,KAAK,QAAQ,qBAAqB;AAChE;;AAEJ,aAAK,mBAAmB;;AAE5B,YAAM,KAAK,KAAK,gBAAe,EAAG,qBAAqB,KAAK,aAAa;AACzE,UAAI,MAAM,KAAK,oBAAoB;AAC/B,YAAI,CAAC,KAAK,mBAAmB,UAAU;AACnC,gBAAM,kBAAkB,IAAI,gBAAgB,KAAK,kBAAkB,MAAM,UAAS,GAAI,sBAAsB,OAAO;AACnH,0BAAgB,SAAS;AACzB,0BAAgB,UAAU;AAC1B,0BAAgB,iBAAiB,KAAK,QAAQ,qBAAqB;AACnE,0BAAgB,SAAS;AACzB,0BAAgB,kBAAkB;AAClC,0BAAgB,OAAO,KAAK,QAAQ,qBAAqB,WAAW,IAAA;AACpE,0BAAgB,eAAe;AAC/B,0BAAgB,QAAQ,KAAK;AAC7B,0BAAgB,SAAS,KAAK;AAC9B,0BAAgB,eAAe;AAC/B,0BAAgB,eAAe;AAC/B,0BAAgB,mBAAmB,IAAI,qBAAqB,IAAI,KAAK,kBAAiB,CAA2B;AACjH,eAAK,mBAAmB,WAAW;eAChC;AACH,qBAAK,mBAAmB,SAAS,qBAAjC,mBAAmD,IAAI;AACvD,eAAK,mBAAmB,SAAS,UAAS,EAAG,kBAAiB;;AAElE,aAAK,mBAAmB,SAAS,UAAU;AAC3C,YAAI,CAAC,KAAK,QAAQ,qBAAqB;AACnC,eAAK,cAAe,oBAAoB,oBAAoB,KAAK,wBAAwB;AACzF,eAAK,WAAW,UAAU,KAAK,kBAAkB,EAAE,KAAK,MAAK;AACzD,iBAAK,kBAAkB,MAAM,wBAAwB,CAAA;AACrD,iBAAK,qCAAqC,gBAAgB,KAAK,kBAAmB;AAClF,iBAAK,cAAe,iBAAiB,oBAAoB,KAAK,wBAAwB;UAC1F,CAAC;eACE;AACH,eAAK,kBAAkB,MAAM,wBAAwB,CAAA;AAErD,eAAK,qCAAqC,gBAAgB,KAAK,kBAAkB;;;IAG7F;AAzGI,SAAK,sBAAsB;AAE3B,QAAI,KAAK,QAAQ,8BAA8B;AAC3C,WAAK,mBAAmB,IAAI,iBAAiB,gCAAgC,KAAK,iBAAiB,KAAK,kBAAkB,KAAK;AAC/H,WAAK,iBAAiB,WAAW,IAAI,QAAQ,GAAG,GAAG,CAAC;AAEpD,WAAK,iBAAiB,YAAY;AAClC,WAAK,iBAAiB,cAAc,eAAe;;AAGvD,SAAK,aAAa,IAAI,aAAa,KAAK,kBAAkB,MAAM,UAAS,CAAE;AAG3E,UAAM,KAAK,2DAA2D;EAC1E;;;;;;EAOA,IAAW,2BAAwB;AAC/B,WAAO,KAAK;EAChB;;;;EAKA,IAAW,qBAAkB;AACzB,QAAI,KAAK,kBAAkB;AACvB,aAAO;QACH,YAAY,KAAK;QACjB,gBAAgB,KAAK;QACrB,gBAAgB,KAAK;QACrB,oBAAoB,KAAK;;;AAGjC,WAAO,KAAK;EAChB;EAEQ,oBAAiB;AACrB,QAAI,KAAK,mBAAmB,MAAM;AAC9B,WAAK,iBAAiB,KAAK,kBAAkB,MAAM,UAAS,EAAG;;AAEnE,WAAO,KAAK;EAChB;EAEQ,kBAAe;AACnB,QAAI,KAAK,oBAAoB,MAAM;AAC/B,YAAM,UAAU,KAAK,kBAAiB;AACtC,WAAK,kBAAkB,IAAI,eAAe,KAAK,kBAAkB,SAAS,OAAO;;AAErF,WAAO,KAAK;EAChB;;;;;;;EA4DO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,UAAM,mBAAmB,KAAK,QAAQ,qBAAqB,KAAK,kBAAkB,QAAQ,6BAA6B;AACvH,SAAK,QAAQ,mBAAmB;AAChC,SAAK,kBAAkB,QAClB,kBAAkB;MACf;KACH,EACA,KAAK,CAAC,iBAA8B;AACjC,WAAK,gBAAgB;AACrB,UAAI,CAAC,KAAK,QAAQ,0BAA0B;AACxC,YAAI,CAAC,KAAK,oBAAoB;AAC1B,eAAK,qBAAqB,IAAI,YAAY,KAAK,kBAAkB,KAAK;AACtE,eAAK,mBAAmB,UAAU;AAClC,eAAK,mBAAmB,kBAAkB;AAC1C,cAAI,KAAK,QAAQ,4BAA4B;AACzC,iBAAK,kBAAkB,MAAM,qBAAqB,KAAK;;;AAG/D,aAAK,cAAc,iBAAiB,oBAAoB,KAAK,wBAAwB;;IAE7F,CAAC;AAEL,WAAO;EACX;;;;;;;EAQO,SAAM;AACT,UAAM,WAAW,MAAM,OAAM;AAE7B,QAAI,KAAK,kBAAkB,QAAQ,CAAC,KAAK,QAAQ,0BAA0B;AACvE,WAAK,cAAc,oBAAoB,oBAAoB,KAAK,wBAAwB;AACxF,WAAK,gBAAgB;;AAGzB,SAAK,iBAAiB;AACtB,SAAK,mBAAmB;AAExB,SAAK,kBAAkB;AAEvB,WAAO;EACX;;;;EAKO,UAAO;AACV,UAAM,QAAO;AAEb,SAAK,qCAAqC,MAAK;AAE/C,QAAI,KAAK,kBAAkB;AACvB,WAAK,iBAAiB,QAAO;AAC7B,WAAK,mBAAmB;;AAG5B,QAAI,KAAK,uBAAuB,MAAM;AAClC,UAAI,KAAK,mBAAmB,UAAU;AAClC,aAAK,mBAAmB,SAAS,QAAO;;AAE5C,WAAK,mBAAmB,QAAO;AAC/B,WAAK,qBAAqB;;EAElC;EAEU,WAAW,UAAiB;AAjV1C;AAkVQ,QAAI,KAAK,kBAAkB,MAAM;AAC7B,UAAI,KAAK,QAAQ,6BAA6B;AAC1C,cAAM,MAAM,KAAK,IAAG;AACpB,YAAI,MAAM,KAAK,2BAA2B,KAAK,QAAQ,6BAA6B;AAChF;;AAEJ,aAAK,2BAA2B;;AAEpC,WAAK,mBAAmB,SAAS,iBAAiB,KAAK,aAAa;AACpE,UAAI,KAAK,kBAAkB;AACvB,aAAK,aAAa,KAAK,IACnB,GACA,KAAK,iBAAiB,sBAAsB,GAC5C,KAAK,iBAAiB,sBAAsB,GAC5C,KAAK,iBAAiB,sBAAsB,CAAC;AAGjD,cAAM,YAAY,KAAK,kBAAkB,MAAM,uBAAuB,IAAM;AAG5E,YAAI,KAAK,QAAQ,oBAAoB;AACjC,eAAK,kBAAkB,IAAI,QAAO;AAClC,eAAK,cAAc,IAAI,OAAM;AAC7B,cAAI,KAAK,kBAAkB;AACvB,iBAAK,iBAAiB,YAAY,KAAK;AACvC,iBAAK,iBAAiB,UAAU,KAAK;;;AAI7C,aAAK,gBAAgB,eACjB,KAAK,iBAAiB,sBAAsB,GAC5C,KAAK,iBAAiB,sBAAsB,GAC5C,KAAK,iBAAiB,sBAAsB,IAAI,SAAS;AAE7D,aAAK,YAAY,eACb,KAAK,iBAAiB,sBAAsB,IAAI,KAAK,YACrD,KAAK,iBAAiB,sBAAsB,IAAI,KAAK,YACrD,KAAK,iBAAiB,sBAAsB,IAAI,KAAK,UAAU;AAEnE,aAAK,oBAAoB,sBAAsB,KAAK,iBAAiB,8BAA8B;AACnG,YAAI,KAAK,sBAAsB,CAAC,KAAK,QAAQ,4BAA4B;AACrE,eAAK,mBAAmB,sBAAsB,KAAK,mBAAmB,uBAAuB,IAAI,oBAAmB;AACpH,qBAAK,mBAAmB,wBAAxB,mBAA6C,oBAAoB,KAAK;;AAI1E,aAAK,gBAAgB,cAAa;AAElC,YAAI,KAAK,kBAAkB;AACvB,eAAK,iBAAiB,UAAU,SAAS,KAAK,eAAe;AAC7D,eAAK,iBAAiB,YAAY,KAAK,IAAI,KAAK,YAAY,CAAG;AAC/D,eAAK,iBAAiB,QAAQ,SAAS,KAAK,WAAW;;;;EAIvE;;AA5RuB,qBAAA,OAAO,iBAAiB;AAMxB,qBAAA,UAAU;AA0RrC,qBAAqB,gBACjB,qBAAqB,MACrB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,qBAAqB,kBAAkB,OAAO;AACnE,GACA,qBAAqB,SACrB,KAAK;;;ACvYH,IAAO,mBAAP,cAAgC,qBAAoB;;;;;EAgCtD,YAAY,mBAAsC;AAC9C,UAAM,iBAAiB;AAfX,SAAA,iCAAkD,IAAI,WAAU;AAIhE,SAAA,+BAAiD,IAAI,WAAU;AAI/D,SAAA,qCAAsD,IAAI,WAAU;AA2E5E,SAAA,4BAA4B,CAAC,UAAmC;AACpE,WAAK,kBAAkB,MAAM;AAC7B,WAAK,WAAW,IAAI,IAAI,QAAQ,KAAI,GAAI,QAAQ,QAAO,CAAE;AACzD,WAAK,+BAA+B,gBAAgB,KAAK,QAAQ;IACrE;AAEQ,SAAA,0BAA0B,MAAK;AACnC,WAAK,kBAAkB;AACvB,WAAK,WAAW;AAChB,WAAK,6BAA6B,gBAAe;IACrD;AA7EI,SAAK,sBAAsB;AAC3B,QAAI,KAAK,kBAAkB,SAAS;AAChC,WAAK,MAAK;WACP;AACH,WAAK,kBAAkB,gBAAgB,QAAQ,MAAK;AAChD,aAAK,MAAK;MACd,CAAC;;EAET;;;;EAKO,UAAO;AACV,UAAM,QAAO;AAEb,SAAK,kBAAkB,QAAQ,oBAAoB,oBAAoB,KAAK,yBAAyB;AACrG,SAAK,kBAAkB,QAAQ,oBAAoB,kBAAkB,KAAK,uBAAuB;AAEjG,SAAK,+BAA+B,MAAK;AACzC,SAAK,6BAA6B,MAAK;AACvC,SAAK,mCAAmC,MAAK;EACjD;;;;;EAMA,IAAW,iBAAc;AACrB,WAAO,CAAC,CAAC,KAAK;EAClB;;;;;EAMO,aAAU;AACb,WAAO,KAAK;EAChB;EAEU,WAAW,OAAc;AAC/B,QAAI,CAAC,KAAK,YAAY,CAAC,OAAO;AAC1B;;AAGJ,QAAI,KAAK,mBAAmB,KAAK,UAAU;AACvC,YAAM,OAAO,MAAM,QAAQ,KAAK,iBAAiB,KAAK,kBAAkB,cAAc;AACtF,UAAI,MAAM;AACN,aAAK,SAAS,OAAO,IAAI,KAAK,UAAU,SAAS,GAAG,KAAK,UAAU,SAAS,GAAG,KAAK,UAAU,SAAS,CAAC,EAAE,aAAa,KAAK,kBAAkB,kBAAkB;AAChK,cAAM,OAAO,KAAK,UAAU;AAC5B,mBAAW,WAAW,CAAC,EAAE,IAAI,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAE3D,YAAI,CAAC,KAAK,kBAAkB,MAAM,sBAAsB;AACpD,eAAK,SAAS,OAAO,KAAK;AAC1B,qBAAW,WAAW,CAAC,EAAE,KAAK;AAC9B,qBAAW,WAAW,CAAC,EAAE,KAAK;AAE9B,kBAAQ,0BAA0B,wBAAwB,WAAW,WAAW,CAAC,GAAG,KAAK,SAAS,SAAS;eACxG;AACH,kBAAQ,2BAA2B,wBAAwB,WAAW,WAAW,CAAC,GAAG,KAAK,SAAS,SAAS;;AAGhH,aAAK,mCAAmC,gBAAgB,KAAK,QAAQ;;;EAGjF;EAcQ,QAAK;AAET,QAAI,KAAK,kBAAkB,UAAU;AACjC,WAAK,kBAAkB,QAAQ,iBAAiB,oBAAoB,KAAK,yBAAyB;AAClG,WAAK,kBAAkB,QAAQ,iBAAiB,kBAAkB,KAAK,uBAAuB;;EAEtG;;AAhHuB,iBAAA,OAAO,iBAAiB;AAMxB,iBAAA,UAAU;AA6GrC,qBAAqB,gBACjB,iBAAiB,MACjB,CAAC,qBAAoB;AACjB,SAAO,MAAM,IAAI,iBAAiB,gBAAgB;AACtD,GACA,iBAAiB,SACjB,KAAK;;;ACjIT,IAAM,eAAN,MAAkB;EAId,YAAY,YAAoB,aAA2B;AAHnD,SAAA,WAA2B,CAAA;AAC3B,SAAA,OAAe;AAGnB,aAAS,MAAM,GAAG,MAAM,YAAY,EAAE,KAAK;AACvC,WAAK,SAAS,KAAK,cAAc,YAAW,IAAK,QAAQ,KAAI,CAAE;;EAEvE;EAEA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS;EACzB;EAEO,KAAK,GAAW,GAAS;AAC5B,SAAK,QAAQ,KAAK,OAAO,KAAK,SAAS,SAAS,KAAK,KAAK,SAAS;AACnE,SAAK,GAAG,CAAC,EAAE,eAAe,GAAG,CAAC;EAClC;EAEO,GAAG,KAAW;AACjB,QAAI,OAAO,KAAK,SAAS,QAAQ;AAC7B,YAAM,IAAI,MAAM,qBAAqB;;AAEzC,WAAO,KAAK,UAAU,KAAK,OAAO,OAAO,KAAK,SAAS,MAAM;EACjE;;AAUJ,IAAM,oBAAN,MAAuB;EAAvB,cAAA;AACY,SAAA,WAAW,IAAI,aAAa,EAAE;AAC9B,SAAA,WAAW;AAEZ,SAAA,sBAAiD,IAAI,WAAU;EAoH1E;EAlHW,OAAO,MAAc,MAAc,UAAkB,UAAgB;AACxE,SAAK,SAAS,KAAK,MAAM,IAAI;AAC7B,UAAM,SAAS,KAAK,SAAS,GAAG,CAAC;AAEjC,SAAK,YAAY,KAAK;AACtB,SAAK,YAAY,QAAQ,SAAS,QAAQ,KAAK,SAAS,GAAG,CAAC,CAAC;AAC7D,QAAI,KAAK,WAAW,KAAK,mBAAmB;AACxC;;AAGJ,QAAI;AACJ,SAAK,eAAe,KAAK,yBAAyB,eAAe,KAAK,SAAS,QAAQ,EAAE,cAAc;AACnG,UAAI,QAAQ,gBAAgB,QAAQ,KAAK,SAAS,GAAG,YAAY,CAAC,IAAI,KAAK,oCAAoC;AAC3G;;;AAIR,QAAI,iBAAiB,KAAK,SAAS,QAAQ;AACvC;;AAGJ,QAAI,kBAAkB;AACtB,QAAI,UAAU;AACd,aAAS,aAAa,MAAM,GAAG,MAAM,cAAc,EAAE,KAAK;AACtD,oBAAc,QAAQ,gBAAgB,QAAQ,KAAK,SAAS,GAAG,GAAG,CAAC;AACnE,UAAI,cAAc,iBAAiB;AAC/B,kBAAU;AACV,0BAAkB;;;AAI1B,QAAI,kBAAkB,KAAK,+BAA+B;AACtD;;AAGJ,UAAM,OAAO,KAAK,SAAS,GAAG,OAAO;AACrC,UAAM,OAAO,KAAK,SAAS,MAAM;AACjC,SAAK,UAAS;AAEd,UAAM,MAAM,WAAW,QAAQ,CAAC;AAChC,QAAI;AACJ,QAAI;AACJ,QAAI,gCAAgC;AACpC,aAAS,MAAM,GAAG,MAAM,cAAc,EAAE,KAAK;AACzC,eAAS,KAAK,SAAS,GAAG,GAAG;AAC7B,aAAO,cAAc,QAAQ,GAAG;AAChC,YAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,uCAAiC,IAAI,cAAa,IAAK,MAAM;;AAGjE,QAAI,gCAAgC,eAAe,KAAK,qCAAqC;AACzF;;AAGJ,UAAM,aAAa,WAAW,QAAQ,CAAC;AACvC,eAAW,IAAI,UAAU,UAAU,CAAC;AACpC,UAAM,UAAU,WAAW,QAAQ,CAAC;AACpC,YAAQ,IAAI,KAAK,GAAG,KAAK,GAAG,CAAC;AAC7B,UAAM,aAAa,QAAQ,MAAM,YAAY,OAAO,EAAE,IAAI;AAC1D,UAAM,WAAW,OAAO,MAAK;AAC7B,UAAM,YAAY,OAAO,MAAK;AAC9B,SAAK,cAAc,QAAQ,IAAI;AAC/B,QAAI,YAAY;AACZ,WAAK,iBAAiB,KAAK,yBAAyB,QAAQ;AAC5D,WAAK,iBAAiB,KAAK,yBAAyB,SAAS;WAC1D;AACH,WAAK,iBAAiB,KAAK,yBAAyB,QAAQ;AAC5D,WAAK,iBAAiB,KAAK,yBAAyB,SAAS;;AAEjE,SAAK,oBAAoB,gBAAgB;MACrC;MACA;MACA,iBAAiB;MACjB,sBAAsB,aAAa,UAAU;KAChD;EACL;EAEO,QAAK;AACR,aAAS,MAAM,GAAG,MAAM,KAAK,SAAS,QAAQ,EAAE,KAAK;AACjD,WAAK,SAAS,GAAG,GAAG,EAAE,eAAe,GAAG,CAAC;;EAEjD;EAEA,IAAY,0BAAuB;AAC/B,WAAO,KAAK,MAAM,KAAK,SAAS,SAAS,CAAC;EAC9C;EAEA,IAAY,qCAAkC;AAC1C,WAAO,OAAO;EAClB;EAEA,IAAY,gCAA6B;AACrC,WAAO,OAAO;EAClB;EAEA,IAAY,sCAAmC;AAC3C,WAAO,OAAO;EAClB;EAEA,IAAY,0BAAuB;AAC/B,WAAO;EACX;EAEA,IAAY,0BAAuB;AAC/B,WAAO;EACX;EAEA,IAAY,sBAAmB;AAC3B,WAAO;EACX;EAEA,IAAY,oBAAiB;AACzB,WAAO;EACX;;AAGJ,IAAM,iBAAN,MAAoB;EAgBhB,YAAY,UAAmB,WAAoB,iBAA0B,sBAAsC;AAf3G,SAAA,YAAY,IAAI,QAAO;AACvB,SAAA,aAAa,IAAI,QAAO;AACxB,SAAA,mBAAmB,IAAI,QAAO;AAC9B,SAAA,QAAQ,IAAI,QAAO;AACnB,SAAA,cAAc;AACd,SAAA,WAAW,IAAI,QAAO;AACtB,SAAA,gBAAgB;AAChB,SAAA,KAAK;AACL,SAAA,QAAQ;AACR,SAAA,gBAAgB,IAAI,QAAO;AAC3B,SAAA,YAAY;AAEb,SAAA,aAAa,IAAI,WAAU;AAC3B,SAAA,aAAa,IAAI,WAAU;AAG9B,SAAK,OAAO,UAAU,WAAW,iBAAiB,yBAAyB,MAAM;EACrF;EAEQ,OAAO,UAAmB,WAAoB,iBAA0B,cAAqB;AACjG,SAAK,UAAU,SAAS,QAAQ;AAChC,SAAK,WAAW,SAAS,SAAS;AAClC,SAAK,gBAAgB;AAErB,QAAI,KAAK,eAAe;AACpB,WAAK,UAAU,cAAc,KAAK,YAAY,KAAK,KAAK;AACxD,WAAK,SAAS,eAAe,CAAC,KAAK,MAAM,GAAG,KAAK,MAAM,CAAC;WACrD;AACH,WAAK,WAAW,cAAc,KAAK,WAAW,KAAK,KAAK;AACxD,WAAK,SAAS,eAAe,KAAK,MAAM,GAAG,CAAC,KAAK,MAAM,CAAC;;AAE5D,SAAK,cAAc,KAAK,MAAM,OAAM;AACpC,SAAK,SAAS,aAAa,IAAI,KAAK,WAAW;AAE/C,SAAK,oBAAoB,gBAAgB,GAAG,gBAAgB,CAAC;AAC7D,SAAK,QAAQ,KAAK;AAClB,SAAK,cAAc,SAAS,eAAe;AAE3C,SAAK,YAAY;EACrB;EAEQ,oBAAoB,GAAW,GAAS;AAC5C,SAAK,iBAAiB,eAAe,GAAG,CAAC;AAEzC,QAAI,KAAK,eAAe;AACpB,WAAK,iBAAiB,gBAAgB,KAAK,UAAU;WAClD;AACH,WAAK,iBAAiB,gBAAgB,KAAK,SAAS;;AAExD,UAAM,SAAS,KAAK;AACpB,UAAM,MAAM,QAAQ,IAAI,KAAK,kBAAkB,KAAK,KAAK;AACzD,SAAK,KAAK,OAAO,KAAK,cAAc,KAAK;AACzC,UAAM,kBAAkB,KAAK,iBAAiB,cAAa,IAAM,MAAM,KAAK,eAAgB,MAAM,KAAK;AAGvG,SAAK,aAAa,OAAO,MAAM,KAAK,IAAI,kBAAkB,OAAQ,CAAC,IAAI,KAAK,IAAI,KAAK,KAAK,QAAQ,CAAC;EACvG;EAEO,OAAO,GAAW,GAAS;AAC9B,QAAI,KAAK,YAAY,KAAK,oBAAoB;AAC1C,aAAO;;AAGX,UAAM,SAAS,KAAK;AACpB,SAAK,oBAAoB,GAAG,CAAC;AAE7B,QAAI,KAAK,KAAK,KAAK,OAAO;AACtB,WAAK,QAAQ,KAAK;AAClB,WAAK,cAAc,eAAe,GAAG,CAAC;;AAG1C,QAAI,KAAK,YAAY,KAAK,oBAAoB;AAC1C,aAAO;;AAGX,QAAI,KAAK,KAAK,QAAQ;AAClB,WAAK,WAAW,gBAAgB,EAAE,QAAQ,KAAK,KAAK,OAAM,CAAE;AAE5D,UAAI,SAAS,OAAO,KAAK,MAAM,KAAK;AAChC,aAAK,WAAW,gBAAgB,EAAE,MAAM,KAAK,gBAAgB,SAAS,QAAO,CAAE;;;AAIvF,QAAI,KAAK,KAAK,OAAO,KAAK,OAAO;AAC7B,WAAK,iBAAiB,eAAe,GAAG,CAAC;AACzC,UAAI,KAAK,eAAe;AACpB,aAAK,UAAU,SAAS,KAAK,aAAa;aACvC;AACH,aAAK,WAAW,SAAS,KAAK,aAAa;;AAE/C,WAAK,OAAO,KAAK,WAAW,KAAK,YAAY,KAAK,kBAAkB,CAAC,KAAK,aAAa;;AAG3F,QAAI,KAAK,cAAc,MAAM;AACzB,aAAO;;AAGX,WAAO;EACX;EAEA,IAAY,qBAAkB;AAC1B,WAAO;EACX;EAEA,IAAI,UAAO;AACP,WAAO,KAAK;EAChB;;AAGJ,IAAM,SAAN,MAAM,QAAM;EAOA,WAAW,yBAAsB;AAErC,WAAO,MAAO;EAClB;EAIA,YAAY,QAAc;AAZlB,SAAA,YAAY,IAAI,kBAAiB;AACjC,SAAA,UAAoC;AACpC,SAAA,YAAY,IAAI,QAAO;AACvB,SAAA,+BAAuC,QAAO;AAO/C,SAAA,oBAA6B,QAAQ,KAAI;AAG5C,SAAK,UAAU;AACf,SAAK,UAAU,oBAAoB,IAAI,CAAC,UAAS;AAC7C,UAAI,CAAC,KAAK,SAAS;AACf,aAAK,UAAU,IAAI,eAAe,MAAM,UAAU,MAAM,WAAW,MAAM,iBAAiB,MAAM,oBAAoB;AACpH,aAAK,QAAQ,WAAW,IAAI,MAAK;AAC7B,iBAAO,IAAI,WAAW;QAC1B,CAAC;AACD,aAAK,QAAQ,WAAW,IAAI,CAACC,WAAS;AAClC,eAAK,QAAS,QAAQ,iBAAiB,QAAQA,OAAM,QAAQ,KAAK,SAAS;QAC/E,CAAC;;IAET,CAAC;EACL;EAEO,OAAO,UAAmB,SAAgB;AAC7C,YAAQ,IAAI;AACZ,YAAQ,UAAS;AAGjB,SAAK,gCAAgC,KAAK,QAAQ,aAAY;AAC9D,QAAI,KAAK,gCAAgC,QAAO,wBAAwB;AACpE,WAAK,gCAAgC,QAAO;AAC5C,WAAK,UAAU,OAAO,SAAS,GAAG,SAAS,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAClE,UAAI,KAAK,SAAS;AACd,cAAM,UAAU,KAAK,QAAQ,OAAO,SAAS,GAAG,SAAS,CAAC;AAC1D,YAAI,CAAC,SAAS;AACV,eAAK,UAAU;;;AAGvB,WAAK,UAAU,aAAa,IAAI;;AAGpC,SAAK,kBAAkB,IAAI,KAAK,UAAU,GAAG,GAAG,KAAK,UAAU,CAAC;EACpE;;AAmBE,IAAO,yBAAP,cAAsC,qBAAoB;;;;EAIrD,WAAW,OAAI;AAClB,WAAO,iBAAiB;EAC5B;;;;;;EAOO,WAAW,UAAO;AACrB,WAAO;EACX;;;;;;;;;EAoBA,IAAW,mBAAgB;AACvB,WAAO,KAAK;EAChB;;;;;;;;;EAUA,IAAW,iBAAiB,kBAA6C;AACrE,SAAK,oBAAoB;AACzB,SAAK,iCAAiC,KAAK,kBAAkB,aAAY,MAAO;EACpF;;;;;;EAOA,YAAmB,gBAAqC,SAAuC;AAC3F,UAAM,cAAc;AAxChB,SAAA,MAAe,IAAI,QAAO;AAC1B,SAAA,WAAoB,IAAI,QAAO;AAC/B,SAAA,YAAqB,IAAI,QAAO;AAChC,SAAA,YAAqB,IAAI,QAAO;AAsCpC,SAAK,kBAAkB;AACvB,SAAK,mBAAmB,QAAQ;AAChC,QAAI,KAAK,gCAAgC;AACrC,aAAO,KACH,8JAA8J;;EAG1K;;;;;;EAOO,eAAY;AACf,WAAO,KAAK,gBAAgB,gBAAgB,UAAa,KAAK,gBAAgB,gBAAgB;EAClG;;;;;;EAOO,SAAM;AACT,QAAI,CAAC,KAAK,gBAAgB,CAAC,MAAM,OAAM,GAAI;AACvC,aAAO;;AAGX,SAAK,UAAU,IAAI,OAAO,KAAK,gBAAgB,MAAM,UAAS,CAAE;AAChE,WAAO;EACX;;;;;;EAOO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,SAAK,UAAU;AACf,WAAO;EACX;EAEU,WAAW,OAAc;AAC/B,UAAM,OAAO,MAAM,cAAc,KAAK,gBAAgB,kBAAkB;AACxE,QAAI,CAAC,MAAM;AACP;;AAGJ,UAAM,mBAAmB,KAAK,iBAAiB,SAAQ,EAAG,uBAAuB,IAAI;AAErF,UAAM,IAAI,KAAK,UAAU;AACzB,SAAK,IAAI,eAAe,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB,EAAE,CAAC,CAAC;AAC3D,SAAK,SAAS,eAAe,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB,EAAE,EAAE,CAAC;AACjE,SAAK,UAAU,eAAe,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,mBAAmB,EAAE,EAAE,CAAC;AAGpE,SAAK,SAAS,iBAAiB,MAAM,KAAK,SAAS;AACnD,SAAK,IAAI,iBAAiB,OAAO,KAAK,SAAS;AAC/C,SAAK,QAAS,OAAO,KAAK,WAAW,KAAK,QAAQ;AAClD,SAAK,UAAU,SAAS,KAAK,QAAS,iBAAiB;AACvD,QAAI,CAAC,KAAK,gCAAgC;AACtC,cAAQ,qBAAqB,KAAK,WAAW,KAAK,iBAAiB,eAAc,GAAI,KAAK,SAAS;;AAEvG,SAAK,iBAAiB,SAAS,WAAW,KAAK,SAAS;EAC5D;;AAIJ,qBAAqB,gBACjB,uBAAuB,MACvB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,uBAAuB,kBAAkB,OAAO;AACrE,GACA,uBAAuB,SACvB,KAAK;;;ACndH,IAAO,+BAAP,cAA4C,kBAAiB;EAC/D,YACW,UACA,WACS,OACA,WACA,aACT,mBACA,2BAAsD,MAAI;AAEjE,UAAM,UAAU,WAAW,OAAO,WAAW,iBAAiB;AARvD,SAAA,WAAA;AACA,SAAA,YAAA;AACS,SAAA,QAAA;AACA,SAAA,YAAA;AACA,SAAA,cAAA;AACT,SAAA,oBAAA;AACA,SAAA,2BAAA;EAGX;;AAOE,IAAO,mDAAP,cAAgE,sCAAqC;EAQvG,YACuB,mBACA,iBACH,cAA0C;AAE1D,UAAM,kBAAkB,OAAO,YAAY;AAJxB,SAAA,oBAAA;AACA,SAAA,kBAAA;AACH,SAAA,eAAA;AAVV,SAAA,iBAAiB,oBAAI,IAAG;AAK3B,SAAA,yCAAyC,IAAI,WAAU;AAQ1D,SAAK,oBAAoB,aAAa;EAC1C;EAEU,4BAA4B,UAA2B,MAAa,QAAM;AAChF,UAAM,eAAe,KAAK,eAAe,IAAI,GAAG;AAChD,UAAM,WAAW,OAAO,UAAU,IAAI;AAEtC,UAAM,oBAAoB,SAAS,qBAAqB,SAAS;AACjE,UAAM,qBAAqB,SAAS,sBAAsB,SAAS;AAEnE,QAAI,CAAC,KAAK,sBAAsB,QAAQ,MAAK,6CAAc,kBAAiB,sBAAqB,6CAAc,mBAAkB,oBAAoB;AACjJ,UAAI;AACJ,YAAM,2BAA2B,SAAS,4BAA4B;AACtE,YAAM,4BAA4B,SAAS,6BAA6B;AACxE,UAAI,sBAAsB,4BAA4B,uBAAuB,2BAA2B;AACpG,8BAAsB,SAAS;;AAGnC,WAAK,sBAAsB,QAAQ,IAAI,KAAK,2BACxC,mBACA,oBACA,MACA,SAAS,cACT,qBACA,KAAK,aAAa,WAAW;AAGjC,WAAK,yBAAyB;QAC1B,kBAAkB;QAClB,mBAAmB;;AAEvB,WAAK,uCAAuC,gBAAgB,EAAE,SAAS,KAAK,sBAAsB,QAAQ,GAAG,IAAG,CAAE;;AAGtH,SAAK,eAAe,IAAI,KAAK,QAAQ;AACrC,WAAO,KAAK,sBAAsB,QAAQ;EAC9C;EACQ,mBAAmB,KAAW;AAClC,UAAM,eAAe,KAAK,kBAAkB;AAC5C,QAAI,cAAc;AACd,aAAO,KAAK,gBAAgB,YAAY,KAAK,mBAAmB,cAAc,GAAG;;AAErF,WAAO;EACX;EACO,6BAA6B,KAAW;AAC3C,UAAM,WAAW,KAAK,mBAAmB,GAAG;AAC5C,QAAI,UAAU;AACV,aAAO,KAAK,4BAA4B,UAAU,GAAG;;AAEzD,WAAO;EACX;EACO,8BAA8B,MAAa;AAC9C,WAAO,KAAK,6BAA6B,6BAAM,GAAG;EACtD;EAEU,wBAAwB,UAAoB,UAAyB;AAC3E,UAAM,eAAe,SAAS,qBAAqB,SAAS;AAC5D,UAAM,gBAAgB,SAAS,sBAAsB,SAAS;AAC9D,UAAM,aAAa,SAAS;AAC5B,aAAS,IAAI,WAAW,IAAI;AAC5B,aAAS,IAAI,WAAW,IAAI;AAC5B,aAAS,QAAQ,WAAW,QAAQ;AACpC,aAAS,SAAS,WAAW,SAAS;EAC1C;EAEO,sBAAsB,UAAoB,MAAY;AACzD,UAAM,WAAW,KAAK,eAAe,IAAI,KAAK,GAAG,KAAK,KAAK,mBAAmB,KAAK,GAAG;AACtF,QAAI,UAAU;AACV,WAAK,wBAAwB,UAAU,QAAQ;AAC/C,aAAO;;AAEX,WAAO;EACX;;;;AC5GE,IAAO,8BAAP,cAA2C,6BAA4B;EACzE,YACoB,OAChB,aACA,aAA2B;AAE3B,UACI,MAAM,MAAM,cACZ,MAAM,MAAM,eACZ,OACA,qBACA,aACA,CAAC,mBAAmB,IAAI,gDAAgD,gBAAgB,aAAa,IAAI,CAAC;AAV9F,SAAA,QAAA;EAYpB;;AAOJ,IAAM,kDAAN,cAA8D,iDAAgD;EAG1G,YACI,mBACA,iBACgB,cAAyC;AAEzD,UAAM,mBAAmB,iBAAiB,YAAY;AAFtC,SAAA,eAAA;AAGhB,SAAK,mBAAmB,aAAa;EACzC;EAEQ,oBAAoB,MAAY;AACpC,WAAO,KAAK,gBAAgB,gBAAgB,KAAK,kBAAkB,IAAI;EAC3E;EAEO,8BAA8B,MAAY;AAC7C,WAAO,KAAK,4BAA4B,KAAK,oBAAoB,IAAI,GAAG,KAAK,GAAG;EACpF;EAEO,6BAA6B,KAAU;AAC1C,UAAM,eAAe,KAAK,eAAe,IAAI,GAAG;AAChD,QAAI,cAAc;AACd,aAAO,KAAK,4BAA4B,cAAc,GAAG;;AAE7D,WAAO;EACX;EAEO,sBAAsB,UAAoB,MAAY;AACzD,UAAM,WAAW,KAAK,eAAe,IAAI,KAAK,GAAG,KAAK,KAAK,oBAAoB,IAAI;AACnF,QAAI,UAAU;AACV,WAAK,wBAAwB,UAAU,QAAQ;AAC/C,aAAO;;AAEX,WAAO;EACX;;AAGG,IAAM,+BAAsD;EAC/D,aAAa;EACb,aAAa;EACb,aAAa;EACb,aAAa;EACb,eAAe;;;;AC9DnB,IAAM,0BAA4C,CAAA;AAqB5C,IAAO,cAAP,cAA2B,qBAAoB;EAwBjD,YACI,mBACiB,WAAgC,CAAA,GAAE;AAEnD,UAAM,iBAAiB;AAFN,SAAA,WAAA;AAZb,SAAA,kBAAuC,CAAA;AAIvC,SAAA,sBAAsB;AACtB,SAAA,8BAA8B;AAE9B,SAAA,kCAA4E,oBAAI,QAAO;AACvF,SAAA,6BAA4G,oBAAI,QAAO;AAO3H,SAAK,sBAAsB;EAC/B;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,UAAM,SAAS,KAAK,kBAAkB,MAAM,UAAS;AACrD,SAAK,aAAa,OAAO;AACzB,SAAK,kBAAkB,IAAI,eAAe,KAAK,kBAAkB,SAAS,KAAK,UAAU;AACzF,SAAK,gBAAgB,SAAS;AAE9B,UAAM,sBAAsB,EAAE,GAAG,8BAA8B,GAAG,KAAK,SAAS,oBAAmB;AACnG,SAAK,sBAAsB,KAAK,SAAS,yBAAyB,OAAO,QAAO,EAAG;AACnF,SAAK;MAAsB;;IAAkD;AAC7E,SAAK,8BAA8B;AAEnC,WAAO;EACX;EAEO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAEX,SAAK,gBAAgB,QAAQ,CAAC,UAAS;AACnC,YAAM,QAAO;IACjB,CAAC;AACD,SAAK,gBAAgB,SAAS;AAC9B,SAAK,8BAA8B;AACnC,WAAO;EACX;;;;;;EAOO,mBAAmB,SAAS,yBAAuB;AACtD,UAAM,QAAQ,IAAI,aAAa,KAAK,kBAAkB,SAAS,KAAK,YAAY,MAAM;AACtF,WAAO,IAAI,uBAAuB,KAAK;EAC3C;EAEQ,mBAAmB,QAAiD,YAAY,KAAK,qBAAmB;AAE5G,QAAI,CAAC,KAAK,kBAAkB,aAAa;AACrC,YAAM,IAAI,MAAM,6GAA6G;;AAEjI,QAAI,aAAa,OAAO,gBAAgB,iBAAiB;AACrD,YAAM,IAAI,MAAM,4HAA4H;;AAIhJ,QAAI,CAAC,aAAa,OAAO,gBAAgB,iBAAiB;AACtD,YAAM,IAAI,MAAM,yGAAyG;;EAEjI;EAEQ,mBAAmB,QAAiD,YAAY,KAAK,qBAAmB;AAC5G,QAAI,WAAW;AACX,aAAO,cAAc;;AAEzB,WAAO;EACX;;;;;;;EAQO,sBAAsB,SAAS,8BAA8B,YAAY,KAAK,qBAAmB;AACpG,SAAK,mBAAmB,QAAQ,SAAS;AACzC,SAAK,mBAAmB,QAAQ,SAAS;AAEzC,UAAM,YAAY,KAAK,gBAAgB,sBAAsB,MAAM;AACnE,UAAM,QAAQ,IAAI,4BAA4B,WAAW,WAAW,KAAK,eAAe;AACxF,SAAK,kBAAkB,KAAK;AAC5B,WAAO;EACX;;;;;;;EAQQ,iBAAiB,UAAgD,EAAE,QAAQ,CAAA,EAAE,GAAI,gBAA4B;AACjH,SAAK,mBAAmB,QAAQ,QAAQ,KAAK;AAC7C,UAAM,QAAS,KAAK,gBAAgB,CAAC,EAAE,MAA4B;AACnE,UAAM,SAAU,KAAK,gBAAgB,CAAC,EAAE,MAA4B;AACpE,UAAM,kBAAmC;MACrC,OAAO,KAAK,kBAAkB;MAC9B,gBAAgB;MAChB,iBAAiB;MACjB,eAAe;MACf,GAAG,QAAQ;;AAEf,SAAK,mBAAmB,iBAAiB,KAAK;AAC9C,UAAM,YAAY,KAAK,gBAAgB,gBAAgB,eAAe;AAEtE,cAAU,QAAQ,KAAK,sBAAsB,IAAI;AACjD,cAAU,SAAS;AAEnB,UAAM,UAAwC,IAAI,6BAC9C,MAAM,UAAU,OAChB,MAAM,UAAU,QAChB,WACA,eACA,OACA,CAAC,mBAAmB,IAAI,iDAAiD,gBAAgB,KAAK,iBAAiB,OAAO,CAAC;AAG3H,QAAI,gBAAgB;AAChB,WAAK,gCAAgC,IAAI,WAAW,cAAc;;AAEtE,UAAM,MAAM,QAAQ,kCAAkC,KAAK,iBAAiB;AAC5E,SAAK,2BAA2B,IAAI,WAAW,GAAG;AAClD,SAAK,kBAAkB,OAAO;AAC9B,WAAO;EACX;;;;;;;;;EAUO,oCAAoC,SAAyB,UAA2C,EAAE,qBAAqB,IAAG,GAAE;AACvI,UAAM,UAAU,KAAK,iBACjB;MACI,QAAQ;QACJ,OAAO,KAAK,kBAAkB;QAC9B,aAAa;QACb,QAAQ;;OAGhB,OAAO;AAGX,UAAM,QAAQ,QAAQ;AACtB,UAAM,WAAW,KAAK,IAAI,KAAK,QAAQ,mBAAmB;AAC1D,UAAM,MAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,SAAQ;AACtC,UAAM,SAAS,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;AACvC,UAAM,YAAY,IAAI,iBAAiB,KAAK,MAAM;AAElD,UAAM,cAAc,KAAK,2BAA2B,IAAI,KAAK;AAC7D,QAAI,CAAC,aAAa;AACd,YAAM,IAAI,MAAM,+CAA+C;;AAEnE,UAAM,eAAe,KAAK,kBAAkB,MAAM,OAAO,KAAK,CAACC,kBAAgB;AAC3E,aAAOA,cAAa,YAAY;IACpC,CAAC;AACD,QAAI,CAAC,cAAc;AACf,YAAM,IAAI,MAAM,kDAAkD;;AAEtE,gBAAY,uCAAuC,IAAI,CAAC,SAAQ;AAC5D,UAAI,KAAK,OAAO,KAAK,QAAQ,SAAS;AAClC;;AAEJ,WAAK,QAAQ,aAAa,IAAI,OAAO,GAAG,GAAG,GAAG,CAAC;AAC/C,mBAAa,qBAAqB,KAAK,KAAK,OAAO;AACnD,mBAAa,mCAAmC;AAEhD,WAAK,kBAAkB,MAAM,yBAAyB,IAAI,MAAK;AAC3D,aAAK,QAAQ,OAAM;MACvB,CAAC;AACD,mBAAa,qBAAqB,KAAK,KAAK,OAAO;AACnD,mBAAa,mCAAmC;AAEhD,WAAK,kBAAkB,iBAAiB,QAAQ,MAAK;AACjD,qBAAa,qBAAqB,OAAO,aAAa,qBAAqB,QAAQ,KAAK,OAAO,GAAG,CAAC;AACnG,qBAAa,mCAAmC;MACpD,CAAC;IACL,CAAC;AACD,WAAO;EACX;;;;;;;;;EAUU,oBAAoB,aAA4B;AACtD,UAAM,UAAU,KAAK,iBAAiB;MAClC,QAAQ;QACJ,OAAO,KAAK,kBAAkB;QAC9B,aAAa;QACb,QAAQ;;KAEf;AAED,UAAM,QAAQ,QAAQ;AACtB,UAAM,QAAQ;AACd,UAAM,SAAS;AACf,UAAM,WAAW;AACjB,UAAM,MAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,SAAQ;AACtC,UAAM,SAAS,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;AACvC,UAAM,YAAY,IAAI,iBAAiB,KAAK,MAAM;AAGlD,UAAM,cAAc,KAAK,2BAA2B,IAAI,KAAK;AAC7D,QAAI,CAAC,aAAa;AACd,YAAM,IAAI,MAAM,+CAA+C;;AAGnE,gBAAY,uCAAuC,IAAI,CAAC,SAAQ;AAC5D,WAAK,QAAQ,aAAa,IAAI,OAAO,GAAG,GAAG,GAAG,CAAC;AAC/C,WAAK,QAAQ,uBAAuB,MAAK;AACrC,oBAAY,OAAM;MACtB;IAMJ,CAAC;AAED,SAAK,kBAAkB,gBAAgB,IAAI,MAAK;AAC5C,WAAK,kBAAkB,MAAM,iBAAiB,OAAO,KAAK,kBAAkB,MAAM,iBAAiB,QAAQ,WAAW,GAAG,CAAC;IAC9H,CAAC;AAED,SAAK,kBAAkB,iBAAiB,IAAI,MAAK;AAC7C,WAAK,kBAAkB,MAAM,iBAAiB,KAAK,WAAW;IAClE,CAAC;AAED,WAAO;EACX;;;;;EAMO,kBAAkB,cAA+B;AACpD,SAAK,gBAAgB,KAAK,YAAY;AACtC,SAAK,mBAAmB,KAAK,eAAe;EAChD;;;;;;;;;;EAWO,mBAAmB,gBAA0C,KAAK,iBAAe;AAEpF,UAAM,kBAAqC,EAAE,GAAG,KAAK,kBAAkB,QAAQ,YAAW;AAE1F,oBAAgB,YAAY;AAC5B,oBAAgB,SAAS,cAAc,IAAI,CAAC,iBAAiB,aAAa,KAAK;AAC/E,SAAK,kBAAkB,kBAAkB,eAAe;AACxD,QAAI,CAAC,KAAK,6BAA6B;AACnC,WAAK,kBAAkB,qBAAqB,cAAc,SAAS,IAAI,cAAc,GAAG,CAAC,IAAK,IAAI;;EAE1G;EAEO,eAAY;AAEf,WAAO,CAAC,KAAK,kBAAkB,YAAY,OAAO,mBAAmB,eAAe,CAAC,CAAC,eAAe,UAAU;EACnH;;;;EAKO,UAAO;AACV,UAAM,QAAO;EACjB;EAEU,WAAW,UAAiB;AAElC,UAAM,SAAS,KAAK;AACpB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACpC,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,MAAM,cAAc,qBAAqB;AAEzC,cAAM,cAAc,KAAK,2BAA2B,IAAI,MAAM,KAA2B;AACzF,YAAI,CAAC,aAAa;AACd;;AAGJ,YAAI,YAAY,aAAa,aAAa;AAEtC,gBAAM,OAAO,SAAS,cAAc,KAAK,kBAAkB,cAAc;AACzE,cAAI,MAAM;AACN,kBAAM,QAAQ,KAAK;AACnB,qBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACnC,oBAAM,OAAO,MAAM,CAAC;AACpB,0BAAY,8BAA8B,IAAI;;;eAGnD;AACH,sBAAY,8BAA6B;;;;EAIzD;;AA9UuB,YAAA,OAAO,iBAAiB;AAMxB,YAAA,UAAU;AA4UrC,qBAAqB,gBACjB,YAAY,MACZ,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,YAAY,kBAAkB,OAAO;AAC1D,GACA,YAAY,SACZ,KAAK;;;AC3FT,WAAW,UAAU,mBAAmB,SACpC,SACA,MACA,QACA,SACA,cAAgC,MAChC,OAAe,GAAA,gBAAU,OAAA;AAGzB,MAAI,CAAC,SAAS;AACV;;AAGJ,QAAM,qBAAqB,KAAK,kCAAkC,MAAM,QAAQ,aAAa;AAG7F,QAAM,iBAAiB,KAAK,mBAAmB,MAAM;AACrD,QAAM,cAAc,KAAK,qBAAqB,IAAI;AAClD,OAAK,qBAAqB,KAAK,IAAI,YAAY,SAAS,IAAI;AAC5D,OAAK,aAAa,YAAY,SAAY,OAAO,UAAU,OAAO,KAAK;AAEvE,MAAI,CAAC,KAAK,yBAAyB;AAC/B,YAAQ,cAAc;AACtB,YAAQ,SAAS;AACjB,YAAQ,OAAO;AACf,YAAQ,UAAU;AAClB,YAAQ,eAAe;;AAG3B,MAAI,QAAQ,QAAQ,MAAM,GAAG;AACzB,SAAK,IAAI,YAAY,KAAK,IAAI,kBAAkB,CAAC;;AAGrD,MAAI,eAAe,MAAM;AACrB,SAAK,IAAI,qBAAqB,KAAK,IAAI,YAAY,GAAS,KAAK,QAAO,EAAG,KAAM,WAAW,GAAG,QAAQ,OAAO,QAAQ,QAAQ,GAAa,IAAI;SAC5I;AACH,SAAK,IAAI,WAAW,KAAK,IAAI,YAAY,GAAG,oBAAoB,QAAQ,OAAO,QAAQ,QAAQ,GAAG,gBAAgB,aAAa,IAAI;;AAGvI,MAAI,QAAQ,iBAAiB;AACzB,SAAK,IAAI,eAAe,KAAK,IAAI,UAAU;;AAE/C,OAAK,qBAAqB,KAAK,IAAI,YAAY,IAAI;AAEnD,UAAQ,UAAU;AACtB;AAEA,WAAW,UAAU,mBAAmB,SACpC,MACA,OACA,QACA,QACA,iBACA,SACA,cACA,cAAgC,MAChC,OAAe,GAEf,gBAAgB,GAChB,gBAAgB,OAAK;AAErB,QAAM,UAAU,IAAI,gBAAgB,MAAM,sBAAsB,GAAG;AACnE,UAAQ,YAAY;AACpB,UAAQ,aAAa;AACrB,UAAQ,QAAQ;AAChB,UAAQ,SAAS;AACjB,UAAQ,SAAS;AACjB,UAAQ,kBAAkB;AAC1B,UAAQ,eAAe;AACvB,UAAQ,UAAU;AAClB,UAAQ,eAAe;AACvB,UAAQ,OAAO;AACf,UAAQ,iBAAiB,KAAK,kBAAkB,eAAe,CAAC,eAAe;AAE/E,MAAI,CAAC,KAAK,yBAAyB;AAC/B,YAAQ,cAAc;;AAG1B,OAAK,iBAAiB,SAAS,MAAM,QAAQ,SAAS,aAAa,MAAM,QAAQ,cAAc;AAC/F,OAAK,qBAAqB,KAAK,IAAI,YAAY,SAAS,IAAI;AAG5D,QAAM,UAAU,KAAK,uBAAuB,cAAc,eAAe;AAEzE,OAAK,IAAI,cAAc,KAAK,IAAI,YAAY,KAAK,IAAI,oBAAoB,QAAQ,GAAG;AACpF,OAAK,IAAI,cAAc,KAAK,IAAI,YAAY,KAAK,IAAI,oBAAoB,QAAQ,GAAG;AAEpF,MAAI,iBAAiB;AACjB,SAAK,IAAI,eAAe,KAAK,IAAI,UAAU;;AAG/C,OAAK,qBAAqB,KAAK,IAAI,YAAY,IAAI;AAEnD,OAAK,uBAAuB,KAAK,OAAO;AAExC,SAAO;AACX;AAEA,WAAW,UAAU,uBAAuB,SACxC,MACA,MACA,QACA,MACA,iBACA,SACA,cACA,cAAgC,MAAI;AAEpC,QAAM,KAAK,KAAK;AAChB,QAAM,UAAU,IAAI,gBAAgB,MAAM,sBAAsB,OAAO;AACvE,UAAQ,SAAS;AACjB,UAAQ,SAAS;AACjB,UAAQ,OAAO;AACf,MAAI,CAAC,KAAK,yBAAyB;AAC/B,YAAQ,mBAAmB;;AAG/B,QAAM,cAAc,KAAK,qBAAqB,IAAI;AAClD,MAAI,iBAAiB,KAAK,mBAAmB,MAAM;AAEnD,MAAI,mBAAmB,GAAG,KAAK;AAC3B,qBAAiB,GAAG;;AAIxB,MAAI,gBAAgB,GAAG,SAAS,CAAC,KAAK,MAAM,6BAA6B;AACrE,sBAAkB;AAClB,mBAAe;AACf,WAAO,KAAK,mJAAmJ;aACxJ,gBAAgB,KAAK,IAAI,kBAAkB,CAAC,KAAK,MAAM,iCAAiC;AAC/F,sBAAkB;AAClB,mBAAe;AACf,WAAO,KAAK,wJAAwJ;aAC7J,gBAAgB,GAAG,SAAS,CAAC,KAAK,MAAM,oBAAoB;AACnE,sBAAkB;AAClB,WAAO,KAAK,+EAA+E;aACpF,gBAAgB,GAAG,cAAc,CAAC,KAAK,MAAM,kBAAkB;AACtE,sBAAkB;AAClB,WAAO,KAAK,oFAAoF;;AAGpG,QAAM,QAAQ;AACd,QAAM,SAAS;AAEf,UAAQ,QAAQ;AAChB,UAAQ,SAAS;AACjB,UAAQ,UAAU;AAClB,UAAQ,eAAe;AAGvB,QAAM,QAAQ,CAAC,KAAK,mBAAoB,MAAM,gBAAgB,QAAQ,KAAK,KAAK,MAAM,gBAAgB,QAAQ,MAAM;AACpH,MAAI,CAAC,OAAO;AACR,sBAAkB;;AAItB,MAAI,MAAM;AACN,SAAK,qBAAqB,SAAS,MAAM,QAAQ,MAAM,SAAS,WAAW;SACxE;AACH,UAAM,qBAAqB,KAAK,kCAAkC,IAAI;AACtE,UAAM,QAAQ;AAEd,SAAK,qBAAqB,GAAG,kBAAkB,SAAS,IAAI;AAE5D,aAAS,YAAY,GAAG,YAAY,GAAG,aAAa;AAChD,UAAI,aAAa;AACb,WAAG,qBACC,GAAG,8BAA8B,WACjC,OACM,KAAK,QAAO,EAAG,KAAM,WAAW,GACtC,QAAQ,OACR,QAAQ,QACR,GACA,MAAgB;aAEjB;AACH,WAAG,WAAW,GAAG,8BAA8B,WAAW,OAAO,oBAAoB,QAAQ,OAAO,QAAQ,QAAQ,GAAG,gBAAgB,aAAa,IAAI;;;AAIhK,SAAK,qBAAqB,KAAK,IAAI,kBAAkB,IAAI;;AAG7D,OAAK,qBAAqB,KAAK,IAAI,kBAAkB,SAAS,IAAI;AAGlE,MAAI,QAAQ,iBAAiB;AACzB,SAAK,IAAI,eAAe,KAAK,IAAI,gBAAgB;;AAGrD,QAAM,UAAU,KAAK,uBAAuB,cAAc,eAAe;AACzE,KAAG,cAAc,GAAG,kBAAkB,GAAG,oBAAoB,QAAQ,GAAG;AACxE,KAAG,cAAc,GAAG,kBAAkB,GAAG,oBAAoB,QAAQ,GAAG;AAExE,KAAG,cAAc,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,aAAa;AACzE,KAAG,cAAc,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,aAAa;AACzE,OAAK,qBAAqB,GAAG,kBAAkB,IAAI;AAEnD,UAAQ,kBAAkB;AAC1B,UAAQ,eAAe;AACvB,UAAQ,UAAU;AAElB,SAAO;AACX;AAEA,WAAW,UAAU,uBAAuB,SACxC,SACA,MACA,QACA,MACA,SACA,cAAgC,MAChC,QAAgB,GAAC;AAEjB,UAAQ,mBAAmB;AAC3B,UAAQ,SAAS;AACjB,UAAQ,OAAO;AACf,UAAQ,UAAU;AAClB,UAAQ,eAAe;AAEvB,QAAM,KAAK,KAAK;AAChB,QAAM,cAAc,KAAK,qBAAqB,IAAI;AAClD,MAAI,iBAAiB,KAAK,mBAAmB,MAAM;AACnD,QAAM,qBAAqB,KAAK,kCAAkC,IAAI;AAEtE,MAAI,iBAAiB;AACrB,MAAI,mBAAmB,GAAG,KAAK;AAC3B,qBAAiB,GAAG;AACpB,qBAAiB;;AAGrB,OAAK,qBAAqB,GAAG,kBAAkB,SAAS,IAAI;AAC5D,OAAK,aAAa,YAAY,SAAY,OAAO,UAAU,OAAO,KAAK;AAEvE,MAAI,QAAQ,QAAQ,MAAM,GAAG;AACzB,OAAG,YAAY,GAAG,kBAAkB,CAAC;;AAIzC,WAAS,YAAY,GAAG,YAAY,GAAG,aAAa;AAChD,QAAI,WAAW,KAAK,SAAS;AAE7B,QAAI,aAAa;AACb,SAAG,qBACC,GAAG,8BAA8B,WACjC,OACM,KAAK,QAAO,EAAG,KAAM,WAAW,GACtC,QAAQ,OACR,QAAQ,QACR,GACU,QAAQ;WAEnB;AACH,UAAI,gBAAgB;AAChB,mBAAW,6BAA6B,UAAU,QAAQ,OAAO,QAAQ,QAAQ,IAAI;;AAEzF,SAAG,WAAW,GAAG,8BAA8B,WAAW,OAAO,oBAAoB,QAAQ,OAAO,QAAQ,QAAQ,GAAG,gBAAgB,aAAa,QAAQ;;;AAIpK,QAAM,QAAQ,CAAC,KAAK,mBAAoB,MAAM,gBAAgB,QAAQ,KAAK,KAAK,MAAM,gBAAgB,QAAQ,MAAM;AACpH,MAAI,SAAS,QAAQ,mBAAmB,UAAU,GAAG;AACjD,SAAK,IAAI,eAAe,KAAK,IAAI,gBAAgB;;AAErD,OAAK,qBAAqB,KAAK,IAAI,kBAAkB,IAAI;AAGzD,UAAQ,UAAU;AACtB;AAEA,WAAW,UAAU,8BAA8B,SAC/C,KACA,OACA,MACA,QACA,MACA,UACA,UACA,iBACA,SAA+B,MAC/B,UAAiE,MACjE,eAAuB,GAAA,UAAU,OAAA;AAGjC,QAAM,KAAK,KAAK;AAChB,QAAM,UAAU,KAAK,qBAAqB,MAAM,MAAM,QAAQ,MAAM,CAAC,UAAU,SAAS,cAAc,IAAI;AAC1G,iCAAO,eAAe;AACtB,UAAQ,MAAM;AACd,UAAQ,UAAU;AAClB,OAAK,uBAAuB,KAAK,OAAO;AAExC,QAAM,UAAU,CAAC,SAAuB,cAAmB;AACvD,mCAAO,kBAAkB;AACzB,QAAI,WAAW,SAAS;AACpB,cAAQ,QAAQ,SAAS,MAAM,QAAQ,YAAY,SAAS;;EAEpE;AAEA,QAAM,mBAAmB,CAAC,SAAa;AACnC,UAAM,QAAQ,QAAQ;AACtB,UAAM,iBAAiB,SAAS,IAAI;AAEpC,QAAI,CAAC,gBAAgB;AACjB;;AAGJ,QAAI,iBAAiB;AACjB,YAAM,cAAc,KAAK,qBAAqB,IAAI;AAClD,UAAI,iBAAiB,KAAK,mBAAmB,MAAM;AACnD,YAAM,qBAAqB,KAAK,kCAAkC,IAAI;AAEtE,UAAI,iBAAiB;AACrB,UAAI,mBAAmB,GAAG,KAAK;AAC3B,yBAAiB,GAAG;AACpB,yBAAiB;;AAGrB,WAAK,qBAAqB,GAAG,kBAAkB,SAAS,IAAI;AAC5D,WAAK,aAAa,KAAK;AAEvB,YAAM,UAAU,gBAAgB,cAAc;AAC9C,eAAS,QAAQ,GAAG,QAAQ,QAAQ,QAAQ,SAAS;AACjD,cAAM,UAAU,SAAS;AAEzB,iBAAS,YAAY,GAAG,YAAY,GAAG,aAAa;AAChD,cAAI,cAAc,QAAQ,KAAK,EAAE,SAAS;AAC1C,cAAI,gBAAgB;AAChB,0BAAc,6BAA6B,aAAa,SAAS,SAAS,IAAI;;AAElF,aAAG,WAAW,WAAW,OAAO,oBAAoB,SAAS,SAAS,GAAG,gBAAgB,aAAa,WAAW;;;AAIzH,WAAK,qBAAqB,GAAG,kBAAkB,IAAI;WAChD;AACH,WAAK,qBAAqB,SAAS,gBAAgB,QAAQ,MAAM,OAAO;;AAG5E,YAAQ,UAAU;AAElB,mCAAO,kBAAkB;AAEzB,YAAQ,mBAAmB,gBAAgB,OAAO;AAClD,YAAQ,mBAAmB,MAAK;AAEhC,QAAI,QAAQ;AACR,aAAM;;EAEd;AAEA,OAAK,UACD,KACA,CAAC,SAAQ;AACL,qBAAiB,IAAI;EACzB,GACA,QACA,+BAAO,iBACP,MACA,OAAO;AAGX,SAAO;AACX;AAMA,SAAS,6BAA6B,SAAc,OAAe,QAAgB,aAAmB;AAElG,MAAI;AACJ,MAAI,OAAO;AACX,MAAI,gBAAgB,GAAA;AAChB,eAAW,IAAI,aAAa,QAAQ,SAAS,CAAC;aACvC,gBAAgB,GAAA;AACvB,eAAW,IAAI,YAAY,QAAQ,SAAS,CAAC;AAC7C,WAAO;aACA,gBAAgB,GAAA;AACvB,eAAW,IAAI,YAAY,QAAQ,SAAS,CAAC;SAC1C;AACH,eAAW,IAAI,WAAW,QAAQ,SAAS,CAAC;;AAIhD,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC7B,YAAM,SAAS,IAAI,QAAQ,KAAK;AAChC,YAAM,YAAY,IAAI,QAAQ,KAAK;AAGnC,eAAS,WAAW,CAAC,IAAI,QAAQ,QAAQ,CAAC;AAC1C,eAAS,WAAW,CAAC,IAAI,QAAQ,QAAQ,CAAC;AAC1C,eAAS,WAAW,CAAC,IAAI,QAAQ,QAAQ,CAAC;AAG1C,eAAS,WAAW,CAAC,IAAI;;;AAIjC,SAAO;AACX;AAQA,SAAS,8BAA8B,MAAa;AAChD,SAAO,SAEH,MACA,OACA,QACA,OACA,QACA,iBACA,SACA,cACA,cAAgC,MAChC,cAAsB,GAAA;AAEtB,UAAM,SAAS,OAAO,KAAK,IAAI,aAAa,KAAK,IAAI;AACrD,UAAM,SAAS,OAAO,sBAAsB,QAAQ,sBAAsB;AAC1E,UAAM,UAAU,IAAI,gBAAgB,MAAM,MAAM;AAChD,YAAQ,YAAY;AACpB,YAAQ,aAAa;AACrB,YAAQ,YAAY;AACpB,YAAQ,QAAQ;AAChB,YAAQ,SAAS;AACjB,YAAQ,QAAQ;AAChB,YAAQ,SAAS;AACjB,YAAQ,OAAO;AACf,YAAQ,kBAAkB;AAC1B,YAAQ,eAAe;AACvB,QAAI,MAAM;AACN,cAAQ,OAAO;WACZ;AACH,cAAQ,YAAY;;AAGxB,QAAI,CAAC,KAAK,yBAAyB;AAC/B,cAAQ,cAAc;;AAG1B,QAAI,MAAM;AACN,WAAK,mBAAmB,SAAS,MAAM,QAAQ,SAAS,aAAa,WAAW;WAC7E;AACH,WAAK,wBAAwB,SAAS,MAAM,QAAQ,SAAS,aAAa,WAAW;;AAEzF,SAAK,qBAAqB,QAAQ,SAAS,IAAI;AAG/C,UAAM,UAAU,KAAK,uBAAuB,cAAc,eAAe;AAEzE,SAAK,IAAI,cAAc,QAAQ,KAAK,IAAI,oBAAoB,QAAQ,GAAG;AACvE,SAAK,IAAI,cAAc,QAAQ,KAAK,IAAI,oBAAoB,QAAQ,GAAG;AAEvE,QAAI,iBAAiB;AACjB,WAAK,IAAI,eAAe,MAAM;;AAGlC,SAAK,qBAAqB,QAAQ,IAAI;AAEtC,SAAK,uBAAuB,KAAK,OAAO;AAExC,WAAO;EACX;AACJ;AAEA,WAAW,UAAU,0BAA0B,8BAA8B,KAAK;AAClF,WAAW,UAAU,qBAAqB,8BAA8B,IAAI;AAQ5E,SAAS,8BAA8B,MAAa;AAChD,SAAO,SAEH,SACA,MACA,QACA,SACA,cAAgC,MAChC,cAAsB,GAAA;AAEtB,UAAM,SAAS,OAAO,KAAK,IAAI,aAAa,KAAK,IAAI;AACrD,UAAM,eAAe,KAAK,qBAAqB,WAAW;AAC1D,UAAM,iBAAiB,KAAK,mBAAmB,MAAM;AACrD,UAAM,qBAAqB,KAAK,kCAAkC,aAAa,MAAM;AAErF,SAAK,qBAAqB,QAAQ,SAAS,IAAI;AAC/C,SAAK,aAAa,YAAY,SAAY,OAAO,UAAU,OAAO,KAAK;AAEvE,QAAI,CAAC,KAAK,yBAAyB;AAC/B,cAAQ,cAAc;AACtB,cAAQ,SAAS;AACjB,cAAQ,UAAU;AAClB,cAAQ,eAAe;;AAG3B,QAAI,QAAQ,QAAQ,MAAM,GAAG;AACzB,WAAK,IAAI,YAAY,KAAK,IAAI,kBAAkB,CAAC;;AAGrD,QAAI,eAAe,MAAM;AACrB,WAAK,IAAI,qBAAqB,QAAQ,GAAS,KAAK,QAAO,EAAG,KAAM,WAAW,GAAG,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,OAAO,GAAG,IAAI;WACpI;AACH,WAAK,IAAI,WAAW,QAAQ,GAAG,oBAAoB,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,OAAO,GAAG,gBAAgB,cAAc,IAAI;;AAG1I,QAAI,QAAQ,iBAAiB;AACzB,WAAK,IAAI,eAAe,MAAM;;AAElC,SAAK,qBAAqB,QAAQ,IAAI;AAEtC,YAAQ,UAAU;EACtB;AACJ;AAEA,WAAW,UAAU,0BAA0B,8BAA8B,KAAK;AAClF,WAAW,UAAU,qBAAqB,8BAA8B,IAAI;;;ACjyBtE,IAAO,aAAP,MAAO,oBAAmB,QAAO;;;;;;;;;;;;;;;;;;EAkBnC,YACI,MACA,OACA,QAIO,QACP,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA,OAAU,GAAA,eAAA,eACjC;AAIA,UAAM,MAAM,eAAe,CAAC,iBAAiB,SAAS,QAAW,QAAW,QAAW,QAAW,QAAW,QAAW,QAAW,QAAW,aAAa;AATpJ,SAAA,SAAA;AAWP,QAAI,CAAC,KAAK,SAAS;AACf;;AAGJ,QAAI,CAAC,KAAK,QAAQ,MAAM,+BAA+B,SAAS,GAAA;AAC5D,qBAAe;;AAEnB,QAAI,CAAC,KAAK,QAAQ,MAAM,mCAAmC,SAAS,GAAA;AAChE,qBAAe;;AAGnB,SAAK,WAAW,KAAK,QAAQ,iBAAiB,MAAM,OAAO,QAAQ,QAAQ,iBAAiB,SAAS,cAAc,MAAM,MAAM,iBAAiB,GAAG,iBAAiB,KAAK;AAEzK,SAAK,QAAQ,QAAQ;AACrB,SAAK,QAAQ,QAAQ;EACzB;;;;;EAMO,OAAO,MAAqB;AAC/B,SAAK,WAAU,EAAI,iBAAiB,KAAK,UAAU,MAAM,KAAK,SAAU,QAAQ,KAAK,SAAU,SAAS,MAAM,KAAK,SAAU,MAAM,KAAK,SAAU,cAAc;EACpK;;;;;;;;;;;;EAaO,OAAO,uBACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA;AAEvB,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAyB,SAAA,YAAe;EACjG;;;;;;;;;;;;EAaO,OAAO,4BACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA;AAEvB,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAA,SAA+B,YAAe;EACvG;;;;;;;;;;;;EAaO,OAAO,mBACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA;AAEvB,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAqB,SAAa,YAAE;EAC7F;;;;;;;;;;;;;;;EAgBO,OAAO,iBACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA,OAAU,GAAA,gBAAA,GAAA,gBACjC,OAAe;AAIf,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAmB,SAAe,cAAA,MAAiB,eAAS,aAAoB;EACzI;;;;;;;;;;;;;;;EAgBO,OAAO,kBACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA,OAAU,GAAA,gBAAA,GAAA,gBACjC,OAAe;AAIf,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAoB,SAAa,cAAE,MAAiB,eAAS,aAAoB;EAC1I;;;;;;;;;;;;;;EAeO,OAAO,yBACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,GAAA,OAAU,GAAA,gBAAA,OAAA;AAIjC,WAAO,IAAI,YACP,MACA,OACA,QACA,GAAA,eAAU,iBACV,SAAa,cACb,MACA,GAAA,aACA;EAKR;;;;;;;;;;;;;EAcO,OAAO,eACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,QAAQ,wBAC/B,OAAe,GAAA;AAEf,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAiB,SAAe,cAAe,IAAE;EAC1G;;;;;;;;;;;;;EAcO,OAAO,sBACV,MACA,OACA,QACA,eACA,kBAA2B,MAC3B,UAAmB,OACnB,eAAuB,QAAQ,wBAC/B,OAAe,GAAA;AAEf,WAAO,IAAI,YAAW,MAAM,OAAO,QAAQ,GAAA,eAAU,iBAAiB,SAAe,cAAe,MAAE,CAAA;EAC1G;;;;AC5PE,IAAO,oBAAP,cAAiC,qBAAoB;;;;EAYvD,IAAW,QAAK;AACZ,WAAO,KAAK;EAChB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK;EAChB;;;;EAKA,IAAW,mBAAgB;AACvB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,8BAA2B;AAClC,WAAO,KAAK;EAChB;;;;EAKA,IAAW,aAAU;AACjB,YAAQ,KAAK,kBAAkB,QAAQ,YAAY;MAC/C,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;;EAEnB;;;;EAKA,IAAW,kBAAe;AACtB,YAAQ,KAAK,kBAAkB,QAAQ,iBAAiB;MACpD,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;;EAEnB;;;;;EAMA,IAAW,wBAAqB;AAC5B,QAAI,CAAC,KAAK,qBAAqB;AAC3B,aAAO;;AAGX,UAAM,SAAS,KAAK,kBAAkB,MAAM,UAAS;AACrD,UAAM,kBAAkB,IAAI,gBAAgB,QAAQ,sBAAsB,OAAO;AACjF,oBAAgB,SAAS;AACzB,oBAAgB,UAAU;AAC1B,oBAAgB,iBAAiB;AACjC,oBAAgB,SAAS,KAAK,oBAAoB,WAAW,IAAA;AAC7D,oBAAgB,kBAAkB;AAClC,oBAAgB,OAAO,KAAK,oBAAoB,WAAW,IAAA;AAC3D,oBAAgB,eAAe;AAC/B,oBAAgB,QAAQ,KAAK,SAAS;AACtC,oBAAgB,SAAS,KAAK,UAAU;AACxC,oBAAgB,eAAe;AAC/B,oBAAgB,eAAe;AAC/B,oBAAgB,mBAAmB,IAAI,qBAAqB,KAAK,qBAAqB,OAAO,GAAG;AAEhG,WAAO;EACX;;;;EAKA,IAAW,oBAAiB;AACxB,QAAI,CAAC,KAAK,oBAAoB;AAC1B,aAAO;;AAGX,WAAO,KAAK,oBAAoB,WAAW,IAAI,YAAY,KAAK,kBAAkB,IAAI,IAAI,aAAa,KAAK,kBAAkB;EAClI;;;;EAWA,IAAW,0BAAuB;AAC9B,WAAO,KAAK;EAChB;;;;;;EAwBA,YACI,mBACgB,SAAkC;AAElD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAvIZ,SAAA,SAA2B;AAC3B,SAAA,UAA4B;AAC5B,SAAA,oBAAsC;AACtC,SAAA,+BAA2D;AAC3D,SAAA,qBAA4C;AAC5C,SAAA,sBAA8C;AAC9C,SAAA,2BAAiD;AAgGlD,SAAA,8BAAgE,IAAI,WAAU;AAoCjF,SAAK,sBAAsB;AAG3B,UAAM,KAAK,wDAAwD;EACvE;;;;;;;EAQO,OAAO,OAA2B;AACrC,QAAI,CAAC,MAAM,OAAO,KAAK,GAAG;AACtB,aAAO;;AAGX,UAAM,gCAAgC,KAAK,kBAAkB,QAAQ,mBAAmB,QAAQ,KAAK,kBAAkB,QAAQ,cAAc;AAC7I,QAAI,+BAA+B;AAC/B,aAAO;;AAGX,SAAK,aAAa,IAAI,eAAe,KAAK,kBAAkB,SAAS,KAAK,kBAAkB,MAAM,UAAS,EAAG,GAAG;AAEjH,WAAO;EACX;;;;EAKO,UAAO;AA7MlB;AA8MQ,eAAK,6BAAL,mBAA+B;EACnC;EAEU,WAAW,UAAiB;AAClC,UAAM,iBAAiB,KAAK,kBAAkB;AAE9C,UAAM,OAAO,SAAS,cAAc,cAAc;AAClD,QAAI,QAAQ,MAAM;AACd;;AAGJ,eAAW,QAAQ,KAAK,OAAO;AAC3B,cAAQ,KAAK,YAAY;QACrB,KAAK;AACD,eAAK,+CAA+C,UAAU,MAAM,KAAK,eAAe;AACxF;QAEJ,KAAK;AACD,cAAI,CAAC,KAAK,YAAY;AAClB;;AAGJ,eAAK,iDAAiD,KAAK,YAAY,MAAM,KAAK,eAAe;AACjG;QAEJ;AACI,gBAAM,MAAM,qBAAqB;AACjC,eAAK,OAAM;AACX;;;EAGhB;EAEQ,+CAA+C,OAAgB,MAAc,YAAgC;AACjH,UAAM,YAAY,MAAM,oBAAoB,IAAI;AAChD,QAAI,cAAc,MAAM;AACpB;;AAGJ,UAAM,EAAE,MAAM,OAAO,QAAQ,kBAAkB,iBAAgB,IAAK;AAEpE,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,oBAAoB;AACzB,SAAK,qBAAqB;AAG1B,SAAK,4BAA4B,gBAAgB,iBAAiB,KAAK,SAAS,CAAC;AAEjF,QAAI,CAAC,KAAK,0BAA0B;AAChC,WAAK,2BAA2B,WAAW,eACvC,MACA,OACA,QACA,KAAK,kBAAkB,OACvB,OACA,MACA,QAAQ,sBACR,OAAO,iBAAiB;;AAIhC,YAAQ,YAAY;MAChB,KAAK;AACD,aAAK,yBAAyB,OAAO,aAAa,KAAK,IAAI,YAAY,IAAI,CAAC,EAAE,IAAI,CAAC,UAAU,QAAQ,gBAAgB,CAAC;AACtH;MAEJ,KAAK;AACD,aAAK,yBAAyB,OAAO,IAAI,aAAa,IAAI,EAAE,IAAI,CAAC,UAAU,QAAQ,gBAAgB,CAAC;AACpG;MAEJ;AACI;;EAEZ;EAEQ,iDAAiD,cAA8B,MAAc,YAAgC;AACjI,UAAM,YAAY,aAAa,oBAAoB,IAAI;AACvD,QAAI,cAAc,MAAM;AACpB;;AAGJ,UAAM,EAAE,SAAS,OAAO,OAAM,IAAK;AAEnC,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,sBAAsB;AAE3B,UAAM,QAAQ,KAAK,kBAAkB;AACrC,UAAM,SAAS,MAAM,UAAS;AAC9B,UAAM,kBAAkB,OAAO,iBAAiB,OAAO;AAEvD,QAAI,CAAC,KAAK,0BAA0B;AAChC,WAAK,2BAA2B,WAAW,eACvC,MACA,OACA,QACA,OACA,OACA,MACA,QAAQ,sBACR,eAAe,WAAW,OAAO,4BAA4B,OAAO,iBAAiB;;AAI7F,SAAK,yBAAyB,WAAW;EAC7C;;;;;EAMO,4BAAyB;AAC5B,UAAM,uBAAuB,KAAK,QAAQ,mBAAmB,QAAQ,KAAK,QAAQ,gBAAgB,WAAW;AAC7G,UAAM,uBAAuB,KAAK,QAAQ,wBAAwB,QAAQ,KAAK,QAAQ,qBAAqB,WAAW;AAEvH,WAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,UAAI,wBAAwB,sBAAsB;AAC9C,cAAM,SAAyB,KAAK,QAAQ,gBAAgB,IAAI,CAAC,UAAS;AACtE,kBAAQ,OAAO;YACX,KAAK;AACD,qBAAO;YACX,KAAK;AACD,qBAAO;;QAEnB,CAAC;AACD,cAAM,cAAmC,KAAK,QAAQ,qBAAqB,IAAI,CAAC,WAAU;AACtF,kBAAQ,QAAQ;YACZ,KAAK;AACD,qBAAO;YACX,KAAK;AACD,qBAAO;;QAEnB,CAAC;AAED,gBAAQ;UACJ,cAAc;YACV,iBAAiB;YACjB,sBAAsB;;SAE7B;aACE;AACH,gBAAQ,CAAA,CAAE;;IAElB,CAAC;EACL;;AAnMuB,kBAAA,OAAO,iBAAiB;AAOxB,kBAAA,UAAU;AA+LrC,qBAAqB,gBACjB,kBAAkB,MAClB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,kBAAkB,kBAAkB,OAAO;AAChE,GACA,kBAAkB,SAClB,KAAK;;;ACrWT,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;AAUf,YAAY,aAAaD,KAAI,IAAIC;;;ACTjC,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;;;;;;;;;AAuBf,YAAY,aAAaD,KAAI,IAAIC;;;ACN3B,IAAO,0BAAP,cAAuC,oBAAmB;;;;;;;;EAa5D,YAAY,qBAAmC,qBAAmC,OAAe,OAAuE,KAAG;AACvK,UAAM,iBAAiB,MAAM,OAAO,OAAO,MAAM,GAAA,OAAU,QAAA,OAAA,OAAwB,MAAO,QAAW,IAAA;AAZjG,SAAA,mBAA8D,CAAA;AAC9D,SAAA,yBAAwC,CAAA;AACxC,SAAA,sBAAgC,CAAC,OAAO,SAAQ,GAAI,OAAO,SAAQ,CAAE;AAWzE,SAAK,gBAAgB,KAAK,SAAQ,EAC7B,UAAS,EACT,mCAAmC,KAAK,eAAc,GAAI,KAAK,gBAAe,GAAI,qBAAqB,mBAAmB;AAC9H,SAAK,cAA2C,2BAA2B;AAC5E,SAAK,WAAW,KAAK,cAAc;AACnC,SAAK,SAAS,cAAc;AAC5B,SAAK,SAAS,SAAS;AAEvB,QAAI,OAAO;AACP,WAAK,oBAAoB,IAAI,eACzB,4BACA,OACA;QACI,QAAQ;QACR,UAAU;SAEd;QACI,UAAU,CAAC,SAAS,iBAAiB,kBAAkB,mBAAmB,0BAA0B,yBAAyB;OAChI;AAEL,WAAK,kBAAkB,uCAAuC;AAC9D,WAAK,kBAAkB,iBAAiB,IAAI,CAAC,SAAQ;AAGjD,aAAK,uBAAuB,KAAK,QAAQ,IAAI,KAAK,uBAAuB,KAAK,QAAQ,KAAK,KAAK,eAAc;AAC9G,aAAK,kBAAkB,UAAS,EAAG,UAAU,iBAAiB,KAAK,uBAAuB,KAAK,QAAQ,CAAC;AACxG,aAAK,uBAAuB,KAAK,QAAQ,IAAI,KAAK,eAAc;AAEhE,aAAK,kBAAkB,UAAS,EAAG,UAAU,0BAA0B,KAAK,oBAAoB,CAAC,CAAC;AAElG,aAAK,kBAAkB,UAAS,EAAG,UAAU,2BAA2B,KAAK,oBAAoB,CAAC,CAAC;AAGnG,aAAK,oBAAoB,CAAC,EAAE,SAAS,MAAM,mBAAkB,CAAE;AAC/D,aAAK,oBAAoB,CAAC,EAAE,SAAS,MAAM,iBAAiB;MAChE,CAAC;AACD,WAAK,kBAAkB,OAAM;;EAErC;EAEO,OAAO,uBAAgC,OAAO,eAAwB,OAAK;AAE9E,SAAK,iBAAiB,SAAS;AAC/B,UAAM,QAAQ,KAAK,SAAQ;AAE3B,QAAI,SAAS,KAAK,mBAAmB;AACjC,YAAM,gBAAe,EAAG,QAAQ,CAAC,SAAQ;AACrC,aAAK,iBAAiB,KAAK,CAAC,MAAM,KAAK,QAAQ,CAAC;AAChD,aAAK,WAAW,KAAK;MACzB,CAAC;;AAGL,UAAM,OAAO,sBAAsB,YAAY;AAG/C,SAAK,iBAAiB,QAAQ,CAAC,UAAS;AACpC,YAAM,CAAC,EAAE,WAAW,MAAM,CAAC;IAC/B,CAAC;EACL;;;;EAKO,mBAAgB;AACnB,QAAI,CAAC,KAAK,eAAe;AACrB;;AAEJ,SAAK,SAAQ,EAAI,UAAS,EAAG,yBAAyB,KAAK,aAAa;EAC5E;;;;;EAMO,eAAY;AACf,WAAO;EACX;EAEO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,kBAAkB,QAAO;AAC9B,SAAK,oBAAoB,SAAS;AAClC,SAAK,uBAAuB,SAAS;AACrC,SAAK,iBAAiB,SAAS;EACnC;;AAME,IAAO,4CAAP,MAAgD;EAMlD,YACuB,QACA,mBACA,iBAA+B;AAF/B,SAAA,SAAA;AACA,SAAA,oBAAA;AACA,SAAA,kBAAA;AARb,SAAA,iBAAiB,oBAAI,IAAG;AACxB,SAAA,wBAAwB,oBAAI,IAAG;AASrC,SAAK,UAAU,OAAO,UAAS;EACnC;EAEQ,oBAAoB,MAAY;AACpC,UAAM,eAAe,KAAK,kBAAkB,qBAAoB;AAChE,QAAI,CAAC,cAAc;AACf,YAAM,IAAI,MAAM,oEAAoE;;AAExF,QAAI,aAAa,cAAc,qBAAqB;AAChD,YAAM,IAAI,MAAM,iEAAiE;;AAErF,UAAM,QAAQ,aAAa;AAC3B,WAAO,KAAK,gBAAgB,gBAAgB,OAAO,IAAI;EAC3D;EAEU,wBAAwB,UAAoB,UAAyB;AAC3E,aAAS,IAAI;AACb,aAAS,IAAI;AACb,aAAS,QAAQ,SAAS;AAC1B,aAAS,SAAS,SAAS;EAC/B;EAEU,2BACN,OACA,QACA,aACA,qBACA,qBAAiC;AAEjC,QAAI,CAAC,KAAK,SAAS;AACf,YAAM,IAAI,MAAM,oBAAoB;;AAGxC,UAAM,cAAc,EAAE,OAAO,OAAM;AAGnC,UAAM,sBAAsB,IAAI,wBAAwB,qBAAqB,qBAAqB,KAAK,QAAQ,WAAW;AAC1H,UAAM,sBAAsB,oBAAoB;AAChD,QAAI,aAAa;AACb,0BAAoB,eAAe;;AAIvC,wBAAoB,qBAAqB;AACzC,wBAAoB,4BAA4B;AAEhD,wBAAoB,iBAAgB;AACpC,wBAAoB,sBAAsB,MAAM;AAEhD,WAAO;EACX;EAEU,4BAA4B,UAA2B,MAAY;AACzE,UAAM,eAAe,KAAK,eAAe,IAAI,IAAI;AACjD,QAAI,sBAAsB,KAAK,sBAAsB,IAAI,KAAK,GAAG;AAEjE,UAAM,QAAQ,SAAS;AACvB,UAAM,SAAS,SAAS;AAExB,QAAI,CAAC,wBAAuB,6CAAc,kBAAiB,UAAS,6CAAc,kBAAiB,QAAQ;AACvG,4BAAsB,KAAK,2BAA2B,OAAO,QAAQ,MAAM,SAAS,qBAAsB,SAAS,mBAAoB;AACvI,WAAK,sBAAsB,IAAI,KAAK,KAAK,mBAAmB;AAE5D,WAAK,yBAAyB;QAC1B,kBAAkB;QAClB,mBAAmB;;;AAI3B,SAAK,eAAe,IAAI,MAAM,QAAQ;AAEtC,WAAO;EACX;EAEO,sBAAsB,UAAoB,MAAY;AACzD,UAAM,WAAW,KAAK,eAAe,IAAI,IAAI,KAAK,KAAK,oBAAoB,IAAI;AAC/E,QAAI,UAAU;AACV,WAAK,wBAAwB,UAAU,QAAQ;AAC/C,aAAO;;AAEX,WAAO;EACX;;;;;EAMO,mBAAmB,MAAY;AAClC,UAAM,WAAW,KAAK,oBAAoB,IAAI;AAC9C,QAAI,UAAU;AAEV,eAAS;AACT,eAAS;;EAEjB;EAEO,6BAA6B,MAAW;AAC3C,WAAO;EACX;EAEO,8BAA8B,MAAY;AAC7C,UAAM,WAAW,KAAK,oBAAoB,IAAI;AAC9C,QAAI,UAAU;AACV,aAAO,KAAK,4BAA4B,UAAU,IAAI;;AAE1D,WAAO;EACX;EAEO,UAAO;AACV,SAAK,sBAAsB,QAAQ,CAAC,QAAQ,IAAI,QAAO,CAAE;AACzD,SAAK,sBAAsB,MAAK;EACpC;;AAME,IAAO,iBAAP,cAA8B,qBAAoB;;;;;EAyBpD,YAAY,mBAAsC;AAC9C,UAAM,iBAAiB;AAPnB,SAAA,yBAAoD;AA6CrD,SAAA,YAAsB,CAAC,iBAAiB,MAAM;AArCjD,SAAK,sBAAsB;AAC3B,SAAK,kBAAkB,MAAM,6BAA6B;EAC9D;;;;;;;EAQO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAGX,UAAM,SAAS,KAAK,kBAAkB,MAAM,UAAS;AACrD,SAAK,aAAa,OAAO;AACzB,SAAK,kBAAkB,IAAI,eAAe,KAAK,kBAAkB,SAAS,KAAK,UAAU;AAEzF,SAAK,uBAAuB,IAAI,0CAA0C,KAAK,kBAAkB,OAAO,KAAK,mBAAmB,KAAK,eAAe;AAEpJ,SAAK,yBAAyB,KAAK,kBAAkB,MAAM,wBAAwB,IAAI,MAAM,KAAK,eAAc,CAAE;AAElH,WAAO;EACX;EAEO,SAAM;AACT,SAAK,kBAAkB,MAAM,wBAAwB,OAAO,KAAK,sBAAsB;AACvF,WAAO,MAAM,OAAM;EACvB;EAEQ,iBAAc;AAClB,QAAI,KAAK,YAAY,KAAK,sBAAsB;AAC5C,WAAK,qBAAqB,OAAO,OAAO,KAAK;;EAErD;EAIO,eAAY;AACf,WAAO,KAAK,kBAAkB,MAAM,UAAS,EAAG,QAAO,EAAG,wBAAwB;EACtF;EAEO,UAAO;AACV,UAAM,QAAO;EACjB;EAEU,WAAW,UAAiB;AAClC,UAAM,OAAO,SAAS,cAAc,KAAK,kBAAkB,cAAc;AACzE,QAAI,CAAC,MAAM;AACP;;AAIJ,UAAM,OAAO,KAAK,MAAM,CAAC;AACzB,SAAK,uBAAuB,KAAK,wBAAwB,KAAK,qBAAsB,8BAA8B,IAAI;AACtH,SAAK,qBAAsB,mBAAmB,IAAI;EACtD;;AAhFuB,eAAA,OAAO,iBAAiB;AAMxB,eAAA,UAAU;AA8ErC,qBAAqB,gBACjB,eAAe,MACf,CAAC,qBAAoB;AACjB,SAAO,MAAM,IAAI,eAAe,gBAAgB;AACpD,GACA,eAAe,SACf,KAAK;;;ACtUH,IAAO,uBAAP,cAAoC,qBAAoB;;;;;;EAsD1D,YACI,mBACgB,UAAwC,CAAA,GAAE;AAE1D,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAvDZ,SAAA,0BAA6C,CAAA;AAM9C,SAAA,eAA8B,CAAA;AAI9B,SAAA,YAAsB,CAAA;AAMtB,SAAA,mBAUD,CAAA;AAKC,SAAA,8BAAyD,IAAI,WAAU;AA2B1E,SAAK,sBAAsB;EAC/B;EAEO,OAAO,OAA2B;AACrC,QAAI,CAAC,MAAM,OAAO,KAAK,GAAG;AACtB,aAAO;;AAGX,SAAK,aAAa,KAAK,kBAAkB,MAAM,UAAS,EAAG;AAC3D,SAAK,aAAa,IAAI,eAAe,KAAK,kBAAkB,SAAS,KAAK,UAAU;AAEpF,WAAO;EACX;EAEO,SAAM;AACT,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;;AAEX,SAAK,aAAa;AAClB,QAAI,CAAC,KAAK,QAAQ,sBAAsB;AACpC,WAAK,wBAAwB,QAAQ,CAAC,MAAM,EAAE,QAAO,CAAE;AACvD,WAAK,aAAa,QAAQ,CAAC,MAAM,EAAE,QAAO,CAAE;AAC5C,WAAK,wBAAwB,SAAS;AACtC,WAAK,aAAa,SAAS;AAC3B,WAAK,iBAAiB,SAAS;;AAEnC,WAAO;EACX;;;;EAKO,UAAO;AACV,UAAM,QAAO;AACb,SAAK,4BAA4B,MAAK;EAC1C;;;;;;EAOQ,wBAAwB,MAAc,OAAa;AACvD,UAAM,iBAAiB;MACnB,OAAO,KAAK,OAAQ;MACpB,QAAQ,KAAK,OAAQ;MACrB,GAAG;MACH,GAAG;;AAEP,UAAM,IAAI,KAAK;AAGf,UAAM,MAAO,IAAI,EAAE,CAAC,KAAK,eAAe,QAAS,IAAI,eAAe;AACpE,UAAM,MAAO,IAAI,EAAE,CAAC,KAAK,eAAe,SAAU,IAAI,eAAe;AAGrE,UAAM,KAAM,eAAe,QAAQ,IAAK,EAAE,CAAC;AAC3C,UAAM,KAAM,eAAe,SAAS,IAAK,EAAE,CAAC;AAG5C,UAAM,QAAS,eAAe,QAAQ,IAAK,EAAE,CAAC;AAC9C,SAAK,iBAAiB,KAAK,IAAI;MAC3B;MACA;MACA;MACA;MACA;MACA,OAAO,eAAe;MACtB,QAAQ,eAAe;MACvB,WAAW,eAAe;MAC1B,WAAW,eAAe;;EAElC;EAEQ,wBAAwB,MAAc,QAAQ,GAAC;AA7J3D;AA8JQ,QAAI,CAAC,KAAK,QAAQ;AACd,aAAO;;AAEX,SAAK,UAAU,KAAK,IAAI,KAAK;AAC7B,UAAM,MAAK,UAAK,eAAL,mBAAiB,eAAe,KAAK;AAEhD,QAAI,CAAC,KAAK,wBAAwB,KAAK,GAAG;AACtC,YAAM,kBAAkB,IAAI,gBAAgB,KAAK,kBAAkB,MAAM,UAAS,GAAI,sBAAsB,SAAS,IAAI;AACzH,sBAAgB,SAAS;AACzB,sBAAgB,UAAU;AAE1B,sBAAgB,SAAS;AACzB,sBAAgB,kBAAkB;AAClC,sBAAgB,OAAO;AACvB,sBAAgB,eAAe;AAC/B,sBAAgB,QAAQ,KAAK,OAAO;AACpC,sBAAgB,SAAS,KAAK,OAAO;AACrC,sBAAgB,eAAe;AAC/B,sBAAgB,eAAe;AAC/B,sBAAgB,mBAAmB,IAAI,qBAAqB,IAAI,KAAK,UAAU;AAC/E,WAAK,wBAAwB,KAAK,IAAI;AAEtC,YAAM,UAAU,IAAI,YAAY,KAAK,kBAAkB,KAAK;AAC5D,cAAQ,OAAO,4BAA4B,KAAK;AAChD,cAAQ,WAAW,KAAK,wBAAwB,KAAK;AACrD,WAAK,aAAa,KAAK,IAAI;AAE3B,WAAK,wBAAwB,MAAM,KAAK;WACrC;AAEH,iBAAK,wBAAwB,KAAK,EAAE,qBAApC,mBAAsD,IAAI;;AAE9D,SAAK,wBAAwB,KAAK,EAAE,UAAU;AAC9C,WAAO;EACX;EAEU,WAAW,UAAiB;AAClC,UAAM,iBAAiB,KAAK,kBAAkB;AAE9C,UAAM,OAAO,SAAS,cAAc,cAAc;AAClD,QAAI,CAAC,QAAQ,CAAC,KAAK,OAAO;AACtB;;AAEJ,QAAI,UAAU;AACd,SAAK,MAAM,QAAQ,CAAC,MAAM,UAAS;AAC/B,gBAAU,WAAW,KAAK,wBAAwB,MAAM,KAAK;IACjE,CAAC;AACD,QAAI,SAAS;AACT,WAAK,4BAA4B,gBAAgB,KAAK,YAAY;;EAE1E;;AAhJuB,qBAAA,OAAO,iBAAiB;AAOxB,qBAAA,UAAU;AA4IrC,qBAAqB,gBACjB,qBAAqB,MACrB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,qBAAqB,kBAAkB,OAAO;AACnE,GACA,qBAAqB,SACrB,KAAK;;;AC/MH,IAAO,6BAAP,cAA0C,8BAA6B;;;;;;;EASzE,YAAY,OAAc,eAA+C,YAAsC;AAE3G,UAAM,OAAO,8BAA8B,UAAU,GAAG,eAAe,YAAY,IAAI;AAVpF,SAAA,YAAY;EAWnB;EAEU,sBAAmB;AACzB,WAAO;MACH,UAAU;MACV,MAAM;;EAEd;EAEU,8BAA2B;AACjC,WAAO;EACX;EAEU,oBAAoB,SAAuB;EAErD;EAEU,aAAa,QAAsB;EAE7C;EAEU,eAAY;EAEtB;;AAIJ,6BAA6B,mBAAmB,6BAA6B,CAAC,SAAwB,UAAgB;AAClH,SAAO,IAAI,2BAA2B,OAAY,QAAQ,SAAS,QAAQ,UAAU;AACzF,CAAC;AAGD,IAAM,gCAA4D;EAC9D,MAAM;IACF,mBAAmB;IACnB,YAAY;;MAER,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,OAAO;QACH,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;EAEf,OAAO;IACH,mBAAmB;IACnB,YAAY;;MAER,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,OAAO;QACH,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;EAEf,MAAM;IACF,mBAAmB;IACnB,YAAY;;MAER,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,OAAO;QACH,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;;;;AClHb,IAAO,uCAAP,MAAO,8CAA6C,8BAA6B;EAsEnF,YAAY,OAAc,eAA+C,YAAsC;AAC3G,UAAM,OAAO,oBAAoB,YAAY,GAAG,eAAe,UAAU;AArE1D,SAAA,WAAW;MAC1B,eAAe;QACX,eAAe;QACf,mBAAmB;QACnB,iBAAiB;;MAErB,aAAa;QACT,eAAe;QACf,aAAa;QACb,aAAa;;MAEjB,SAAS;QACL,uBAAuB;UACnB,cAAc;UACd,mBAAmB;UACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;;QAE5C,uBAAuB;UACnB,cAAc;UACd,mBAAmB;UACnB,QAAQ,CAAC,SAAS;;QAEtB,wBAAwB;UACpB,cAAc;UACd,qBAAqB;UACrB,oBAAoB;;;QAExB,0BAA0B;UACtB,cAAc;UACd,mBAAmB;UACnB,QAAQ,CAAC,SAAS;;;MAG1B,MAAM;QACF,wBAAwB;UACpB,UAAU;YACN,cAAc;;UAElB,UAAU;YACN,cAAc;;;QAGtB,0BAA0B;UACtB,UAAU;YACN,cAAc;;UAElB,UAAU;YACN,cAAc;;;;;AAmBvB,SAAA,YAAY;EAInB;EAEU,sBAAmB;AACzB,QAAI,WAAW;AACf,QAAI,KAAK,eAAe,QAAQ;AAC5B,iBAAW,sCAAqC;WAC7C;AAEH,iBAAW,sCAAqC;;AAGpD,UAAM,SAAS;AACf,UAAM,OAAO,sCAAqC,iBAAiB,SAAS;AAC5E,WAAO;MACH;MACA;;EAER;EAEU,8BAA2B;AACjC,UAAM,YAAY,YAAY,8BAA8B,MAAM;AAClE,QAAI,CAAC,WAAW;AACZ,aAAO,KAAK,wEAAwE;;AAExF,WAAO;EACX;EAEU,oBAAoB,SAAuB;AACjD,QAAI,CAAC,KAAK,UAAU;AAChB;;AAIJ,SAAK,gBAAe,EAAG,QAAQ,CAAC,IAAI,MAAK;AACrC,UAAI,KAAK,kBAAkB;AACvB;;AAEJ,UAAI,MAAM,KAAK,UAAU;AACrB,cAAM,YAAkB,KAAK,SAAS,QAAS,EAAE;AACjD,cAAM,iBAAiB,UAAU;AACjC,YAAI,CAAC,gBAAgB;AACjB,iBAAO,IAAI,uCAAuC,IAAI,wBAAwB,EAAE;AAChF;;AAGJ,cAAM,aAAa,KAAK,gBAAgB,KAAK,UAAU,cAAc;AACrE,YAAI,CAAC,YAAY;AACb,iBAAO,KAAK,oCAAoC,cAAc;AAC9D;;AAGJ,kBAAU,YAAY,KAAK,yBAAyB,YAAY,KAAK,SAAS,cAAc,aAAa;AACzG,kBAAU,cAAc,KAAK,yBAAyB,YAAY,KAAK,SAAS,cAAc,eAAe;AAC7G,kBAAU,gBAAgB,KAAK,yBAAyB,YAAY,KAAK,SAAS,cAAc,iBAAiB;AAEjH,YAAI,UAAU,aAAa,UAAU,eAAe,UAAU,eAAe;AACzE,gBAAM,OAAO,KAAK,aAAa,EAAE;AACjC,cAAI,MAAM;AACN,iBAAK,+BAA+B,IAChC,CAAC,cAAa;AACV,mBAAK,eAAe,WAAW,UAAU,KAAK;YAClD,GACA,QACA,IAAI;;eAGT;AAEH,iBAAO,KAAK,kDAAkD,cAAc;;;IAGxF,CAAC;AAGD,SAAK,gBAAe,EAAG,QAAQ,CAAC,OAAM;AAClC,YAAM,OAAO,KAAK,aAAa,EAAE;AACjC,UAAI,CAAC,KAAK,OAAM,GAAI;AAChB;;AAGJ,OAAC,UAAU,QAAQ,EAAE,QAAQ,CAAC,SAAQ;AAClC,YAAI,CAAC,KAAK,UAAU;AAChB;;AAEJ,cAAM,UAAgB,KAAK,SAAS,KAAM,EAAE,EAAE,IAAI;AAElD,cAAM,WAAW,KAAK,gBAAgB,KAAK,UAAU,QAAQ,YAAY;AACzE,YAAI,CAAC,UAAU;AACX,iBAAO,KAAK,kCAAkC,QAAQ,YAAY;AAClE;;AAGJ,gBAAQ,YAAY,KAAK,yBAAyB,UAAU,KAAK,SAAS,YAAY,aAAa;AACnG,gBAAQ,UAAU,KAAK,yBAAyB,UAAU,KAAK,SAAS,YAAY,WAAW;AAC/F,gBAAQ,UAAU,KAAK,yBAAyB,UAAU,KAAK,SAAS,YAAY,WAAW;AAE/F,YAAI,QAAQ,aAAa,QAAQ,WAAW,QAAQ,SAAS;AACzD,cAAI,MAAM;AACN,iBAAK,6BAA6B,IAC9B,CAAC,eAAc;AACX,oBAAM,QAAQ,SAAS,WAAW,WAAW,IAAI,WAAW;AAC5D,mBAAK,eAAe,SAAS,OAAO,IAAI;YAC5C,GACA,QACA,IAAI;;eAGT;AAEH,iBAAO,KAAK,gDAAgD,QAAQ,YAAY;;MAExF,CAAC;IACL,CAAC;EACL;EAEU,aAAa,QAAsB;AACzC,SAAK,WAAW,IAAI,KAAK,KAAK,YAAY,MAAM,KAAK,YAAY,KAAK,KAAK;AAC3E,SAAK,SAAS,aAAa;AAC3B,QAAI;AAEJ,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,YAAM,OAAO,OAAO,CAAC;AAErB,WAAK,aAAa;AAElB,UAAI,CAAC,KAAK,QAAQ;AAEd,mBAAW;;;AAInB,QAAI,UAAU;AACV,eAAS,UAAU,KAAK,QAAQ;;AAGpC,QAAI,CAAC,KAAK,MAAM,sBAAsB;AAClC,WAAK,SAAS,qBAAqB,WAAW,gBAAgB,GAAG,KAAK,IAAI,CAAC;;EAEnF;EAEU,eAAY;EAEtB;;AA5Jc,qCAAA,iBAAyB;AAIzB,qCAAA,sBAA8B;AAI9B,qCAAA,uBAA+B;AAwJjD,6BAA6B,mBAAmB,yBAAyB,CAAC,SAAwB,UAAgB;AAC9G,SAAO,IAAI,qCAAqC,OAAY,QAAQ,SAAS,QAAQ,UAAU;AACnG,CAAC;AAGD,IAAM,sBAAkD;EACpD,MAAM;IACF,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB;UACb,6BAA6B;YACzB,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;;;MAIzB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB;UACb,6BAA6B;YACzB,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;;;MAIzB,wBAAwB;QACpB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB;UACb,8BAA8B;YAC1B,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,mCAAmC;YAC/B,mBAAmB;YACnB,QAAQ,CAAC,WAAW,SAAS;YAC7B,mBAAmB;YACnB,eAAe;;;QAGvB,oBAAoB;;MAExB,0BAA0B;QACtB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB;UACb,gCAAgC;YAC5B,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,sCAAsC;YAClC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,sCAAsC;YAClC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;;;;IAK7B,gBAAgB;IAChB,cAAc;IACd,WAAW;;EAEf,OAAO;IACH,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB;UACb,6BAA6B;YACzB,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;;;MAIzB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB;UACb,6BAA6B;YACzB,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;;;MAIzB,wBAAwB;QACpB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB;UACb,8BAA8B;YAC1B,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,oCAAoC;YAChC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,mCAAmC;YAC/B,mBAAmB;YACnB,QAAQ,CAAC,WAAW,SAAS;YAC7B,mBAAmB;YACnB,eAAe;;;QAGvB,oBAAoB;;MAExB,0BAA0B;QACtB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB;UACb,gCAAgC;YAC5B,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,sCAAsC;YAClC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;UAEjB,sCAAsC;YAClC,mBAAmB;YACnB,QAAQ,CAAC,WAAW,WAAW,SAAS;YACxC,mBAAmB;YACnB,eAAe;YACf,aAAa;YACb,aAAa;;;;;IAK7B,gBAAgB;IAChB,cAAc;IACd,WAAW;;;;;AC7eb,IAAO,mCAAP,MAAO,0CAAyC,8BAA6B;EAsB/E,YACI,OACA,eACA,YACA,iBAA0B,OAClB,0BAAmC,OAAK;AAEhD,UAAM,OAAO,mBAAmB,UAAU,GAAG,eAAe,UAAU;AAF9D,SAAA,0BAAA;AAPL,SAAA,YAAY;EAUnB;EAEU,sBAAmB;AACzB,QAAI,WAAW;AACf,QAAI,KAAK,eAAe,QAAQ;AAC5B,iBAAW,kCAAiC;WACzC;AAEH,iBAAW,kCAAiC;;AAGhD,UAAM,OAAO,KAAK,SAAQ,IAAK,kCAAiC,uBAAuB,kCAAiC;AACxH,WAAO;MACH;MACA;;EAER;EAEU,8BAA2B;AACjC,WAAO;EACX;EAEU,oBAAoB,SAAuB;AACjD,UAAM,UAAU,KAAK,SAAQ;AAC7B,UAAM,mBAAmB,KAAK,eAAe,UAAU,KAAK;AAE5D,SAAK,gBAAe,EAAG,QAAQ,CAAC,OAAM;AAClC,YAAM,OAAO,MAAM,KAAK,aAAa,EAAE;AACvC,UAAI,MAAM;AACN,aAAK,+BAA+B,IAChC,CAAC,cAAa;AACV,cAAI,CAAC,KAAK,YAAY,KAAK,kBAAkB;AACzC;;AAGJ,kBAAQ,IAAI;YACR,KAAK;AACD,kBAAI,CAAC,SAAS;AACK,qBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI,CAAC,UAAU,QAAQ;AACtE,qBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI,CAAC,UAAU,QAAQ;AACtE,qBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI,CAAC,UAAU,QAAQ;;AAEzF;YACJ,KAAK;AACD,kBAAI,CAAC,SAAS;AACK,qBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI,mBAAmB,UAAU,QAAQ;;AAE3G;YACJ,KAAK;AACD;YACJ,KAAK;YACL,KAAK;AACD,kBAAI,CAAC,SAAS;AACV,oBAAI,UAAU,SAAS;AACJ,uBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI;uBAC/D;AACY,uBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI;;;AAG1E;YACJ,KAAK;YACL,KAAK;AACD,kBAAI,CAAC,SAAS;AACV,oBAAI,UAAU,SAAS;AACJ,uBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI;uBAC/D;AACY,uBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI;;;AAG1E;;QAEZ,GACA,QACA,IAAI;;IAGhB,CAAC;EACL;EAEU,aAAa,QAAsB;AACzC,SAAK,WAAW,IAAI,KAAK,KAAK,YAAY,MAAM,KAAK,YAAY,KAAK,KAAK;AAC3E,QAAI,CAAC,KAAK,MAAM,sBAAsB;AAClC,WAAK,SAAS,qBAAqB,WAAW,gBAAgB,GAAG,KAAK,IAAI,CAAC;;AAG/E,WAAO,QAAQ,CAAC,SAAQ;AACpB,WAAK,aAAa;IACtB,CAAC;AACD,QAAI,KAAK,SAAQ,GAAI;AACjB,WAAK,iBAAiB,OAAO,CAAC;WAC3B;AACH,WAAK,iBAAiB,OAAO,CAAC;AAC9B,WAAK,SAAS,SAAS,IAAI;AAC3B,WAAK,SAAS,SAAS,IAAI;;AAE/B,SAAK,eAAe,SAAS,KAAK;EACtC;EAEU,eAAY;EAEtB;;;;;;EAOQ,WAAQ;AAEZ,WAAO,CAAC,CAAC,UAAU,UAAU,MAAM,SAAS,KAAK,CAAC,KAAK;EAC3D;;AAtIc,iCAAA,iBAAyB;AAIzB,iCAAA,sBAA8B;AAI9B,iCAAA,uBAA+B;AAI/B,iCAAA,uBAA+B;AA8HjD,6BAA6B,mBAAmB,gBAAgB,CAAC,SAAwB,UAAgB;AACrG,SAAO,IAAI,iCAAiC,OAAY,QAAQ,SAAS,QAAQ,UAAU;AAC/F,CAAC;AAED,6BAA6B,mBAAmB,uBAAuB,CAAC,SAAwB,UAAgB;AAC5G,SAAO,IAAI,iCAAiC,OAAY,QAAQ,SAAS,QAAQ,YAAY,IAAI;AACrG,CAAC;AAED,IAAM,qBAAiD;EACnD,MAAM;IACF,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,0BAA0B;QACtB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB,CAAA;;MAErB,YAAY;QACR,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,YAAY;QACR,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,WAAW;QACP,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;EAEf,OAAO;IACH,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,0BAA0B;QACtB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB,CAAA;;MAErB,YAAY;QACR,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,YAAY;QACR,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,WAAW;QACP,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;;;;AC5Qb,IAAO,+BAAP,MAAO,sCAAqC,8BAA6B;;;;;;;EAoB3E,YAAY,OAAc,eAA+C,YAAsC;AAC3G,UAAM,OAAO,cAAc,UAAU,GAAG,eAAe,UAAU;AAT9D,SAAA,YAAY;EAUnB;EAEU,sBAAmB;AACzB,UAAM,WAAW,8BAA6B;AAC9C,UAAM,OAAO,8BAA6B;AAE1C,WAAO;MACH;MACA;;EAER;EAEU,8BAA2B;AACjC,WAAO;EACX;EAEU,oBAAoB,SAAuB;AACjD,SAAK,gBAAe,EAAG,QAAQ,CAAC,OAAM;AAClC,YAAM,OAAO,MAAM,KAAK,aAAa,EAAE;AACvC,UAAI,MAAM;AACN,aAAK,+BAA+B,IAChC,CAAC,cAAa;AACV,cAAI,CAAC,KAAK,YAAY,KAAK,kBAAkB;AACzC;;AAGJ,kBAAQ,IAAI;YACR,KAAK;AACc,mBAAK,eAAe,YAAW,EAAG,CAAC,EAAG,SAAS,IAAI,CAAC,UAAU,QAAQ;AACrF;YACJ,KAAK;AACD;YACJ,KAAK;AACD;;QAEZ,GACA,QACA,IAAI;;IAGhB,CAAC;EACL;EAEU,aAAa,QAAsB;AACzC,SAAK,WAAW,IAAI,KAAK,KAAK,YAAY,MAAM,KAAK,YAAY,KAAK,KAAK;AAE3E,WAAO,QAAQ,CAAC,SAAQ;AACpB,WAAK,aAAa;IACtB,CAAC;AACD,SAAK,iBAAiB,OAAO,CAAC;AAC9B,SAAK,eAAe,SAAS,KAAK;AAClC,QAAI,CAAC,KAAK,MAAM,sBAAsB;AAClC,WAAK,SAAS,qBAAqB,WAAW,gBAAgB,GAAG,KAAK,IAAI,CAAC;;EAEnF;EAEU,eAAY;EAEtB;;AA1Ec,6BAAA,iBAAyB;AAIzB,6BAAA,iBAAyB;AA0E3C,6BAA6B,mBAAmB,YAAY,CAAC,SAAwB,UAAgB;AACjG,SAAO,IAAI,6BAA6B,OAAY,QAAQ,SAAS,QAAQ,UAAU;AAC3F,CAAC;AAMD,IAAM,gBAA4C;EAC9C,MAAM;IACF,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,wBAAwB;QACpB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB,CAAA;;MAErB,MAAM;QACF,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;EAEf,OAAO;IACH,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,wBAAwB;QACpB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB,CAAA;;MAErB,MAAM;QACF,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;EAEf,MAAM;IACF,mBAAmB;IACnB,YAAY;MACR,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,uBAAuB;QACnB,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;MAErB,wBAAwB;QACpB,MAAM;QACN,gBAAgB;UACZ,QAAQ;UACR,OAAO;UACP,OAAO;;QAEX,cAAc;QACd,iBAAiB,CAAA;;MAErB,MAAM;QACF,MAAM;QACN,gBAAgB;UACZ,QAAQ;;QAEZ,cAAc;QACd,iBAAiB,CAAA;;;IAGzB,gBAAgB;IAChB,cAAc;IACd,WAAW;;;;;ACjOnB,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;AAMf,YAAY,aAAaD,KAAI,IAAIC;;;ACRjC,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;;;;;;;;;;AAwBf,YAAY,aAAaD,KAAI,IAAIC;;;ACX3B,IAAO,kBAAP,MAAO,yBAAwB,YAAW;;;;;EAKrC,eAAY;AACf,WAAO;EACX;;;;;;;;;;;;EAaA,YACIC,QACA,SACA,SAA2B,MAC3B,cACA,QACA,UACA,cAAsB,GAAA,mBAAU,OAAA;AAGhC,UAAMA,QAAM,QAAQ,MAAM,MAAM,SAAS,QAAQ,cAAc,QAAQ,UAAU,QAAW,aAAa,QAAW,MAAM,gBAAgB;EAC9I;;;;EAKO,OAAO,OAAO,mBAAwB,cAAsB,OAAc,SAAe;AAC5F,WAAO,oBAAoB,MACvB,MAAK;AACD,aAAO,IAAI,iBACP,kBAAkB,MAClB,kBAAkB,SAClB,cACA,kBAAkB,0BAClB,kBAAkB,SAClB,kBAAkB,QAAQ;IAElC,GACA,mBACA,OACA,OAAO;EAEf;;AAGJ,cAAc,2BAA2B,eAAe;AAKlD,IAAO,sBAAP,MAAO,6BAA4B,YAAW;;;;;;;;;;EAYhD,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;EAEA,IAAW,KAAK,OAAa;AACzB,QAAI,QAAQ,KAAK,QAAQ,GAAG;AACxB;;AAGJ,SAAK,QAAQ;AACb,YAAQ,KAAK,OAAO;MAChB,KAAK;AACD,aAAK,aAAa,mBAAmB;AACrC;MACJ,KAAK;AACD,aAAK,aAAa,mBAAmB;AACrC;MACJ,KAAK;AACD,aAAK,aAAa,mBAAmB;AACrC;MACJ,KAAK;AACD,aAAK,aAAa,mBAAmB;AACrC;MACJ,KAAK;AACD,aAAK,aAAa,mBAAmB;AACrC;MACJ,KAAK;AACD,aAAK,aAAa,mBAAmB;AACrC;;EAEZ;;;;;EAMO,eAAY;AACf,WAAO;EACX;;;;;;;;;;;;EAaA,YACIA,QACA,SACA,SAA2B,MAC3B,cACA,QACA,UACA,cAAsB,GAAA,mBAAU,OAAA;AAGhC,UAAMA,QAAM,YAAY,MAAM,MAAM,SAAS,QAAQ,cAAc,QAAQ,UAAU,qBAAqB,aAAa,QAAW,MAAM,gBAAgB;AAxEpJ,SAAA,QAAQ;EAyEhB;;;;EAKO,OAAO,OAAO,mBAAwB,cAAsB,OAAc,SAAe;AAC5F,WAAO,oBAAoB,MACvB,MAAK;AACD,aAAO,IAAI,qBACP,kBAAkB,MAClB,kBAAkB,SAClB,cACA,kBAAkB,0BAClB,kBAAkB,SAClB,kBAAkB,QAAQ;IAElC,GACA,mBACA,OACA,OAAO;EAEf;;AAGJ,OAAO,6BAA6B,CAAC,WAAkB;AACnD,SAAO,IAAI,gBAAgB,WAAW,GAAG,MAAM,GAAA,QAAU,OAAA,CAAA;AAC7D;;;AC9JM,SAAU,kBAAkB,SAAkB,OAAe,QAAgB,kBAA2B,MAAI;AAC9G,QAAM,QAAe,QAAQ,SAAQ;AACrC,QAAM,SAAS,MAAM,UAAS;AAE9B,QAAM,MAAM,IAAI,oBACZ,YAAY,QAAQ,MACpB,EAAE,OAAc,OAAc,GAC9B,OACA,CAAC,QAAQ,UACT,MACkB,QAAQ,SAAU,MACpC,OACA,QAAQ,cACR,KAAK;AAGT,MAAI,QAAQ,QAAQ;AACpB,MAAI,QAAQ,QAAQ;AACpB,MAAI,UAAU,QAAQ;AACtB,MAAI,UAAU,QAAQ;AACtB,MAAI,SAAS,QAAQ;AACrB,MAAI,SAAS,QAAQ;AACrB,MAAI,OAAO,QAAQ;AACnB,MAAI,OAAO,QAAQ;AACnB,MAAI,OAAO,QAAQ;AACnB,MAAI,mBAAmB,QAAQ;AAC/B,MAAI,QAAQ,QAAQ;AACpB,MAAI,4BAA4B,QAAQ;AACtB,MAAI,SAAU,UAAU;AAE1C,UAAQ,QAAQ,QAAQ;AACxB,UAAQ,QAAQ,QAAQ;AAExB,QAAM,kBAAkB,IAAI,gBACxB,QACA,GACA,MACA,kBAAkB,QAAQ,wBAAwB,QAAQ,sBAC1D,QACA,OACA,CAAA;AAEJ,kBAAgB,gCAAgC;AAChD,kBAAgB,UAAS,EAAG,oBAAoB,MAAK;AACjD,oBAAgB,UAAU,SAAU,QAAM;AACtC,aAAO,WAAW,kBAAkB,OAAO;IAC/C;AAEA,UAAM,kBAAkB,IAAI;AAE5B,QAAI,iBAAiB;AACjB,YAAM,mBAAmB,aAAa,CAAC,eAAe,GAAG,eAAe;AAExE,aAAO,kBAAkB,eAAe;AACxC,UAAI,0BAAyB;AAC7B,sBAAgB,QAAO;AAEvB,UAAI,mBAAkB,EAAI,UAAU;;EAE5C,CAAC;AAED,SAAO;AACX;AAcM,SAAU,iBACZ,iBACA,iBACA,OACA,MACA,cACA,QACA,OACA,QAAe;AAGf,QAAM,SAAS,gBAAgB,UAAS;AAExC,kBAAgB,UAAU;AAE1B,iBAAe,gBAAgB,gBAAgB;AAC/C,SAAO,QAAQ,gBAAgB;AAC/B,WAAS,UAAU,gBAAgB;AACnC,UAAQ,SAAS,gBAAgB;AACjC,WAAS,UAAU,gBAAgB;AAEnC,MAAI,SAAS,IAAI;AACb,WAAO;;AAGX,SAAO,IAAI,QAAQ,CAAC,YAAW;AAE3B,UAAM,cAAc,IAAI,YAAY,eAAe,iBAAiB,MAAM,MAAM,GAAG,MAAM,cAAc,QAAQ,OAAO,QAAW,MAAM,QAAW,MAAM,OAAO,MAAM;AACrK,gBAAY,gCAAgC;AAG5C,UAAM,iBAAiB,OAAO,0BAC1B,EAAE,OAAwB,OAAwB,GAClD;MACI,qBAAqB;MACrB,iBAAiB;MACjB,uBAAuB;MACvB;MACA;MACA;KACH;AAGL,gBAAY,UAAS,EAAG,oBAAoB,MAAK;AAE7C,kBAAY,UAAU,CAAC,WAAU;AAC7B,eAAO,aAAa,kBAAkB,eAAe;AACrD,eAAO,UAAU,SAAS,GAAG,CAAC;MAClC;AACA,YAAM,mBAAmB,aAAa,CAAC,WAAY,GAAG,gBAAgB,IAAI;AAG1E,aAAO,0BAAyB;AAChC,aAAO,gBAAgB,eAAe;AACtC,UAAI,aAAa;AACb,oBAAY,QAAO;;AAIvB,qBAAe,YAAY,eAAe;AAG1C,sBAAgB,OAAO;AACvB,sBAAgB,SAAS;AACzB,sBAAgB,UAAU;AAE1B,cAAQ,eAAe;IAC3B,CAAC;EACL,CAAC;AACL;AAGA,IAAI;AACJ,IAAI;AAME,SAAU,YAAY,OAAa;AACrC,MAAI,CAAC,WAAW;AACZ,gBAAY,IAAI,aAAa,CAAC;AAC9B,gBAAY,IAAI,WAAW,UAAU,MAAM;;AAG/C,YAAU,CAAC,IAAI;AACf,QAAM,IAAI,UAAU,CAAC;AAErB,MAAI,OAAQ,KAAK,KAAM;AACvB,MAAI,IAAK,KAAK,KAAM;AACpB,QAAM,IAAK,KAAK,KAAM;AAItB,MAAI,IAAI,KAAK;AACT,WAAO;;AAIX,MAAI,IAAI,KAAK;AACT,YAAQ;AAGR,aAAS,KAAK,MAAM,IAAI,MAAM,IAAI;AAClC,WAAO;;AAIX,MAAI,IAAI,KAAK;AACT,SAAK;AAGL,aAAS,KAAM,MAAM,MAAQ,KAAM,MAAM,IAAM;AAC/C,WAAO;;AAGX,UAAU,IAAI,OAAQ,KAAO,KAAK;AAClC,UAAQ,IAAI;AACZ,SAAO;AACX;AAOM,SAAU,cAAc,OAAa;AACvC,QAAM,KAAK,QAAQ,UAAW;AAC9B,QAAM,KAAK,QAAQ,UAAW;AAC9B,QAAM,IAAI,QAAQ;AAElB,MAAI,MAAM,GAAG;AACT,YAAQ,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,GAAG,KAAK,IAAI,KAAK,IAAI,GAAG,EAAE;aACrD,KAAK,IAAM;AAClB,WAAO,IAAI,OAAO,IAAI,KAAK,KAAK;;AAGpC,UAAQ,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,EAAE,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,EAAE;AACvE;AAEA,IAAM,eAAe,OAAO,SAAsB,OAAe,QAAgB,MAAc,QAAoC;AAC/H,QAAM,QAAQ,QAAQ,SAAQ;AAC9B,QAAM,SAAS,MAAM,UAAS;AAE9B,MAAI;AAEJ,MAAI,CAAC,QAAQ,QAAQ;AACjB,qBAAiB,IAAI,YAAY,OAAO,OAAO,CAAC,OAAO,OAAO,GAAG,MAAM,GAAK,MAAM,QAAQ,4BAA4B,MAAM;SACzH;AACH,UAAM,cAAc,CAAC,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,mBAAmB;AACjJ,qBAAiB,IAAI,YAAY,WAAW,WAAW,CAAC,OAAO,OAAO,GAAG,MAAM,GAAK,MAAM,QAAQ,4BAA4B,QAAQ,OAAO,YAAY,IAAI,CAAC;;AAGlK,QAAM,IAAI,QAAQ,CAAC,YAAW;AAC1B,mBAAe,UAAS,EAAG,oBAAoB,MAAK;AAChD,cAAQ,CAAC;IACb,CAAC;EACL,CAAC;AAED,QAAM,MAAM,IAAI,oBAAoB,QAAQ,EAAE,OAAc,OAAc,GAAI,OAAO,KAAK;AAE1F,iBAAe,UAAU,SAAU,QAAM;AACrC,WAAO,WAAW,kBAAkB,OAAO;AAC3C,WAAO,SAAS,OAAO,GAAG;AAC1B,WAAO,QAAQ,SAAS,QAAQ,UAAU;EAC9C;AAEA,QAAM,kBAAkB,QAAQ,mBAAkB;AAElD,MAAI;AACA,QAAI,IAAI,gBAAgB,iBAAiB;AACrC,YAAM,eAAe,gBAAgB;AACrC,UAAI,QAAQ,GAAG;AACX,gBAAQ,mBAAmB,QAAQ,0BAA0B;aAC1D;AACH,gBAAQ,mBAAmB,QAAQ,eAAe;;AAGtD,YAAM,mBAAmB,aAAa,CAAC,cAAc,GAAG,IAAI,cAAc,IAAI;AAC9E,cAAQ,mBAAmB,YAAY;AAGvC,YAAM,aAAa,MAAM,OAAO,WAAW,GAAG,GAAG,OAAO,MAAM;AAC9D,YAAM,OAAO,IAAI,WAAW,WAAW,QAAQ,GAAG,WAAW,UAAU;AAGvE,aAAO,kBAAkB,IAAI,YAAY;AAEzC,aAAO;WACJ;AACH,YAAM,MAAM,2BAA2B;;;AAG3C,QAAI,QAAO;AACX,mBAAe,QAAO;;AAE9B;AAYA,eAAsB,oBAAoB,SAAsB,OAAe,QAAgB,OAAe,GAAG,MAAc,GAAC;AAC5H,MAAI,CAAC,QAAQ,QAAO,KAAM,QAAQ,UAAU;AACxC,UAAM,IAAI,QAAQ,CAAC,SAAS,WAAU;AAClC,UAAI,QAAQ,aAAa,MAAM;AAC3B,eAAO,CAAC;AACR;;AAEJ,cAAQ,SAAS,mBAAmB,QAAQ,MAAK;AAC7C,gBAAQ,CAAC;MACb,CAAC;IACL,CAAC;;AAEL,SAAO,MAAM,aAAa,SAAS,OAAO,QAAQ,MAAM,GAAG;AAC/D;AAKO,IAAM,eAAe;;;;;;;;;EASxB;;;;;;;;;;;EAYA;;;;;;EAMA;;;;;;EAOA;;;;;;;;;;;;EAaA;;;;ACjWE,IAAO,mBAAP,MAAuB;;;;;EAKlB,OAAO,kBAAkB,SAAgB;AAC5C,UAAM,kBAAkB,QAAQ;AAChC,QAAI,CAAC,mBAAmB,CAAC,QAAQ,QAAQ;AACrC;;AAIJ,UAAM,SAAS,gBAAgB,UAAS;AACxC,UAAM,OAAO,OAAO,QAAO;AAC3B,UAAM,UAAU,gBAAgB;AAChC,QAAI,gBAAgB;AAGpB,QAAI,KAAK,0BAA0B,KAAK,iCAAiC;AACrE,sBAAgB;AAChB,sBAAgB,OAAO;eAGlB,KAAK,sBAAsB,KAAK,6BAA6B;AAClE,sBAAgB;AAChB,sBAAgB,OAAO;;AAG3B,QAAI,eAAe;AAEf,sBAAgB,UAAU;AAC1B,sBAAgB,UAAU;AAC1B,sBAAgB,UAAU;;AAG9B,UAAM,oBAAoB,MAAK;AAG3B,YAAM,kBAAkB,IAAI,YACxB,cACA,cACA,MACA,MACA,GACA,MACA,GAAA,QAAU,OAAA,QAAA,gBACV,MACA,QACA,MACA,KAAA;AAKJ,sBAAgB,gCAAgC;AAGhD,YAAM,kBAAkB,OAAO,0BAA0B,gBAAgB,OAAO;QAC5E,qBAAqB;QACrB,iBAAiB;QACjB,uBAAuB;QACvB,cAAc,gBAAgB;QAC9B,MAAM,gBAAgB;QACtB,QAAQ;OACX;AAED,sBAAgB,UAAS,EAAG,oBAAoB,MAAK;AAEjD,wBAAgB,UAAU,CAAC,WAAU;AACjC,iBAAO,aAAa,kBAAkB,eAAe;AACrD,iBAAO,UAAU,SAAS,GAAG,CAAC;QAClC;AACA,gBAAQ,SAAQ,EAAI,mBAAmB,aAAa,CAAC,eAAgB,GAAG,iBAAiB,IAAI;AAG7F,eAAO,0BAAyB;AAChC,eAAO,gBAAgB,eAAe;AACtC,YAAI,iBAAiB;AACjB,0BAAgB,QAAO;;AAI3B,wBAAgB,YAAY,eAAe;AAG3C,wBAAgB,UAAU;MAC9B,CAAC;IACL;AAEA,QAAI,eAAe;AACf,UAAI,SAAS;AACT,0BAAiB;aACd;AACH,gBAAQ,iBAAiB,QAAQ,iBAAiB;;;EAG9D;;;;;;;;EASO,OAAO,oBAAoB,iBAAkC,OAAc,oBAAoB,GAAA;AAClG,WAAO,iBAAiB,cAAc,iBAAiB,OAAO,mBAAmB,GAAA,CAAA;EACrF;;;;AChHJ,IAAM,sBAAN,MAAyB;EAMrB,YAAmBC,QAAc,oBAA6B,mBAA4B,mBAA0B;AAChH,SAAK,OAAOA;AACZ,SAAK,qBAAqB;AAC1B,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;EAC7B;;AAOE,IAAO,oCAAP,MAAwC;;;;;;;;EAsBnC,OAAO,2CAA2C,SAAoB;AAlDjF;AAmDQ,QAAI,CAAC,QAAQ,QAAQ;AAEjB,aAAO;;AAGX,kBAAQ,SAAQ,MAAhB,mBAAoB,YAAY;AAEhC,UAAM,OAAO,QAAQ,QAAO,EAAG;AAC/B,UAAM,eAAe,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;AACtE,UAAM,cAAc,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;AAErE,QAAI;AACJ,QAAI;AACJ,QAAI,QAAQ,gBAAgB;AACxB,kBAAY,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;AAC7D,oBAAc,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;WAC5D;AACH,kBAAY,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;AAC7D,oBAAc,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;;AAGnE,UAAM,eAAe,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;AACtE,UAAM,cAAc,QAAQ,WAAW,GAAG,QAAW,QAAW,KAAK;AAErE,UAAM,aAAa,QAAQ;AAE3B,UAAM,SAAS;AACf,QAAI,OAAO;AACX,QAAI,QAAQ,eAAe,KAAA,QAAU,eAAiB,GAAI;AACtD,aAAO;;AAGX,WAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,cAAQ,IAAI,CAAC,aAAa,cAAc,WAAW,aAAa,cAAc,WAAW,CAAC,EAAE,KAAK,CAAC,CAAC,MAAM,OAAO,IAAI,MAAM,OAAO,IAAI,MAAK;AACtI,cAAM,WAAwB;UAC1B;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;AAGJ,gBAAQ,KAAK,oCAAoC,QAAQ,CAAC;MAC9D,CAAC;IACL,CAAC;EACL;;;;;;;;EASQ,OAAO,aAAa,GAAW,GAAS;AAC5C,WAAO,KAAK,MAAM,IAAI,GAAG,KAAK,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC;EACzD;;;;;;;;EASO,OAAO,oCAAoC,UAAqB;AACnE,UAAM,qBAAqB,IAAI,mBAAkB;AACjD,QAAI,kBAAkB;AAGtB,UAAM,KAAK,IAAM,SAAS;AAC1B,UAAM,KAAK;AAEX,UAAM,YAAY,MAAM;AAGxB,UAAM,QAAQ,YAAY;AAE1B,aAAS,YAAY,GAAG,YAAY,GAAG,aAAa;AAChD,YAAM,WAAW,KAAK,WAAW,SAAS;AAC1C,YAAM,YAAkB,SAAU,SAAS,IAAI;AAC/C,UAAI,IAAI;AAKR,YAAM,SAAS,SAAS,WAAW,IAAA,IAAA;AACnC,eAAS,IAAI,GAAG,IAAI,SAAS,MAAM,KAAK;AACpC,YAAI,IAAI;AAER,iBAAS,IAAI,GAAG,IAAI,SAAS,MAAM,KAAK;AAEpC,gBAAM,iBAAiB,SAAS,kBAAkB,MAAM,CAAC,EAAE,IAAI,SAAS,kBAAkB,MAAM,CAAC,CAAC,EAAE,IAAI,SAAS,kBAAkB;AACnI,yBAAe,UAAS;AAExB,gBAAM,kBACF,KAAK,aAAa,IAAI,WAAW,IAAI,SAAS,IAC9C,KAAK,aAAa,IAAI,WAAW,IAAI,SAAS,IAC9C,KAAK,aAAa,IAAI,WAAW,IAAI,SAAS,IAC9C,KAAK,aAAa,IAAI,WAAW,IAAI,SAAS;AAElD,cAAI,IAAI,UAAU,IAAI,SAAS,OAAO,SAAS,IAAI,SAAS,CAAC;AAC7D,cAAI,IAAI,UAAU,IAAI,SAAS,OAAO,SAAS,IAAI,SAAS,CAAC;AAC7D,cAAI,IAAI,UAAU,IAAI,SAAS,OAAO,SAAS,IAAI,SAAS,CAAC;AAG7D,cAAI,MAAM,CAAC,GAAG;AACV,gBAAI;;AAER,cAAI,MAAM,CAAC,GAAG;AACV,gBAAI;;AAER,cAAI,MAAM,CAAC,GAAG;AACV,gBAAI;;AAIR,cAAI,SAAS,SAAS,GAAA;AAClB,iBAAK;AACL,iBAAK;AACL,iBAAK;;AAIT,cAAI,SAAS,YAAY;AACrB,gBAAI,KAAK,IAAI,OAAO,MAAM,CAAC,GAAG,aAAa;AAC3C,gBAAI,KAAK,IAAI,OAAO,MAAM,CAAC,GAAG,aAAa;AAC3C,gBAAI,KAAK,IAAI,OAAO,MAAM,CAAC,GAAG,aAAa;;AAK/C,gBAAM,MAAM,KAAK;AACjB,cAAI,KAAK,yBAAyB;AAC9B,kBAAM,aAAa,KAAK,IAAI,GAAG,GAAG,CAAC;AACnC,gBAAI,aAAa,KAAK;AAClB,oBAAM,SAAS,MAAM;AACrB,mBAAK;AACL,mBAAK;AACL,mBAAK;;iBAEN;AACH,gBAAI,OAAO,MAAM,GAAG,GAAG,GAAG;AAC1B,gBAAI,OAAO,MAAM,GAAG,GAAG,GAAG;AAC1B,gBAAI,OAAO,MAAM,GAAG,GAAG,GAAG;;AAG9B,gBAAM,QAAQ,IAAI,OAAO,GAAG,GAAG,CAAC;AAEhC,6BAAmB,SAAS,gBAAgB,OAAO,eAAe;AAElE,6BAAmB;AAEnB,eAAK;;AAGT,aAAK;;;AAKb,UAAM,mBAAmB,IAAM,KAAK;AAGpC,UAAM,iBAAiB;AACvB,UAAM,qBAAsB,mBAAmB,iBAAkB;AAMjE,UAAM,mBAAmB,qBAAqB;AAC9C,uBAAmB,aAAa,gBAAgB;AAEhD,uBAAmB,oCAAmC;AACtD,uBAAmB,sCAAqC;AAExD,WAAO,oBAAoB,cAAc,kBAAkB;EAC/D;;AA7Me,kCAAA,aAAoC;EAC/C,IAAI,oBAAoB,SAAS,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,EAAE,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;EACnG,IAAI,oBAAoB,QAAQ,IAAI,QAAQ,IAAI,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;EAClG,IAAI,oBAAoB,MAAM,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,CAAC;EAC9F,IAAI,oBAAoB,QAAQ,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,EAAE,CAAC;EAClG,IAAI,oBAAoB,SAAS,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;EAClG,IAAI,oBAAoB,QAAQ,IAAI,QAAQ,GAAG,GAAG,EAAE,GAAG,IAAI,QAAQ,IAAI,GAAG,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;;;AAIzF,kCAAA,iBAAiB;AAEjB,kCAAA,0BAA0B;;;ACnB5C,YAAY,UAAU,qCAAqC,WAAA;AACvD,MAAI,KAAK,UAAU;AACf,SAAK,SAAS,uBAAuB;AACrC,SAAK,SAAS,8BAA8B;AAC5C,SAAK,SAAS,+BAA+B;;AAErD;AAEA,OAAO,eAAe,YAAY,WAAW,uBAAuB;EAChE,KAAK,WAAA;AACD,QAAI,KAAK,UAAU;AACf,UAAI,KAAK,SAAS,wBAAwB,KAAK,SAAS,8BAA8B;AAClF,eAAO,KAAK,SAAS;;AAGzB,UAAI,KAAK,SAAS,SAAS;AACvB,YAAI,CAAC,KAAK,SAAS,6BAA6B;AAC5C,eAAK,SAAS,8BAA8B,kCAAkC,2CAA2C,IAAI;AAC7H,cAAI,KAAK,SAAS,gCAAgC,MAAM;AACpD,iBAAK,SAAS,+BAA+B;iBAC1C;AACH,iBAAK,SAAS,4BAA4B,KAAK,CAAC,wBAAuB;AACnE,mBAAK,SAAU,uBAAuB;AACtC,mBAAK,SAAU,+BAA+B;YAClD,CAAC;;;AAIT,eAAO;;;AAIf,WAAO;EACX;EACA,KAAK,SAA6B,OAAoC;AAClE,QAAI,KAAK,UAAU;AACf,WAAK,SAAS,uBAAuB;;EAE7C;EACA,YAAY;EACZ,cAAc;CACjB;;;AC3DD,IAAMC,SAAO;AACb,IAAMC,WAAS;;;;;AAMf,YAAY,aAAaD,MAAI,IAAIC;;;ACajC,IAAM,qCAAqC;AAC3C,IAAM,iBAAiB;AAmIvB,IAAM,aAAa,CAAC,KAAM,IAAM,KAAM,KAAM,KAAM,KAAM,KAAM,EAAI;AAO5D,SAAU,WAAW,MAAqB;AAC5C,QAAM,WAAW,IAAI,SAAS,KAAK,QAAQ,KAAK,YAAY,KAAK,UAAU;AAC3E,MAAI,MAAM;AAEV,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,QAAI,SAAS,SAAS,KAAK,MAAM,WAAW,CAAC,GAAG;AAC5C,aAAO,MAAM,+BAA+B;AAC5C,aAAO;;;AAKf,MAAI,iBAAiB;AACrB,MAAI,WAAW;AACf,SAAQ,WAAW,SAAS,SAAS,KAAK,GAAI;AAC1C,sBAAkB,OAAO,aAAa,QAAQ;;AAGlD,MAAI,WAAmC,KAAK,MAAM,cAAc;AAChE,aAAW,iBAAiB,QAAQ;AACpC,MAAI,SAAS,UAAU;AAEnB,aAAS,SAAS,uBAAuB;AAEzC,aAAS,SAAS,qBAAqB,SAAS,SAAS,sBAAsB;;AAGnF,SAAO;AACX;AAQM,SAAU,iBAAiB,MAA4B;AACzD,MAAI,KAAK,UAAU,gBAAgB;AAC/B,UAAM,IAAI,MAAM,gDAAgD,KAAK,OAAO,mCAAmC,cAAc,IAAI;;AAGrI,MAAI,KAAK,YAAY,GAAG;AACpB,WAAO;;AAIX,SAAO,EAAE,GAAG,MAAM,SAAS,GAAG,WAAW,mCAAkC;AAE3E,SAAO;AACX;AAUA,eAAsB,sBAAsB,SAAsB,UAAmC,CAAA,GAAE;AA5NvG;AA6NI,QAAM,kBAAkB,QAAQ,mBAAkB;AAClD,MAAI,CAAC,iBAAiB;AAClB,WAAO,QAAQ,OAAO,8BAA8B;;AAGxD,QAAM,YAAY,QAAQ,aAAa;AAEvC,QAAM,SAAS,gBAAgB,UAAS;AAExC,MACI,QAAQ,gBAAgB,KACxB,QAAQ,gBAAgB,KACxB,QAAQ,gBAAgB,KACxB,QAAQ,gBAAgB,KACxB,QAAQ,gBAAgB,KACxB,QAAQ,gBAAgB,IAC1B;AACE,WAAO,QAAQ,OAAO,+DAA+D;;AAGzF,MAAI,cAAc;AAClB,MAAI,CAAC,OAAO,QAAO,EAAG,oBAAoB;AACtC,kBAAc;AACd,QAAI,CAAC,OAAO,QAAO,EAAG,wBAAwB;AAC1C,aAAO,QAAQ,OAAO,+FAA+F;;;AAK7H,UAAQ;AAGR,QAAM,8BAA6B,aAAQ,mBAAkB,MAA1B,mBAA8B;AAEjE,QAAM,YAAY,gBAAgB;AAClC,QAAM,eAAe,IAAI,MAAM,MAAM;AACrC,QAAM,mBAAmD,CAAA;AAGzD,SAAO,iBAAgB;AAGvB,QAAM,eAAe,OAAO,MAAM,gBAAgB,KAAK;AACvD,WAAS,IAAI,GAAG,KAAK,cAAc,KAAK;AACpC,UAAM,YAAY,KAAK,IAAI,GAAG,eAAe,CAAC;AAG9C,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,UAAI,WAAW,MAAM,QAAQ,WAAW,MAAM,GAAG,QAAW,KAAK;AACjE,UAAI,YAAY,SAAS,eAAgB,SAAwB,QAAQ;AACrE,cAAM,gBAAgB,IAAI,aAAa,SAAU,aAAa,CAAC;AAC/D,iBAASC,KAAI,GAAGA,KAAI,SAAS,YAAYA,MAAK;AAC1C,wBAAcA,EAAC,IAAK,SAAwBA,EAAC,IAAI;AAEjD,wBAAcA,EAAC,IAAI,KAAK,IAAI,cAAcA,EAAC,GAAG,GAAG;;AAErD,mBAAW;iBACJ,YAAY,QAAQ,YAAY;AACvC,cAAM,YAAY;AAClB,iBAASA,KAAI,GAAGA,KAAI,UAAU,QAAQA,MAAK;AAEvC,oBAAUA,EAAC,IAAI,KAAK,IAAI,UAAUA,EAAC,GAAG,GAAG;;;AAIjD,YAAM,cAAc,OAAO,iBACvB,UACA,WACA,WACA,GAAA,OAAU,MAAA,GAAA,MAAA,WACL;AAOT,YAAM,iBAAiB,oBAAoB,aAAa,cAAc,WAAW;AAEjF,YAAM,kBAAkB,MAAM,OAAO,mBAAmB,aAAa,WAAW,SAAS;AAEzF,YAAM,mBAAmB,MAAM,UAAU,cAAc,WAAW,WAAW,iBAAiB,WAAW,QAAW,OAAO,MAAM,QAAQ,YAAY;AAErJ,uBAAiB,IAAI,IAAI,IAAI,IAAI;AAEjC,kBAAY,QAAO;;;AAK3B,eAAa,QAAO;AAGpB,MAAI,4BAA4B;AAC5B,UAAM;;AAIV,QAAM,OAA+B;IACjC,SAAS;IACT,OAAO;IACP;IACA,YAAY,4BAA4B,OAAO;IAC/C,UAAU;MACN,SAAS,CAAA;MACT,oBAAoB,QAAQ;;;AAKpC,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,KAAK,cAAc,KAAK;AACpC,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,YAAM,aAAa,iBAAiB,IAAI,IAAI,IAAI,EAAE;AAClD,WAAK,SAAS,QAAQ,KAAK;QACvB,QAAQ;QACR;OACH;AACD,kBAAY;;;AAKpB,QAAM,aAAa,KAAK,UAAU,IAAI;AACtC,QAAM,aAAa,IAAI,YAAY,WAAW,SAAS,CAAC;AACxD,QAAM,WAAW,IAAI,WAAW,UAAU;AAC1C,WAAS,IAAI,GAAG,SAAS,WAAW,QAAQ,IAAI,QAAQ,KAAK;AACzD,aAAS,CAAC,IAAI,WAAW,WAAW,CAAC;;AAGzC,WAAS,WAAW,MAAM,IAAI;AAG9B,QAAM,YAAY,WAAW,SAAS,WAAW,WAAW;AAC5D,QAAM,cAAc,IAAI,YAAY,SAAS;AAC7C,QAAM,kBAAkB,IAAI,WAAW,WAAW;AAClD,QAAM,WAAW,IAAI,SAAS,WAAW;AAGzC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,aAAS,SAAS,OAAO,WAAW,CAAC,CAAC;;AAI1C,kBAAgB,IAAI,IAAI,WAAW,UAAU,GAAG,GAAG;AACnD,SAAO,WAAW;AAGlB,WAAS,IAAI,GAAG,KAAK,cAAc,KAAK;AACpC,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,YAAM,aAAa,iBAAiB,IAAI,IAAI,IAAI;AAChD,sBAAgB,IAAI,IAAI,WAAW,UAAU,GAAG,GAAG;AACnD,aAAO,WAAW;;;AAK1B,SAAO;AACX;AAOA,SAAS,4BAA4B,SAAoB;AACrD,QAAM,aAAa,QAAQ;AAC3B,MAAI,cAAc,MAAM;AACpB,WAAO;;AAGX,SAAO;IACH,GAAG,CAAC,WAAW,EAAE,GAAG,WAAW,EAAE,GAAG,WAAW,EAAE,CAAC;IAClD,GAAG,CAAC,WAAW,EAAE,GAAG,WAAW,EAAE,GAAG,WAAW,EAAE,CAAC;IAClD,GAAG,CAAC,WAAW,EAAE,GAAG,WAAW,EAAE,GAAG,WAAW,EAAE,CAAC;IAElD,IAAI,CAAC,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,CAAC;IACtD,IAAI,CAAC,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,CAAC;IACtD,IAAI,CAAC,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,CAAC;IAEtD,IAAI,CAAC,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,CAAC;IACtD,IAAI,CAAC,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,CAAC;IACtD,IAAI,CAAC,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,CAAC;;AAE9D;AAQM,SAAU,gCAAgC,MAAuB,MAA4B;AAC/F,SAAO,iBAAiB,IAAI;AAE5B,QAAM,eAAe,KAAK;AAG1B,MAAI,eAAe,OAAO,KAAK,KAAK,KAAK;AACzC,iBAAe,KAAK,MAAM,YAAY,IAAI;AAC1C,MAAI,aAAa,QAAQ,WAAW,IAAI,cAAc;AAClD,UAAM,IAAI,MAAM,wCAAwC,aAAa,QAAQ,MAAM,GAAG;;AAG1F,QAAM,YAAY,IAAI,MAA8B,YAAY;AAChE,WAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACnC,cAAU,CAAC,IAAI,IAAI,MAAuB,CAAC;AAC3C,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,YAAM,YAAY,aAAa,QAAQ,IAAI,IAAI,IAAI;AACnD,gBAAU,CAAC,EAAE,IAAI,IAAI,IAAI,WAAW,KAAK,QAAQ,KAAK,aAAa,aAAa,uBAAwB,UAAU,UAAU,UAAU,MAAM;;;AAIpJ,SAAO;AACX;AASM,SAAU,qBAAqB,SAA0B,MAAuB,MAA4B;AAC9G,SAAO,iBAAiB,IAAI;AAE5B,QAAM,eAAe,KAAK;AAC1B,MAAI,CAAC,cAAc;AAEf,WAAO,QAAQ,QAAO;;AAG1B,UAAQ,sBAAsB,aAAa;AAE3C,QAAM,YAAY,gCAAgC,MAAM,IAAI;AAE5D,SAAO,kBAAkB,SAAS,WAAW,KAAK,SAAS;AAC/D;AAEA,SAAS,mBACL,OACA,QACA,eACA,iBACA,KACA,MACA,GACA,wBACA,aACA,SACA,SAAwB;AAExB,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,QAAI,eAAe;AACf,YAAM,cAAc,OAAO,cACvB,MACA,MACA,MACA,MACA,GAAA,MAAS,CAAC,YAAA;AAGN,eAAO,OAAO;MAClB,GACA,KAAK;AAGT,sBAAiB,UAAS,EAAG,oBAAoB,MAAK;AAElD,wBAAiB,gCAAgC;AACjD,wBAAiB,UAAU,CAAC,WAAU;AAClC,iBAAO,aAAa,kBAAkB,WAAW;AACjD,iBAAO,UAAU,SAAS,GAAG,OAAO,UAAU,wBAAwB,iBAAiB,cAAc,KAAK,CAAC;QAC/G;AAEA,YAAI,CAAC,OAAO,OAAO,QAAQ;AACvB;;AAGJ,eAAO,OAAO,CAAC,EAAE,mBAAmB,aAAa,CAAC,eAAgB,GAAG,SAAS,MAAM,MAAM,CAAC;AAG3F,eAAO,0BAAyB;AAChC,oBAAY,QAAO;AACnB,YAAI,gBAAgB,GAAG;AACvB,gBAAO;MACX,CAAC;WACE;AACH,aAAO,sBAAsB,SAAS,OAAO,MAAM,CAAC;AAGpD,UAAI,wBAAwB;AACxB,cAAM,aAAa,YAAa,CAAC;AACjC,YAAI,YAAY;AACZ,iBAAO,sBAAsB,WAAW,UAAW,OAAO,MAAM,CAAC;;;AAGzE,cAAO;;EAEf,CAAC;AACL;AASM,SAAU,kBAAkB,SAA0B,WAAgC,YAAoB,oCAAkC;AAC9I,MAAI,CAAC,MAAM,gBAAgB,QAAQ,KAAK,GAAG;AACvC,UAAM,IAAI,MAAM,qCAAqC;;AAGzD,QAAM,eAAe,OAAO,MAAM,QAAQ,KAAK,IAAI;AAGnD,QAAM,SAAS,QAAQ,UAAS;AAChC,MAAI,gBAAgB;AACpB,MAAI,yBAAyB;AAC7B,MAAI,kBAAyC;AAC7C,MAAI,UAAyC;AAC7C,MAAI,cAAwD;AAC5D,QAAM,OAAO,OAAO,QAAO;AAE3B,UAAQ,SAAS;AACjB,UAAQ,OAAO;AACf,UAAQ,kBAAkB;AAC1B,UAAQ,mCAAmC;AAC3C,SAAO,0BAA0B,GAAA,OAAU;AAG3C,MAAI,CAAC,KAAK,YAAY;AAClB,oBAAgB;AAChB,6BAAyB;AACzB,kBAAc,CAAA;aAGT,CAAC,OAAO,UAAU,2CAA2C;AAClE,oBAAgB;aAGX,KAAK,0BAA0B,KAAK,iCAAiC;AAC1E,oBAAgB;AAChB,YAAQ,OAAO;aAGV,KAAK,sBAAsB,KAAK,6BAA6B;AAClE,oBAAgB;AAChB,YAAQ,OAAO;;AAInB,MAAI,eAAe;AAEf,sBAAkB,IAAI,YAClB,cACA,cACA,MACA,MACA,GACA,MACA,GAAA,QAAU,OAAA,QAAA,QAAA,MACV,QACA,MACA,KAAA;AAOJ,YAAQ,UAAU;AAClB,YAAQ,UAAU;AAClB,cAAU,OAAO,8BAA8B,QAAQ,OAAO;MAC1D,qBAAqB;MACrB,iBAAiB;MACjB,uBAAuB;MACvB,cAAc;MACd,MAAM,QAAQ;MACd,QAAQ;KACX;SACE;AACH,YAAQ,UAAU;AAClB,YAAQ,UAAU;AAGlB,QAAI,wBAAwB;AACxB,YAAM,YAAY;AAClB,YAAM,QAAQ,QAAQ;AACtB,YAAM,SAAS,QAAQ;AAEvB,eAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAEhC,cAAM,aAAa,KAAK,YAAY;AACpC,cAAM,YAAY,IAAI;AAEtB,cAAM,cAAc;AACpB,cAAM,eAAe,eAAe,KAAK,QAAQ;AAEjD,cAAM,WAAW,eAAe,cAAc,eAAe;AAC7D,cAAM,cAAc,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,UAAU,CAAC,GAAG,WAAW,CAAC;AAE3E,cAAM,mBAAmB,IAAI,gBAAgB,QAAQ,sBAAsB,IAAI;AAC/E,yBAAiB,SAAS;AAC1B,yBAAiB,UAAU;AAC3B,yBAAiB,kBAAkB;AACnC,eAAO,0BAA0B,GAAA,gBAAU;AAG3C,cAAM,aAAa,IAAI,YAAY,IAAI;AACvC,mBAAW,UAAU;AACrB,mBAAW,WAAW;AACtB,oBAAa,WAAW,IAAI;AAE5B,gBAAQ,GAAG;UACP,KAAK;AACD,oBAAQ,iBAAiB;AACzB;UACJ,KAAK;AACD,oBAAQ,iBAAiB;AACzB;UACJ,KAAK;AACD,oBAAQ,kBAAkB;AAC1B;;;;;AAMpB,QAAM,WAA4B,CAAA;AAElC,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAEvC,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AAEjC,YAAM,QAAQ,UAAU,CAAC,EAAE,IAAI;AAC/B,YAAM,OAAO,IAAI,KAAK,CAAC,KAAK,GAAG,EAAE,MAAM,UAAS,CAAE;AAClD,YAAM,MAAM,IAAI,gBAAgB,IAAI;AACpC,UAAI;AAEJ,UAAI,OAAO,UAAU,iCAAiC;AAClD,kBAAU,OAAO,kBAAkB,MAAM,EAAE,kBAAkB,OAAM,CAAE,EAAE,KAAK,CAAC,QAAO;AAChF,iBAAO,mBAAmB,KAAK,QAAQ,eAAe,iBAAiB,KAAK,MAAM,GAAG,wBAAwB,aAAa,SAAS,OAAO;QAC9I,CAAC;aACE;AACH,cAAM,QAAQ,IAAI,MAAK;AACvB,cAAM,MAAM;AAGZ,kBAAU,IAAI,QAAc,CAAC,SAAS,WAAU;AAC5C,gBAAM,SAAS,MAAK;AAChB,+BAAmB,OAAO,QAAQ,eAAe,iBAAiB,KAAK,MAAM,GAAG,wBAAwB,aAAa,SAAS,OAAO,EAChI,KAAK,MAAM,QAAO,CAAE,EACpB,MAAM,CAAC,WAAU;AACd,qBAAO,MAAM;YACjB,CAAC;UACT;AACA,gBAAM,UAAU,CAAC,UAAS;AACtB,mBAAO,KAAK;UAChB;QACJ,CAAC;;AAEL,eAAS,KAAK,OAAO;;;AAK7B,MAAI,UAAU,SAAS,cAAc;AACjC,QAAI;AACJ,UAAM,OAAO,KAAK,IAAI,GAAG,eAAe,IAAI,UAAU,MAAM;AAC5D,UAAM,aAAa,OAAO,OAAO;AACjC,YAAQ,QAAQ,MAAM;MAClB,KAAK,GAAA;AACD,eAAO,IAAI,WAAW,UAAU;AAChC;;MAEJ,KAAK,GAAA;AACD,eAAO,IAAI,YAAY,UAAU;AACjC;;MAEJ,KAAK,GAAA;AACD,eAAO,IAAI,aAAa,UAAU;AAClC;;;AAGR,aAAS,IAAI,UAAU,QAAQ,IAAI,cAAc,KAAK;AAClD,eAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,eAAO,gCAAgC,SAAS,MAAO,MAAM,CAAC;;;;AAM1E,SAAO,QAAQ,IAAI,QAAQ,EAAE,KAAK,MAAK;AAEnC,QAAI,SAAS;AACT,aAAO,gBAAgB,OAAO;AAC9B,cAAQ,YAAY,OAAO;;AAG/B,QAAI,iBAAiB;AACjB,sBAAgB,QAAO;;AAG3B,QAAI,wBAAwB;AACxB,UAAI,QAAQ,mBAAmB,QAAQ,gBAAgB,UAAU;AAC7D,gBAAQ,gBAAgB,SAAS,UAAU;;AAE/C,UAAI,QAAQ,kBAAkB,QAAQ,eAAe,UAAU;AAC3D,gBAAQ,eAAe,SAAS,UAAU;;AAE9C,UAAI,QAAQ,kBAAkB,QAAQ,eAAe,UAAU;AAC3D,gBAAQ,eAAe,SAAS,UAAU;;;EAGtD,CAAC;AACL;AAOM,SAAU,mBAAmB,SAA0B,MAA4B;AACrF,SAAO,iBAAiB,IAAI;AAE5B,QAAM,iBAAiB,KAAK;AAC5B,MAAI,CAAC,gBAAgB;AACjB;;AAGJ,QAAM,KAAK,IAAI,oBAAmB;AAClC,UAAQ,eAAe,eAAe,GAAG,GAAG,GAAG,CAAC;AAChD,UAAQ,eAAe,eAAe,GAAG,GAAG,GAAG,CAAC;AAChD,UAAQ,eAAe,eAAe,GAAG,GAAG,GAAG,CAAC;AAChD,UAAQ,eAAe,eAAe,IAAI,GAAG,GAAG,EAAE;AAClD,UAAQ,eAAe,eAAe,IAAI,GAAG,GAAG,EAAE;AAClD,UAAQ,eAAe,eAAe,IAAI,GAAG,GAAG,EAAE;AAClD,UAAQ,eAAe,eAAe,IAAI,GAAG,GAAG,EAAE;AAClD,UAAQ,eAAe,eAAe,IAAI,GAAG,GAAG,EAAE;AAClD,UAAQ,eAAe,eAAe,IAAI,GAAG,GAAG,EAAE;AAClD,UAAQ,uBAAuB;AACnC;AAKM,SAAU,iBACZ,iBACA,MACA,qBACA,UACA,WAAiB;AAEjB,QAAM,QAAQ,gBACT,UAAS,EACT,qBACG,MACA,gBAAgB,OAChB,gBAAgB,QAChB,gBAAgB,MAChB,gBAAgB,iBAChB,gBAAgB,SAChB,gBAAgB,cAChB,gBAAgB,YAAY;AAEpC,QAAM,eAAe,kBAAkB,OAAO,IAAI,EAAE,KAAK,MAAM,eAAe;AAC9E,kBAAgB,oBAAoB,CAAC,qBAAoB;AACrD,WAAO;MACH,OAAO;MACP,SAAS;MACT,SAAS;;EAEjB;AACA,kBAAgB,UAAU,sBAAsB;AAChD,kBAAgB,wBAAwB;AACxC,kBAAgB,sBAAsB;AACtC,kBAAgB,uBAAuB;AACvC,kBAAgB,uBAAuB;AAEvC,SAAO,kBAAkB,iBAAiB,IAAI,EAAE,KAAK,MAAK;AACtD,oBAAgB,UAAU;AAC1B,WAAO;EACX,CAAC;AACL;AAOO,IAAM,0BAA0B;;;;;;EAMnC;;;;;;;;;EAUA;;;;;;;EAQA;;;;;;;;EASA;;;;;;;;EASA;;;;;;EAOA;;;;ACz1BE,SAAU,sBAAsB,YAAoB,aAAqB,OAAe,YAAkB;AAC5G,MAAI,UAAU,YACV,cAAc,GACd,cAAc;AAElB,SAAO,UAAU,MAAM,QAAQ;AAC3B,UAAM,WAAW,MAAM,OAAO,OAAO;AAErC,QAAI,CAAC,aAAa;AACd,cAAQ,UAAU;QACd,KAAK;AACD;AACA;QACJ,KAAK;AACD;AACA;QACJ,KAAK;QACL,KAAK;QACL,KAAK;AACD,wBAAc;AACd;QACJ,KAAK;AACD,cAAI,UAAU,IAAI,MAAM,QAAQ;AAC5B,kBAAM,WAAW,MAAM,OAAO,UAAU,CAAC;AACzC,gBAAI,aAAa,KAAK;AAClB,4BAAc;uBACP,aAAa,KAAK;AACzB,4BAAc;;;AAGtB;;WAEL;AACH,UAAI,aAAa,aAAa;AAC1B,YAAI,gBAAgB,OAAO,gBAAgB,KAAK;AAC5C,gBAAM,OAAO,UAAU,CAAC,MAAM,SAAS,cAAc;eAClD;AACH,wBAAc;;iBAEX,gBAAgB,QAAQ,aAAa,OAAO,UAAU,IAAI,MAAM,QAAQ;AAC/E,cAAM,OAAO,UAAU,CAAC,MAAM,QAAQ,cAAc;AACpD,YAAI,gBAAgB,IAAI;AACpB;;;;AAKZ;AACA,QAAI,gBAAgB,GAAG;AACnB;;;AAIR,SAAO,gBAAgB,IAAI,UAAU,IAAI;AAC7C;AAQM,SAAU,gBAAgB,GAAW,OAAa;AACpD,SAAO,QAAQ,EAAE,QAAQ;AACrB,UAAM,IAAI,EAAE,KAAK;AACjB,QAAI,MAAM,OAAO,MAAM,QAAQ,MAAM,QAAQ,MAAM,OAAQ,MAAM,QAAY,MAAM,KAAU;AACzF;;AAEJ;;AAGJ,SAAO;AACX;AAOM,SAAU,iBAAiB,GAAS;AACtC,QAAM,IAAI,EAAE,WAAW,CAAC;AACxB,SACK,KAAK,MAAM,KAAK;EAChB,KAAK,MAAM,KAAK;EAChB,KAAK,MAAM,KAAK;EACjB,KAAK;AAEb;AAOM,SAAU,eAAe,OAAa;AACxC,MAAI,UAAU,GACV,cAAc,IACd,aAAa;AACjB,QAAM,IAAI,CAAA;AAEV,SAAO,UAAU,MAAM,QAAQ;AAC3B,UAAM,WAAW,MAAM,OAAO,OAAO;AAErC,QAAI,CAAC,aAAa;AACd,cAAQ,UAAU;QACd,KAAK;QACL,KAAK;QACL,KAAK;AACD,wBAAc;AACd;QACJ,KAAK;AACD,cAAI,UAAU,IAAI,MAAM,QAAQ;AAC5B,kBAAM,WAAW,MAAM,OAAO,UAAU,CAAC;AACzC,gBAAI,aAAa,KAAK;AAClB,4BAAc;AACd,2BAAa;uBACN,aAAa,KAAK;AACzB,4BAAc;AACd,2BAAa;;;AAGrB;;AAER,UAAI,CAAC,YAAY;AACb,UAAE,KAAK,QAAQ;;WAEhB;AACH,UAAI,aAAa,aAAa;AAC1B,YAAI,gBAAgB,OAAO,gBAAgB,KAAK;AAC5C,gBAAM,OAAO,UAAU,CAAC,MAAM,SAAS,cAAc;AACrD,YAAE,KAAK,QAAQ;eACZ;AACH,wBAAc;AACd,uBAAa;;iBAEV,gBAAgB,QAAQ,aAAa,OAAO,UAAU,IAAI,MAAM,QAAQ;AAC/E,cAAM,OAAO,UAAU,CAAC,MAAM,QAAQ,cAAc;AACpD,YAAI,gBAAgB,IAAI;AACpB,uBAAa;AACb;;aAED;AACH,YAAI,CAAC,YAAY;AACb,YAAE,KAAK,QAAQ;;;;AAK3B;;AAGJ,SAAO,EAAE,KAAK,EAAE;AACpB;AAUM,SAAU,aAAa,GAAW,OAAe,GAAW,IAAW;AACzE,SAAO,SAAS,KAAK,EAAE,OAAO,KAAK,MAAM,MAAM,CAAC,MAAM,EAAE,OAAO,KAAK,MAAM,KAAK;AAC3E;;AAGJ,SAAO;AACX;AAOM,SAAU,aAAa,GAAS;AAClC,SAAO,EAAE,QAAQ,uBAAuB,MAAM;AAClD;;;AC3KM,IAAO,oBAAP,MAAO,mBAAiB;;EAc1B,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;;;;;;EAOA,YAAY,YAAoB,mBAAmB,IAAE;AAZ9C,SAAA,QAAiB;AAapB,SAAK,cAAc;AACnB,SAAK,oBAAoB;AACzB,SAAK,iBAAiB,CAAA;AACtB,SAAK,cAAc;EACvB;;;;EAKO,cAAW;AACd,QAAI,KAAK,OAAO;AACZ,aAAO,IAAI,qCAAqC,KAAK,YAAY,MAAM,MAAM;;AAEjF,SAAK,kBAAiB;AACtB,SAAK,iBAAiB,KAAK,iBAAiB;AAC5C,QAAI,KAAK,OAAO;AACZ,aAAO,IAAI,0BAA0B;;EAE7C;EAEQ,oBAAiB;AACrB,QAAI,aAAa;AAEjB,WAAO,aAAa,KAAK,YAAY,QAAQ;AAEzC,YAAM,mBAAmB,KAAK,YAAY,QAAQ,KAAK,aAAa,UAAU;AAC9E,UAAI,mBAAmB,GAAG;AACtB;;AAGJ,YAAM,uBAAuB,KAAK,YAAY,QAAQ,KAAK,mBAAmB,KAAK,YAAY,MAAM;AACrG,UAAI,uBAAuB,GAAG;AAC1B,YAAI,KAAK,OAAO;AACZ,iBAAO,KAAK,sEAAsE,UAAU,EAAE;;AAElG,qBAAa,mBAAmB,KAAK,YAAY;AACjD;;AAGJ,YAAM,gBAAgB,mBAAkB,+BAA+B,KACnE,KAAK,YAAY,UAAU,mBAAmB,KAAK,YAAY,QAAQ,oBAAoB,CAAC;AAEhG,UAAI,CAAC,eAAe;AAChB,YAAI,KAAK,OAAO;AACZ,iBAAO,KACH,yDAAyD,KAAK,YAAY,UAAU,mBAAmB,KAAK,YAAY,QAAQ,oBAAoB,CAAC,EAAE;;AAG/J,qBAAa,mBAAmB,KAAK,YAAY;AACjD;;AAEJ,YAAM,CAAC,UAAU,QAAQ,IAAI,CAAC,cAAc,CAAC,GAAG,cAAc,CAAC,CAAC;AAGhE,YAAM,qBAAqB,sBAAsB,KAAK,KAAK,KAAK,aAAa,oBAAoB;AACjG,UAAI,qBAAqB,GAAG;AACxB,YAAI,KAAK,OAAO;AACZ,iBAAO,KAAK,kDAAkD,QAAQ,WAAW,QAAQ,2BAA2B,oBAAoB,EAAE;;AAE9I,qBAAa,mBAAmB,KAAK,YAAY;AACjD;;AAEJ,YAAM,aAAa,KAAK,YAAY,UAAU,uBAAuB,GAAG,kBAAkB;AAG1F,YAAM,qBAAqB,gBAAgB,KAAK,aAAa,qBAAqB,CAAC;AACnF,UAAI,uBAAuB,KAAK,YAAY,QAAQ;AAChD,YAAI,KAAK,OAAO;AACZ,iBAAO,KAAK,+CAA+C,QAAQ,WAAW,QAAQ,yBAAyB,kBAAkB,EAAE;;AAEvI,qBAAa,mBAAmB,KAAK,YAAY;AACjD;;AAGJ,YAAM,mBAAmB,sBAAsB,KAAK,KAAK,KAAK,aAAa,kBAAkB;AAC7F,UAAI,mBAAmB,GAAG;AACtB,YAAI,KAAK,OAAO;AACZ,iBAAO,KAAK,+CAA+C,QAAQ,WAAW,QAAQ,yBAAyB,kBAAkB,EAAE;;AAEvI,qBAAa,mBAAmB,KAAK,YAAY;AACjD;;AAEJ,YAAM,WAAW,KAAK,YAAY,UAAU,oBAAoB,mBAAmB,CAAC;AAGpF,YAAM,SAAS,eAAe,UAAU,EAAE,MAAM,GAAG;AACnD,YAAM,aAAa,CAAA;AAEnB,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACpC,cAAM,QAAQ,OAAO,CAAC,EAAE,KAAI;AAC5B,cAAM,MAAM,MAAM,YAAY,GAAG;AAEjC,YAAI,OAAO,GAAG;AACV,qBAAW,KAAK,MAAM,UAAU,MAAM,CAAC,CAAC;;;AAIhD,UAAI,aAAa,QAAQ;AAErB,mBAAW,KAAK,QAAQ;;AAI5B,WAAK,eAAe,KAAK;QACrB,MAAM;QACN,MAAM;QACN,YAAY;QACZ,MAAM;QACN,WAAW;OACd;AAED,mBAAa,mBAAmB;AAGhC,YAAM,aAAa,mBAAmB,IAAI,KAAK,YAAY,UAAU,GAAG,gBAAgB,IAAI;AAC5F,YAAM,YAAY,mBAAmB,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,YAAY,UAAU,mBAAmB,CAAC,IAAI;AAE1H,WAAK,cAAc,aAAa;AAEhC,oBAAc,mBAAmB,IAAI;;AAGzC,QAAI,KAAK,OAAO;AACZ,aAAO,IAAI,sBAAsB,KAAK,eAAe,MAAM,mCAAmC,KAAK,cAAc,EAAE;;EAE3H;EAEQ,iBAAiB,mBAA2B,IAAE;AAClD,WAAO,sBAAsB,GAAG;AAC5B,UAAI,CAAC,KAAK,4BAA2B,GAAI;AACrC;;;AAIR,QAAI,KAAK,OAAO;AACZ,aAAO,IAAI,uBAAuB,gBAAgB,yBAAyB;;AAG/E,WAAO,oBAAoB;EAC/B;EAEQ,8BAA2B;AAC/B,QAAI,UAAU;AAEd,eAAW,QAAQ,KAAK,gBAAgB;AACpC,YAAM,EAAE,MAAAC,QAAM,MAAM,YAAY,KAAI,IAAK;AAEzC,UAAI,aAAa;AAEjB,aAAO,aAAa,KAAK,YAAY,QAAQ;AAEzC,cAAM,oBAAoB,KAAK,YAAY,QAAQA,QAAM,UAAU;AAEnE,YAAI,oBAAoB,GAAG;AACvB;;AAIJ,YAAI,sBAAsB,KAAK,iBAAiB,KAAK,YAAY,OAAO,oBAAoB,CAAC,CAAC,GAAG;AAC7F,uBAAa,oBAAoBA,OAAK;AACtC;;AAIJ,cAAM,uBAAuB,gBAAgB,KAAK,aAAa,oBAAoBA,OAAK,MAAM;AAC9F,YAAI,yBAAyB,KAAK,YAAY,UAAU,KAAK,YAAY,OAAO,oBAAoB,MAAM,KAAK;AAC3G,uBAAa,oBAAoBA,OAAK;AACtC;;AAIJ,cAAM,qBAAqB,sBAAsB,KAAK,KAAK,KAAK,aAAa,oBAAoB;AACjG,YAAI,qBAAqB,GAAG;AACxB,cAAI,KAAK,OAAO;AACZ,mBAAO,KAAK,oEAAoEA,MAAI,WAAW,IAAI,2BAA2B,oBAAoB,EAAE;;AAExJ,uBAAa,oBAAoBA,OAAK;AACtC;;AAEJ,cAAM,aAAa,KAAK,YAAY,UAAU,uBAAuB,GAAG,kBAAkB;AAM1F,cAAM,qBAAqB,CAAC,MAAa;AACrC,gBAAMC,cAAa,CAAA;AACnB,cAAI,SAAS,GACT,gBAAgB;AACpB,iBAAO,SAAS,EAAE,QAAQ;AACtB,gBAAI,EAAE,OAAO,MAAM,MAAM,KAAK;AAC1B,oBAAM,OAAO,sBAAsB,KAAK,KAAK,GAAG,MAAM;AACtD,kBAAI,OAAO,GAAG;AACV,uBAAO;;AAEX,uBAAS;uBACF,EAAE,OAAO,MAAM,MAAM,KAAK;AACjC,cAAAA,YAAW,KAAK,EAAE,UAAU,eAAe,MAAM,CAAC;AAClD,8BAAgB,SAAS;;AAE7B;;AAEJ,cAAI,gBAAgB,QAAQ;AACxB,YAAAA,YAAW,KAAK,EAAE,UAAU,eAAe,MAAM,CAAC;;AAEtD,iBAAOA;QACX;AAEA,cAAM,SAAS,mBAAmB,eAAe,UAAU,CAAC;AAE5D,YAAI,WAAW,MAAM;AACjB,cAAI,KAAK,OAAO;AACZ,mBAAO,KACH,uFAAuFD,MAAI,WAAW,IAAI,2BAA2B,oBAAoB,kBACrJ,UAAU;;AAGtB,uBAAa,oBAAoBA,OAAK;AACtC;;AAGJ,cAAM,aAAa,CAAA;AAEnB,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACpC,gBAAM,QAAQ,OAAO,CAAC,EAAE,KAAI;AAC5B,qBAAW,KAAK,KAAK;;AAGzB,cAAM,eAAe,SAAS,SAASA,SAAO,MAAM,KAAK,cAAc;AAEvE,YAAI,cAAc;AACd,qBAAW,KAAK,eAAe,IAAI;;AAGvC,YAAI,WAAW,WAAW,WAAW,QAAQ;AACzC,cAAI,KAAK,OAAO;AACZ,mBAAO,KACH,6HAA6HA,MAAI,WAAW,IAAI,0BAA0B,UAAU,qBAAqB,UAAU,EAAE;;AAG7N,uBAAa,oBAAoBA,OAAK;AACtC;;AAGJ,qBAAa,qBAAqB;AAGlC,cAAM,WAAW,KAAK,cAAc,MAAM,YAAY,UAAU;AAEhE,YAAI,aAAa,oBAAoB,IAAI,KAAK,YAAY,UAAU,GAAG,iBAAiB,IAAI;AAC5F,cAAM,YAAY,qBAAqB,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,YAAY,UAAU,qBAAqB,CAAC,IAAI;AAE9H,YAAI,cAAc;AAKd,gBAAM,yBAAyB,aAAa,KAAK,aAAa,oBAAoB,GAAG,MAAM,GAAG;AAE9F,uBAAa,KAAK,YAAY,UAAU,GAAG,yBAAyB,CAAC;AACrE,gBAAM,cAAc,KAAK,YAAY,UAAU,yBAAyB,GAAG,iBAAiB;AAE5F,eAAK,cAAc,aAAa,OAAO,MAAM,eAAe,QAAQ,WAAW,OAAO,cAAc,eAAe;AAEnH,cAAI,KAAK,OAAO;AACZ,mBAAO,IACH,4CAA4CA,MAAI,WAAW,IAAI,6BAA6B,sBAAsB,qBAAqB,UAAU,EAAE;;eAGxJ;AAEH,eAAK,cAAc,aAAa,WAAW;AAE3C,wBAAc,SAAS,UAAU,qBAAqB,IAAI;AAE1D,cAAI,KAAK,OAAO;AACZ,mBAAO,IAAI,4CAA4CA,MAAI,WAAW,IAAI,wBAAwB,iBAAiB,qBAAqB,UAAU,EAAE;;;AAI5J,kBAAU;;;AAIlB,WAAO;EACX;EAEQ,cAAc,MAAc,SAAmB,cAAsB;AACzE,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,YAAM,SAAS,IAAI,OAAO,aAAa,QAAQ,CAAC,CAAC,GAAG,GAAG,GACnD,YAAY,QAAQ,CAAC,EAAE,QACvB,cAAc,aAAa,CAAC;AAEhC,aAAO,KAAK,QAAQ,QAAQ,CAAC,UAAU,SAAQ;AAC3C,cAAM,SAAiB,KAAK,CAAC;AAE7B,YAAI,iBAAiB,KAAK,OAAO,SAAS,CAAC,CAAC,KAAK,iBAAiB,KAAK,OAAO,SAAS,SAAS,CAAC,GAAG;AAChG,iBAAO,QAAQ,CAAC;;AAEpB,eAAO;MACX,CAAC;;AAGL,WAAO;EACX;;AAvUwB,kBAAA,iCAAiC;;;ACPvD,IAAO,mBAAP,MAAO,kBAAgB;EAYzB,cAAA;AACI,UAAM,SAAS,IAAI,YAAY,kBAAiB,mBAAmB;AACnE,SAAK,WAAW,IAAI,YAAY,MAAM;AACtC,SAAK,UAAU,IAAI,WAAW,MAAM;AACpC,SAAK,YAAY,IAAI,aAAa,MAAM;AAExC,SAAK,UAAU,kBAAiB,sBAAsB;AACtD,SAAK,YAAY;AAEjB,SAAK,oBAAoB,IAAI,QAAQ,iBAAiB,MAAK;AACvD,WAAK,OAAM;IACf,CAAC;EACL;;;;;EAMO,YAAY,OAAa;AAC5B,SAAK,kBAAkB,CAAC;AACxB,SAAK,SAAS,KAAK,WAAW,IAAI;EACtC;;;;;EAMO,WAAW,OAAa;AAC3B,SAAK,kBAAkB,CAAC;AACxB,SAAK,QAAQ,KAAK,WAAW,IAAI;EACrC;;;;;EAMO,aAAa,OAAa;AAC7B,SAAK,kBAAkB,CAAC;AACxB,SAAK,UAAU,KAAK,WAAW,IAAI;EACvC;;;;;EAMO,iBAAiB,QAAmB;AACvC,SAAK,kBAAkB,IAAI,OAAO,MAAM;AACxC,SAAK,SAAS,KAAK,WAAW,IAAI,OAAO;AACzC,SAAK,SAAS,IAAI,QAAQ,KAAK,SAAS;AACxC,SAAK,aAAa,OAAO;EAC7B;;;;;EAMO,gBAAgB,QAAkB;AACrC,SAAK,kBAAkB,IAAI,OAAO,MAAM;AACxC,SAAK,SAAS,KAAK,WAAW,IAAI,OAAO;AACzC,SAAK,QAAQ,IAAI,QAAQ,KAAK,SAAS;AACvC,SAAK,aAAa,OAAO;EAC7B;;;;;EAMO,kBAAkB,QAAoB;AACzC,SAAK,kBAAkB,IAAI,OAAO,MAAM;AACxC,SAAK,SAAS,KAAK,WAAW,IAAI,OAAO;AACzC,SAAK,UAAU,IAAI,QAAQ,KAAK,SAAS;AACzC,SAAK,aAAa,OAAO;EAC7B;;;;;EAMO,gBAAgB,QAAkB;AACrC,SAAK,kBAAkB,OAAO,MAAM;AACpC,SAAK,SAAS,IAAI,QAAQ,KAAK,SAAS;AACxC,SAAK,aAAa,OAAO;EAC7B;;;;;EAMO,aAAa,OAAc;AAC9B,SAAK,YAAY,QAAQ,IAAI,CAAC;EAClC;EAEQ,kBAAkB,UAAgB;AACtC,QAAI,KAAK,YAAY,WAAW,KAAK,SAAS;AAC1C,WAAK,OAAM;;EAEnB;EAEQ,SAAM;AACV,SAAK,kBAAkB,YAAY,KAAK,SAAS,QAAQ,KAAK,SAAS;AACvE,SAAK,YAAY;EACrB;;AAvGwB,iBAAA,sBAAsB;;;ACX5C,IAAO,wBAAP,MAA4B;EAQ9B,IAAW,UAAO;AACd,QAAI,KAAK,kBAAkB;AACvB,YAAM,UAAU,KAAK,iBAAiB;AACtC,YAAM,IAAI,MAAM,kBAAkB,OAAO,YAAY,WAAW,OAAO,UAAU,GAAG;;AAExF,WAAO,KAAK;EAChB;EAIO,uBAAoB;AACvB,WAAO;EACX;EAEO,yBAAsB;AACzB,WAAO;EACX;EAMA,YAAY,QAAsB,SAAgB;AA7B3C,SAAA,aAAsB;AA0BrB,SAAA,cAAsC,CAAA;AAI1C,SAAK,UAAU;AACf,SAAK,UAAU;EACnB;EAEO,uBACH,QACA,qBACA,eACA,UACA,aACA,UACA,iBACA,YAAoB;AAEpB,UAAM,SAAS,KAAK;AACpB,QAAI,OAAO,wBAAwB;AAC/B,iBAAWE,UAAQ,qBAAqB;AACpC,eAAO,iBAAiBA,QAAM,oBAAoBA,MAAI,CAAC;;;AAI/D,UAAM,0BAA0B,KAAK,QAAQ,YAAY,MAAM,aAAa;AAC5E,4BAAwB,QAAQ,CAAC,SAASC,WAAS;AAC/C,eAAS,cAAcA,MAAK,CAAC,IAAI;IACrC,CAAC;AACD,SAAK,YAAY;AAEjB,QAAI;AACJ,SAAK,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACjD,YAAM,UAAU,OAAO,WAAW,YAAY,KAAK,CAAC;AACpD,UAAI,WAAW,MAAM;AACjB,oBAAY,OAAO,OAAO,CAAC;AAC3B;;;AAIR,gBAAY,QAAQ,CAACD,QAAMC,WAAS;AAChC,eAASD,MAAI,IAAIC;IACrB,CAAC;AAED,eAAW,KAAK,GAAG,OAAO,cAAc,MAAM,eAAe,CAAC;EAClE;;;;EAKO,UAAO;AACV,SAAK,YAAY,CAAA;EACrB;;;;EAKO,aAAa,aAAqB,QAAmB;AACxD,UAAM,QAAQ,KAAK,YAAY,WAAW;AAC1C,UAAM,OAAO,OAAO;AACpB,QAAI,UAAU,UAAa,UAAU,MAAM;AACvC,aAAO;;AAGX,SAAK,YAAY,WAAW,IAAI;AAEhC,WAAO;EACX;;;;EAKO,aAAa,aAAqB,GAAW,GAAS;AACzD,QAAI,QAAQ,KAAK,YAAY,WAAW;AACxC,QAAI,CAAC,OAAO;AACR,cAAQ,CAAC,GAAG,CAAC;AACb,WAAK,YAAY,WAAW,IAAI;AAChC,aAAO;;AAGX,QAAI,UAAU;AACd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAEd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAGd,WAAO;EACX;;;;EAKO,aAAa,aAAqB,GAAW,GAAW,GAAS;AACpE,QAAI,QAAQ,KAAK,YAAY,WAAW;AACxC,QAAI,CAAC,OAAO;AACR,cAAQ,CAAC,GAAG,GAAG,CAAC;AAChB,WAAK,YAAY,WAAW,IAAI;AAChC,aAAO;;AAGX,QAAI,UAAU;AACd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAEd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAEd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAGd,WAAO;EACX;;;;EAKO,aAAa,aAAqB,GAAW,GAAW,GAAW,GAAS;AAC/E,QAAI,QAAQ,KAAK,YAAY,WAAW;AACxC,QAAI,CAAC,OAAO;AACR,cAAQ,CAAC,GAAG,GAAG,GAAG,CAAC;AACnB,WAAK,YAAY,WAAW,IAAI;AAChC,aAAO;;AAGX,QAAI,UAAU;AACd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAEd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAEd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAEd,QAAI,MAAM,CAAC,MAAM,GAAG;AAChB,YAAM,CAAC,IAAI;AACX,gBAAU;;AAGd,WAAO;EACX;;;;;;EAOO,OAAO,aAAqB,OAAa;AAC5C,UAAM,QAAQ,KAAK,YAAY,WAAW;AAC1C,QAAI,UAAU,UAAa,UAAU,OAAO;AACxC;;AAGJ,QAAI,KAAK,QAAQ,OAAO,KAAK,UAAU,WAAW,GAAI,KAAK,GAAG;AAC1D,WAAK,YAAY,WAAW,IAAI;;EAExC;;;;;;;EAQO,QAAQ,aAAqB,GAAW,GAAS;AACpD,QAAI,KAAK,aAAa,aAAa,GAAG,CAAC,GAAG;AACtC,UAAI,CAAC,KAAK,QAAQ,QAAQ,KAAK,UAAU,WAAW,GAAG,GAAG,CAAC,GAAG;AAC1D,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;;EASO,QAAQ,aAAqB,GAAW,GAAW,GAAS;AAC/D,QAAI,KAAK,aAAa,aAAa,GAAG,GAAG,CAAC,GAAG;AACzC,UAAI,CAAC,KAAK,QAAQ,QAAQ,KAAK,UAAU,WAAW,GAAG,GAAG,GAAG,CAAC,GAAG;AAC7D,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;;;EAUO,QAAQ,aAAqB,GAAW,GAAW,GAAW,GAAS;AAC1E,QAAI,KAAK,aAAa,aAAa,GAAG,GAAG,GAAG,CAAC,GAAG;AAC5C,UAAI,CAAC,KAAK,QAAQ,QAAQ,KAAK,UAAU,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG;AAChE,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,YAAY,aAAqB,OAAiB;AACrD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,YAAY,KAAK,UAAU,WAAW,GAAI,KAAK;EAChE;;;;;;EAOO,aAAa,aAAqB,OAAiB;AACtD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,aAAa,KAAK,UAAU,WAAW,GAAI,KAAK;EACjE;;;;;;EAOO,aAAa,aAAqB,OAAiB;AACtD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,aAAa,KAAK,UAAU,WAAW,GAAI,KAAK;EACjE;;;;;;EAOO,aAAa,aAAqB,OAAiB;AACtD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,aAAa,KAAK,UAAU,WAAW,GAAI,KAAK;EACjE;;;;;;EAOO,QAAQ,aAAqB,OAAa;AAC7C,UAAM,QAAQ,KAAK,YAAY,WAAW;AAC1C,QAAI,UAAU,UAAa,UAAU,OAAO;AACxC;;AAGJ,QAAI,KAAK,QAAQ,QAAQ,KAAK,UAAU,WAAW,GAAI,KAAK,GAAG;AAC3D,WAAK,YAAY,WAAW,IAAI;;EAExC;;;;;;;EAQO,SAAS,aAAqB,GAAW,GAAS;AACrD,QAAI,KAAK,aAAa,aAAa,GAAG,CAAC,GAAG;AACtC,UAAI,CAAC,KAAK,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAG,GAAG,CAAC,GAAG;AAC3D,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;;EASO,SAAS,aAAqB,GAAW,GAAW,GAAS;AAChE,QAAI,KAAK,aAAa,aAAa,GAAG,GAAG,CAAC,GAAG;AACzC,UAAI,CAAC,KAAK,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAG,GAAG,GAAG,CAAC,GAAG;AAC9D,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;;;EAUO,SAAS,aAAqB,GAAW,GAAW,GAAW,GAAS;AAC3E,QAAI,KAAK,aAAa,aAAa,GAAG,GAAG,GAAG,CAAC,GAAG;AAC5C,UAAI,CAAC,KAAK,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG;AACjE,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,aAAa,aAAqB,OAAkB;AACvD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,aAAa,KAAK,UAAU,WAAW,GAAI,KAAK;EACjE;;;;;;EAOO,cAAc,aAAqB,OAAkB;AACxD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,cAAc,KAAK,UAAU,WAAW,GAAI,KAAK;EAClE;;;;;;EAOO,cAAc,aAAqB,OAAkB;AACxD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,cAAc,KAAK,UAAU,WAAW,GAAI,KAAK;EAClE;;;;;;EAOO,cAAc,aAAqB,OAAkB;AACxD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,cAAc,KAAK,UAAU,WAAW,GAAI,KAAK;EAClE;;;;;;EAOO,cAAc,aAAqB,OAAmB;AACzD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,cAAc,KAAK,UAAU,WAAW,GAAI,KAAK;EAClE;;;;;;EAOO,eAAe,aAAqB,OAAmB;AAC1D,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,eAAe,KAAK,UAAU,WAAW,GAAI,KAAK;EACnE;;;;;;EAOO,eAAe,aAAqB,OAAmB;AAC1D,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,eAAe,KAAK,UAAU,WAAW,GAAI,KAAK;EACnE;;;;;;EAOO,eAAe,aAAqB,OAAmB;AAC1D,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,eAAe,KAAK,UAAU,WAAW,GAAI,KAAK;EACnE;;;;;;EAOO,SAAS,aAAqB,OAAe;AAChD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAI,KAAK;EAC7D;;;;;;EAOO,UAAU,aAAqB,OAAe;AACjD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,KAAK;EAC9D;;;;;;EAOO,UAAU,aAAqB,OAAe;AACjD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,KAAK;EAC9D;;;;;;EAOO,UAAU,aAAqB,OAAe;AACjD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,KAAK;EAC9D;;;;;;EAOO,YAAY,aAAqB,UAAsB;AAC1D,QAAI,CAAC,UAAU;AACX;;AAGJ,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,YAAY,KAAK,UAAU,WAAW,GAAI,QAAQ;EACnE;;;;;;EAOO,UAAU,aAAqB,QAAmB;AACrD,QAAI,KAAK,aAAa,aAAa,MAAM,GAAG;AACxC,UAAI,CAAC,KAAK,QAAQ,YAAY,KAAK,UAAU,WAAW,GAAI,OAAO,QAAO,CAAkB,GAAG;AAC3F,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,aAAa,aAAqB,QAAoB;AACzD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,aAAa,KAAK,UAAU,WAAW,GAAI,MAAM;EAClE;;;;;;EAOO,aAAa,aAAqB,QAAoB;AACzD,SAAK,YAAY,WAAW,IAAI;AAChC,SAAK,QAAQ,aAAa,KAAK,UAAU,WAAW,GAAI,MAAM;EAClE;;;;;;EAOO,SAAS,aAAqB,OAAa;AAC9C,UAAM,QAAQ,KAAK,YAAY,WAAW;AAC1C,QAAI,UAAU,UAAa,UAAU,OAAO;AACxC;;AAGJ,QAAI,KAAK,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAI,KAAK,GAAG;AAC5D,WAAK,YAAY,WAAW,IAAI;;EAExC;;;;;;EAOO,QAAQ,aAAqB,MAAa;AAC7C,UAAM,QAAQ,KAAK,YAAY,WAAW;AAC1C,QAAI,UAAU,UAAa,UAAU,MAAM;AACvC;;AAGJ,QAAI,KAAK,QAAQ,OAAO,KAAK,UAAU,WAAW,GAAI,OAAO,IAAI,CAAC,GAAG;AACjE,WAAK,YAAY,WAAW,IAAI,OAAO,IAAI;;EAEnD;;;;;;EAOO,WAAW,aAAqB,SAAqB;AACxD,QAAI,KAAK,aAAa,aAAa,QAAQ,GAAG,QAAQ,CAAC,GAAG;AACtD,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,QAAQ,GAAG,QAAQ,CAAC,GAAG;AAC7E,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;EAQO,UAAU,aAAqB,GAAW,GAAS;AACtD,QAAI,KAAK,aAAa,aAAa,GAAG,CAAC,GAAG;AACtC,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,GAAG,CAAC,GAAG;AAC7D,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,WAAW,aAAqB,SAAqB;AACxD,QAAI,KAAK,aAAa,aAAa,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG;AACjE,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG;AACxF,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;;EASO,UAAU,aAAqB,GAAW,GAAW,GAAS;AACjE,QAAI,KAAK,aAAa,aAAa,GAAG,GAAG,CAAC,GAAG;AACzC,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,GAAG,GAAG,CAAC,GAAG;AAChE,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,WAAW,aAAqB,SAAqB;AACxD,QAAI,KAAK,aAAa,aAAa,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG;AAC5E,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG;AACnG,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,cAAc,aAAqB,YAA2B;AACjE,QAAI,KAAK,aAAa,aAAa,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,CAAC,GAAG;AACxF,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,CAAC,GAAG;AAC/G,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;;;EAUO,UAAU,aAAqB,GAAW,GAAW,GAAW,GAAS;AAC5E,QAAI,KAAK,aAAa,aAAa,GAAG,GAAG,GAAG,CAAC,GAAG;AAC5C,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,GAAG,GAAG,GAAG,CAAC,GAAG;AACnE,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,UAAU,aAAqB,QAAmB;AACrD,QAAI,KAAK,aAAa,aAAa,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC,GAAG;AAC9D,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC,GAAG;AACrF,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;;EAQO,UAAU,aAAqB,QAAqB,OAAa;AACpE,QAAI,KAAK,aAAa,aAAa,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,KAAK,GAAG;AACrE,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,KAAK,GAAG;AAC5F,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;;;EAOO,gBAAgB,aAAqB,QAAmB;AAC3D,QAAI,KAAK,aAAa,aAAa,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC,GAAG;AACxE,UAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,UAAU,WAAW,GAAI,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC,GAAG;AAC/F,aAAK,YAAY,WAAW,IAAI;;;EAG5C;;;;ACrqBE,IAAO,4BAAP,cAAyC,oBAAmB;EAQ9D,IAAW,eAAY;AACnB,WAAO,KAAK;EAChB;EAEA,IAAW,aAAa,aAAwC;AAC5D,QAAI,KAAK,eAAe;AACpB,WAAK,QAAQ,2BAA2B,KAAK,aAAa;;AAE9D,SAAK,gBAAgB;EACzB;EAEA,IAAW,2BAAwB;AAC/B,WAAO,KAAK;EAChB;EAEA,IAAW,yBAAyB,yBAAoD;AACpF,QAAI,KAAK,2BAA2B;AAChC,WAAK,QAAQ,2BAA2B,KAAK,yBAAyB;;AAE1E,SAAK,4BAA4B;EACrC;EAEA,YAAY,SAAkB,QAAiB,MAAmB,QAAoB;AAClF,UAAM,SAAS,QAAQ,MAAM,MAAM;AA3B/B,SAAA,gBAA6C;AAE7C,SAAA,4BAAyD;AA0B7D,SAAK,UAAU;EACnB;EAEO,QAAQ,0BAA0B,OAAK;AAC1C,SAAK,eAAe;AACpB,SAAK,2BAA2B;AAEhC,UAAM,QAAQ,uBAAuB;EACzC;;;;ACzCE,IAAO,wBAAP,MAA4B;EAI9B,IAAW,qBAAkB;AACzB,WAAO,KAAK;EAChB;EAEA,YAAY,iBAAgC,QAAqB;AAC7D,SAAK,UAAU;AACf,SAAK,IAAI,eAAe;EAC5B;EAEO,WAAQ;EAAU;EAElB,IAAI,iBAA8B;AACrC,SAAK,iBAAiB;EAC1B;EAEO,QAAK;AACR,SAAK,iBAAiB;EAC1B;EAEO,UAAO;AACV,QAAI,KAAK,gBAAgB;AACrB,WAAK,QAAQ,cAAc,KAAK,cAAc;;AAGlD,SAAK,MAAK;EACd;;;;AC3BE,SAAU,uBAAuB,QAAgB,MAAY;AAC/D,UAAQ,QAAQ;IAEZ,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAG1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAE1B,KAAK,GAAA;AACD,cAAQ,MAAM;QACV,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;;AAE9B;;IAEJ,KAAK,GAAA;AACD,cAAQ,MAAM;QACV,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;;AAE9B;;IAEJ,KAAK,GAAA;AACD,cAAQ,MAAM;QACV,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;;AAE9B;;IAEJ,KAAK,GAAA;AACD,cAAQ,MAAM;QACV,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;QAC1B,KAAK;AACD,iBAAO,QAAQ,OAAO;;AAE9B;;IAEJ,KAAK,IAAA;AACD,cAAQ,MAAM;QACV,KAAK;AACD,iBAAO,QAAQ,OAAO;;AAE9B;;;AAIR,QAAM,IAAI,aAAa,8CAA8C,MAAM,UAAU,IAAI,KAAK,WAAW,uBAAuB;AACpI;AAEM,SAAU,sBAAsB,cAAoB;AACtD,UAAQ,cAAc;IAClB,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,8BAA8B,YAAY,GAAG;;AAEzE;AAEM,SAAU,qBAAqB,UAAgB;AACjD,UAAQ,UAAU;IACd,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,2BAA2B,WAAW,GAAG;;AAErE;AAEM,SAAU,qBAAqB,MAAY;AAC7C,UAAQ,MAAM;IACV,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,kCAAkC,IAAI,GAAG;;AAErE;AAEM,SAAU,uBAAuB,QAAc;AACjD,UAAQ,QAAQ;IACZ,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,oCAAoC,MAAM,GAAG;;AAEzE;AAEM,SAAU,0BAA0B,WAAiB;AACvD,UAAQ,WAAW;IACf,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,uCAAuC,SAAS,GAAG;;AAE/E;AAEM,SAAU,0BAA0B,QAAc;AACpD,UAAQ,QAAQ;IACZ,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,oCAAoC,MAAM,GAAG;;AAEzE;AAEM,SAAU,mBAAmB,MAAY;AAC3C,UAAQ,MAAM;IACV,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B,KAAK;AACD,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,2BAA2B,IAAI,GAAG;;AAE9D;AAEM,SAAU,oBAAoB,MAAY;AAC5C,UAAQ,MAAM;IACV,KAAK,aAAa;AACd,aAAO,QAAQ,OAAO;IAC1B,KAAK,aAAa;AACd,aAAO,QAAQ,OAAO;IAC1B,KAAK,aAAa;AACd,aAAO,QAAQ,OAAO;IAC1B,KAAK,aAAa;AACd,aAAO,QAAQ,OAAO;IAC1B,KAAK,aAAa;AACd,aAAO,QAAQ,OAAO;IAC1B;AACI,YAAM,IAAI,MAAM,+BAA+B,IAAI,GAAG;;AAElE;;;AC9PA,IAAM,4BAA4B,IAAI,WAAU;AAChD,IAAI,OAAO,SAAS,eAAe,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,SAAS,GAAG;AACvF,MAAI;AACJ,SAAO,eAAe,MAAM,WAAW;IACnC,KAAK,MAAM;IACX,KAAK,CAAC,UAAkB;AACpB,iBAAW;AACX,UAAI,UAAU;AACV,kCAA0B,gBAAgB,QAAQ;;IAE1D;GACH;;AAOC,SAAU,2BAAwB;AACpC,SAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,QAAI,OAAO,YAAY,aAAa;AAChC,gCAA0B,QAAQ,CAAC,iBAAiB,QAAQ,YAAY,CAAC;WACtE;AACH,cAAQ,OAAO;;EAEvB,CAAC;AACL;AAMA,eAAsB,wBAA8B,UAAkB,aAAiB;AAClF,GAAC,MAAM,yBAAwB,GAAY,QAAQ,IAAI;AAC5D;AAKA,IAAM,mBAAN,cAA+B,WAAU;;AAuBzC,IAAM,uBAAN,MAA0B;EAKtB,YAAoC,SAAsB;AAAtB,SAAA,UAAA;AAHnB,SAAA,WAAW,IAAI,MAAK;AAC7B,SAAA,8BAA8B;AAGlC,SAAK,iBAAiB,aAAa,wBAAuB;AAC1D,SAAK,QAAQ,qBAAqB,KAAK,cAAc;EACzD;EAEO,oBAAiB;AACpB,QAAI,KAAK,6BAA6B;AAClC,YAAM,IAAI,MAAM,+BAA+B;;AAGnD,SAAK,8BAA8B;EACvC;EAEO,kBAAe;AAClB,QAAI,CAAC,KAAK,6BAA6B;AACnC,YAAM,IAAI,MAAM,8BAA8B;;AAGlD,SAAK,8BAA8B;AACnC,SAAK,QAAO;EAChB;EAEO,qBAAqB,SAAmB;AAC3C,SAAK,eAAe,gBAAgB,OAAO;EAC/C;EAEO,yBAAyB,YAAkB;AAC9C,SAAK,eAAe,YAAY,UAAU;EAC9C;EAEO,0BAA0B,YAAuB;AACpD,SAAK,eAAe,iBAAiB,UAAU;EACnD;EAEO,wBAAwB,YAAkB;AAC7C,SAAK,eAAe,WAAW,UAAU;EAC7C;EAEO,yBAAyB,YAAsB;AAClD,SAAK,eAAe,gBAAgB,UAAU;EAClD;EAEO,0BAA0B,YAAkB;AAC/C,SAAK,eAAe,aAAa,UAAU;EAC/C;EAEO,2BAA2B,YAAwB;AACtD,SAAK,eAAe,kBAAkB,UAAU;EACpD;EAEO,6BAA6B,YAAsB;AACtD,SAAK,eAAe,gBAAgB,UAAU;AAC9C,SAAK,SAAS,KAAK,UAAU;EACjC;EAEO,wBAAqB;AACxB,QAAI,CAAC,KAAK,6BAA6B;AACnC,WAAK,QAAO;;EAEpB;EAEQ,UAAO;AACX,SAAK,QAAQ,eAAc;AAC3B,SAAK,SAAS,SAAS;EAC3B;;AAIE,IAAO,eAAP,MAAO,sBAAqB,OAAM;EAuB7B,wBAAwB,OAAa;AACxC,UAAM,wBAAwB,KAAK;AACnC,SAAK,QAAQ,wBAAwB,KAAK;EAC9C;EAEA,YAAmB,UAA+B,CAAA,GAAE;AAChD,UAAM,MAAM,OAAO,QAAW,QAAQ,kBAAkB;AAzB3C,SAAA,UAAyB,IAAI,QAAQ,OAAM;AAC3C,SAAA,UAAmC,QAAQ,SAAS,IAAI,QAAQ,OAAM,IAAK;AAE3E,SAAA,wBAAwB,IAAI,qBAAqB,KAAK,OAAO;AAEtE,SAAA,2BAAgC;AAChC,SAAA,oBAA4B,QAAQ,OAAO;AAC3C,SAAA,eAAe;AACf,SAAA,eAAuB;AACvB,SAAA,eAAuB;AACvB,SAAA,kBAA0B;AAC1B,SAAA,mBAA2B;AAC3B,SAAA,wBAAgC;AAChC,SAAA,sBAA8B;AAC9B,SAAA,6BAAqC;AACrC,SAAA,WAAmB;AACnB,SAAA,gBAAwB;AACxB,SAAA,cAAuB;AAU3B,QAAI,QAAQ,OAAO,qBAAqB,cAAa,kBAAkB;AACnE,YAAM,IAAI,MAAM,8BAA8B,QAAQ,OAAO,gBAAgB,iBAAiB,cAAa,gBAAgB,OAAO;;AAGtI,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAC7B,SAAK,sBAAsB;AAK3B,SAAK,QAAQ;MACT,uBAAuB;MACvB,4BAA4B;MAC5B,+BAA+B;MAC/B,gBAAgB,QAAQ,OAAO;MAC/B,uBAAuB;MACvB,sBAAsB;MACtB,kBAAkB;MAClB,mBAAmB;MACnB,2BAA2B;MAC3B,yBAAyB;MACzB,qBAAqB;MACrB,MAAM;MACN,OAAO;MACP,MAAM;MACN,MAAM;MACN,MAAM;MACN,eAAe;MACf,aAAa;MACb,wBAAwB;MACxB,8BAA8B;MAC9B,kBAAkB;MAClB,6BAA6B;MAC7B,0BAA0B;MAC1B,cAAc;MACd,6BAA6B;MAC7B,oBAAoB;MACpB,kBAAkB;MAClB,iCAAiC;MACjC,wBAAwB;MACxB,YAAY;MACZ,YAAY;MACZ,sBAAsB;MACtB,uBAAuB;MACvB,mBAAmB;MACnB,iBAAiB;MACjB,uBAAuB;MACvB,8BAA8B;MAC9B,aAAa;MACb,gBAAgB;MAChB,oBAAoB;MACpB,kBAAkB;MAClB,uBAAuB;MACvB,oBAAoB;MACpB,2BAA2B;MAC3B,iBAAiB;MACjB,6BAA6B,QAAQ,OAAO;MAC5C,2BAA2B;MAC3B,uBAAuB,EAAE,uBAAuB,EAAC;;AAGrD,SAAK,YAAY;MACb,iCAAiC;MACjC,2CAA2C;MAC3C,4BAA4B;MAC5B,uBAAuB;MACvB,8BAA8B;MAC9B,0BAA0B;MAC1B,kBAAkB;MAClB,8BAA8B;MAC9B,YAAY;MACZ,eAAe;MACf,mBAAmB;MACnB,iCAAiC;MACjC,aAAa;MACb,cAAc;MACd,+BAA+B;MAC/B,2BAA2B;MAC3B,wBAAwB;MACxB,sBAAsB;MACtB,oBAAoB;MACpB,wBAAwB;MACxB,gCAAgC;MAChC,qBAAqB;MACrB,yBAAyB;MACzB,uCAAuC;MACvC,4BAA4B;;AAGhC,UAAM,IAAI,sBAAsB,OAAO,UAAU,YAAY;AAE7D,UAAM,aAAa,SAAU,WAAW,WAAW,SAAS,UAAQ;AAChE,YAAM,SACF,WACA,CAAC,SAAQ;AACL,iBAAS,IAAc,EAAE,MAAM,IAAI;AACnC,YAAI,WAAW;AACX,oBAAS;;MAEjB,GACA,QACA,QACA,OACA,CAAC,SAAS,cAAa;AACnB,YAAI,SAAS;AACT,kBAAQ,oBAAoB,SAAS;;MAE7C,CAAC;IAET;AAGA,QAAI,OAAO,QAAQ,aAAa;AAC3B,aAAO,MAAc;QAClB,iBAAiB,WAAA;QAAa;QAC9B,iBAAiB,WAAA;QAAa;;;AAItC,QAAI,OAAO,SAAS,aAAa;AAC5B,aAAO,OAAe,SAAU,GAAM;AACnC,eAAO;MACX;;AAIJ,QAAI,CAAC,MAAM,UAAU,MAAM;AACvB,aAAO,eAAe,MAAM,WAAW,QAAQ;QAC3C,cAAc;QACd,OAAO,SAAS,OAAI;AAChB,gBAAM,QAAQ,MAAM,UAAU,CAAC,CAAC,IAAI,IAAI,OAAO,UAAU,CAAC,CAAC;AAE3D,iBAAO,QACD,MAAM,UAAU,OAAO,KACnB,MACA,SAAU,KAAU,KAAQ;AACxB,gBAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,kBAAI,KAAK,MAAM,KAAK,KAAK,KAAK,KAAK,QAAQ,CAAC,CAAC;mBAC1C;AACH,kBAAI,KAAK,GAAG;;AAEhB,mBAAO;UACX,GACA,CAAA,CAAE,IAEN,MAAM,UAAU,MAAM,KAAK,IAAI;QACzC;QACA,UAAU;OACb;;AAKL,UAAM,mBAAmB,SAAS,OAAO,oBAAoB,IAAM;AACnE,SAAK,wBAAwB,QAAQ,qBAAqB,IAAM,mBAAmB;AACnF,SAAK,QAAQ,wBAAwB,KAAK,qBAAqB;AAC/D,SAAK,wBAAwB;AAC7B,SAAK,OAAM;AAEX,UAAM,uBAAuB,KAAK,iBAAgB;AAClD,QAAI,sBAAsB;AACtB,WAAK,iBAAiB,oBAAoB;;AAI9C,SAAK,mBAAmB,IAAI,sBAAqB;AAEjD,SAAK,0BAA0B,IAAI,CAAC,UAAS;AACzC,YAAM,iBAAiB,MAAM;AAC7B,YAAM,SAAS,IAAI,SAA2C;AAC1D,aAAK,sBAAsB,kBAAiB;AAC5C,uBAAe,MAAM,OAAO,IAAI;AAChC,aAAK,sBAAsB,gBAAe;MAC9C;IACJ,CAAC;EACL;EAEO,UAAO;AACV,UAAM,QAAO;AACb,QAAI,KAAK,0BAA0B;AAC/B,WAAK,mBAAmB,KAAK,wBAAwB;;AAEzD,SAAK,QAAQ,QAAO;EACxB;;EAGO,OAAO,0BAAuB;AACjC,WAAO,IAAI,iBAAgB;EAC/B;;;;;EAMU,eAAe,sBAA2B,WAAe;AAE/D,QAAI,UAAU,yBAAyB,cAAc,QAAQ;AACzD,gBAAU,sBAAsB,oBAAoB;WACjD;AACH,WAAK,QAAQ,sBAAsB,oBAAoB;;AAE3D,WAAO;EACX;;;;;EAMO,wBAAwB,aAAuC;AAClE,QAAI,KAAK,wBAAwB,aAAa;AAC1C,UAAI,KAAK,qBAAqB;AAC1B,aAAK,sBAAsB,qBAAqB,QAAQ,OAAO,yBAAyB;AACxF,aAAK,sBAAsB,6BAA6B,KAAK,mBAAwC;AACrG,aAAK,sBAAsB,sBAAqB;;AAGpD,UAAI,aAAa;AACb,aAAK,sBAAsB,qBAAqB,QAAQ,OAAO,uBAAuB;AACtF,aAAK,sBAAsB,6BAA6B,WAAgC;AACxF,aAAK,sBAAsB,sBAAqB;;AAGpD,WAAK,sBAAsB;;EAEnC;;;;;EAMO,kBAAe;AAClB,WAAO;EACX;EAEO,MAAM,OAA8B,YAAqB,OAAgB,UAAmB,OAAK;AACpG,QAAI,KAAK,uBAAuB;AAC5B,YAAM,IAAI,MAAM,mDAAmD;;AAGvE,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,aAAa;AAC5E,SAAK,sBAAsB,yBAAyB,cAAc,QAAQ,IAAI,CAAC;AAC/E,SAAK,sBAAsB,0BAA0B,QAAQ,MAAM,IAAI,CAAC;AACxE,SAAK,sBAAsB,0BAA0B,QAAQ,MAAM,IAAI,CAAC;AACxE,SAAK,sBAAsB,0BAA0B,QAAQ,MAAM,IAAI,CAAC;AACxE,SAAK,sBAAsB,0BAA0B,QAAQ,MAAM,IAAI,CAAC;AACxE,SAAK,sBAAsB,yBAAyB,QAAQ,IAAI,CAAC;AACjE,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,yBAAyB,UAAU,IAAI,CAAC;AACnE,SAAK,sBAAsB,yBAAyB,CAAC;AACrD,SAAK,sBAAsB,sBAAqB;EACpD;EAEO,kBAAkB,SAAuB,YAAsB,QAAe;AACjF,UAAM,OAAO,KAAK,oBAAoB,OAAO;AAC7C,UAAM,SAAS,IAAI,iBAAgB;AACnC,WAAO,aAAa;AACpB,WAAO,WAAW,KAAK,sBAAsB;AAC7C,QAAI,KAAK,YAAY;AACjB,aAAO,oBAAoB,KAAK,QAAQ,kBAAkB,KAAK,QAAQ,KAAK,YAAY,KAAK,YAAY,OAAO,UAAU,cAAc,KAAK;;AAEjJ,WAAO;EACX;EAEO,mBAAmB,UAAqB,YAAsB,QAAe;AAChF,UAAM,OAAO,YAAY,OAAO,QAAQ,IAAI,WAAW,IAAI,aAAa,QAAQ;AAChF,UAAM,SAAS,IAAI,iBAAgB;AACnC,WAAO,aAAa;AACpB,QAAI,KAAK,YAAY;AACjB,aAAO,qBAAqB,KAAK,QAAQ,mBAAmB,KAAK,QAAQ,KAAK,YAAY,KAAK,YAAY,cAAc,KAAK;;AAElI,WAAO;EACX;EAEU,yBACN,aACA,eACA,aACA,QACA,uBAAkE;AAElE,QAAI,aAAa;AACb,WAAK,QAAQ,kBAAkB,aAAa,YAAY,iBAAkB;;AAG9E,UAAM,aAAa,OAAO,mBAAkB;AAC5C,aAAS,QAAQ,GAAG,QAAQ,WAAW,QAAQ,SAAS;AACpD,YAAM,WAAW,OAAO,qBAAqB,KAAK;AAClD,UAAI,YAAY,GAAG;AACf,cAAM,OAAO,WAAW,KAAK;AAC7B,YAAI,eAAuC;AAE3C,YAAI,uBAAuB;AACvB,yBAAe,sBAAsB,IAAI;;AAE7C,YAAI,CAAC,cAAc;AACf,yBAAe,cAAc,IAAI;;AAGrC,YAAI,cAAc;AACd,gBAAM,SAAS,aAAa,UAAS;AACrC,cAAI,UAAU,OAAO,oBAAoB;AACrC,iBAAK,QAAQ,mBACT,aACA,OAAO,oBACP,UACA,aAAa,YACb,aAAa,YACb,aAAa,QAAO,GACpB,oBAAoB,aAAa,IAAI,GACrC,aAAa,YACb,aAAa,mBAAkB,CAAE;;;;;EAMzD;EAEO,YAAY,eAAgD,aAAyC,QAAc;AACtH,QAAI,KAAK,0BAA0B;AAC/B,WAAK,mBAAmB,KAAK,wBAAwB;;AAEzD,SAAK,2BAA2B,KAAK,QAAQ,kBAAiB;AAC9D,SAAK,yBAAyB,KAAK,0BAA0B,eAAe,aAAa,MAAM;AAC/F,SAAK,sBAAsB,KAAK,wBAAwB;EAC5D;EAEO,wBACH,eACA,aACA,QACA,uBAAkE;AAElE,UAAM,cAAc,KAAK,QAAQ,kBAAiB;AAClD,SAAK,yBAAyB,aAAa,eAAe,aAAa,QAAQ,qBAAqB;AACpG,WAAO;EACX;EAEQ,mBAAmB,aAAoC;AAC3D,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,yBAAyB;AACxF,SAAK,sBAAsB,6BAA6B,WAAW;AACnE,SAAK,sBAAsB,sBAAqB;EACpD;EAEO,sBAAsB,aAAmC;AAC5D,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,uBAAuB;AACtF,SAAK,sBAAsB,6BAA6B,WAAsC;AAC9F,SAAK,sBAAsB,sBAAqB;EACpD;EAEO,yBAAyB,aAAmC;AAC/D,SAAK,mBAAmB,WAAsC;EAClE;EAEO,cAAc,iBAAmC,iBAAyB;AAC7E,UAAM,wBAAwB;AAC9B,WAAO,KAAK,QAAQ,cAAc,sBAAsB,SAAS,eAAe;EACpF;;;;;;;;EASO,iBAAiB,UAAkB,YAAoB,YAAoB,gBAAuB;AAErG,SAAK,WAAW,SAAS,GAAG,KAAK;AAEjC,QAAI,kBAAkB,QAAQ,OAAO,8BAA8B;AAC/D,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,4BAA4B;AAC3F,WAAK,sBAAsB,yBAAyB,QAAQ;AAC5D,WAAK,sBAAsB,yBAAyB,UAAU;AAC9D,WAAK,sBAAsB,yBAAyB,UAAU;AAC9D,WAAK,sBAAsB,yBAAyB,cAAc;WAC/D;AACH,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,mBAAmB;AAClF,WAAK,sBAAsB,yBAAyB,QAAQ;AAC5D,WAAK,sBAAsB,yBAAyB,UAAU;AAC9D,WAAK,sBAAsB,yBAAyB,UAAU;;AAGlE,SAAK,sBAAsB,sBAAqB;EAEpD;;;;;;;;EASO,eAAe,UAAkB,eAAuB,eAAuB,gBAAuB;AAEzG,SAAK,WAAW,SAAS,GAAG,KAAK;AAEjC,QAAI,kBAAkB,QAAQ,OAAO,uBAAuB;AACxD,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,qBAAqB;AACpF,WAAK,sBAAsB,yBAAyB,QAAQ;AAC5D,WAAK,sBAAsB,yBAAyB,aAAa;AACjE,WAAK,sBAAsB,yBAAyB,aAAa;AACjE,WAAK,sBAAsB,yBAAyB,cAAc;WAC/D;AACH,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,YAAY;AAC3E,WAAK,sBAAsB,yBAAyB,QAAQ;AAC5D,WAAK,sBAAsB,yBAAyB,aAAa;AACjE,WAAK,sBAAsB,yBAAyB,aAAa;;AAGrE,SAAK,sBAAsB,sBAAqB;EAEpD;EAEO,wBAAqB;AACxB,UAAM,UAAU,CAAC,EAAE,KAAK,MAAM,yBAAyB,KAAK,QAAQ;AACpE,WAAO,IAAI,sBAAsB,MAAM,OAAO;EAClD;EAEO,wBAAqB;AACxB,WAAO;EACX;EAEO,oBAAiB;AACpB,WAAO;EACX;;;;EAKO,wBACH,iBACA,kBACA,oBACA,aACA,sBACA,wBACA,gBACA,SAAyB;AAEzB,QAAI,aAAa;AACb,WAAK,uBAAsB;WACxB;AACH,WAAK,oBAAoB,iBAAiB,kBAAkB,oBAAoB,OAAO;;EAE/F;;;;EAKO,qCAAqC,iBAAmC,QAAkB;AAC7F,UAAM,wBAAwB;AAC9B,QAAI,sBAAsB,SAAS;AAC/B,UAAI,sBAAsB,YAAY;AAClC,cAAM,aAAa,sBAAsB;AACzC,8BAAsB,aAAa,MAAK;AACpC,qBAAU;AACV,iBAAM;QACV;aACG;AACH,8BAAsB,aAAa;;WAEpC;AACH,aAAM;;EAEd;EAEO,yBAAsB;AACzB,UAAM,IAAI,MAAM,eAAe;EACnC;EAEO,oBAAoB,iBAAmC,YAAoB,cAAsB,SAAyB;AAC7H,UAAM,wBAAwB;AAE9B,SAAK,oCAAoC,gBAAgB,IAAI;AAE7D,UAAM,gBAAgB,IAAI,kBAAkB,UAAU;AACtD,kBAAc,YAAW;AACzB,iBAAa,cAAc;AAE3B,UAAM,kBAAkB,IAAI,kBAAkB,YAAY;AAC1D,oBAAgB,YAAW;AAC3B,mBAAe,gBAAgB;AAE/B,iBAAa,WAAW,mBAAmB,YAAY,OAAO;AAC9D,mBAAe,WAAW,mBAAmB,cAAc,OAAO;AAElE,UAAM,YAAY,MAAK;AApsB/B;AAqsBY,4BAAsB,aAAa;AACnC,kCAAsB,eAAtB;AACA,WAAK,mCAAmC,gBAAgB,IAAI;IAChE;AAEA,QAAI,gBAAgB,SAAS;AACzB,4BAAsB,UAAU,KAAK,QAAQ,mBAAmB,YAAY,cAAc,WAAW,CAAC,UAAgB;AAClH,8BAAsB,mBAAmB;MAC7C,CAAC;WACE;AACH,UAAI;AACA,8BAAsB,UAAU,KAAK,QAAQ,cAAc,YAAY,YAAY;AACnF,kBAAS;eACJ,GAAG;AACR,cAAM,UAAU,uBAAG;AACnB,cAAM,IAAI,MAAM,kBAAkB,OAAO,YAAY,WAAW,OAAO,UAAU,GAAG;;;AAI5F,WAAO,sBAAsB;EACjC;;;;;;EAOO,iBAAiB,MAAY;AAChC,UAAM,MAAM,IAAI,kBAAkB,IAAI;AACtC,QAAI,QAAQ;AACZ,QAAI,YAAW;AACf,WAAO,IAAI;EACf;EAEU,YAAY,SAAqB;AACvC,QAAI,KAAK,oBAAoB,SAAS;AAClC,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kBAAkB;AACjF,WAAK,sBAAsB,6BAA6B,OAAwB;AAChF,WAAK,sBAAsB,sBAAqB;AAChD,WAAK,kBAAkB;;EAE/B;EAEO,uBAAuB,iBAAiC;AAC3D,UAAM,wBAAwB;AAC9B,QAAI,yBAAyB,sBAAsB,SAAS;AACxD,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,qBAAqB;AACpF,WAAK,sBAAsB,6BAA6B,sBAAsB,OAAO;AACrF,WAAK,sBAAsB,sBAAqB;;EAExD;EAEO,YAAY,iBAAmC,eAAuB;AACzE,UAAM,wBAAwB;AAC9B,WAAO,KAAK,QAAQ,YAAY,sBAAsB,SAAS,aAAa;EAChF;EAEO,iBAAiB,iBAAmC,WAAmB,OAAa;AAEvF,UAAM,IAAI,MAAM,iBAAiB;EACrC;EAEO,aAAa,QAAc;AAC9B,UAAM,wBAAwB,OAAO,mBAAkB;AACvD,SAAK,YAAY,sBAAsB,OAAuB;AAG9D,UAAM,WAAW,OAAO,YAAW;AACnC,aAAS,QAAQ,GAAG,QAAQ,SAAS,QAAQ,SAAS;AAClD,YAAM,UAAU,OAAO,WAAW,SAAS,KAAK,CAAC;AAEjD,UAAI,SAAS;AACT,aAAK,eAAe,KAAK,IAAI;;;AAGrC,SAAK,iBAAiB;EAC1B;EAEO,eAAe,YAAY,OAAK;AACnC,QAAI,CAAC,aAAa,KAAK,sBAAsB;AACzC,aAAO,KAAK,qBAAqB;;AAGrC,WAAO,KAAK,QAAQ,eAAc;EACtC;EAEO,gBAAgB,YAAY,OAAK;AACpC,QAAI,CAAC,aAAa,KAAK,sBAAsB;AACzC,aAAO,KAAK,qBAAqB;;AAGrC,WAAO,KAAK,QAAQ,gBAAe;EACvC;EAEO,YAAY,UAAyB,eAAwB,gBAAuB;AACvF,SAAK,kBAAkB;AACvB,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,mBAAmB;AAClF,SAAK,sBAAsB,0BAA0B,SAAS,CAAC;AAC/D,SAAK,sBAAsB,0BAA0B,SAAS,CAAC;AAC/D,SAAK,sBAAsB,0BAA0B,SAAS,KAAK;AACnE,SAAK,sBAAsB,0BAA0B,SAAS,MAAM;AACpE,SAAK,sBAAsB,sBAAqB;EACpD;EAEO,cAAc,GAAW,GAAW,OAAe,QAAc;AACpE,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kBAAkB;AACjF,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,KAAK;AAC1D,SAAK,sBAAsB,0BAA0B,MAAM;AAC3D,SAAK,sBAAsB,sBAAqB;EACpD;EAEO,iBAAc;AACjB,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kBAAkB;AACjF,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,sBAAqB;EACpD;EAEO,SAAS,SAAkB,UAAkB,GAAG,OAAiB,cAAc,OAAO,eAAyB,SAAyB,eAAuB,GAAC;AACnK,SAAK,WAAW;AAChB,SAAK,gBAAgB;AACrB,QAAI,KAAK,aAAa,GAAG;AACrB,YAAM,KAAK,4CAA4C;;AAG3D,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,gBAAgB;AAC/E,SAAK,sBAAsB,yBAAyB,UAAU,IAAI,CAAC;AACnE,SAAK,sBAAsB,0BAA0B,OAAO;AAC5D,SAAK,sBAAsB,0BAA0B,YAAY;AACjE,SAAK,sBAAsB,yBAAyB,KAAK,iBAAiB,iBAAiB,OAAO,IAAI,CAAC;AACvG,SAAK,sBAAsB,yBAAyB,cAAc,IAAI,CAAC;AACvE,SAAK,sBAAsB,sBAAqB;EACpD;;;;;EAMO,4BAAyB;AAC5B,UAAM,OAAO;MACT,QAAQ,KAAK,gBAAe;MAC5B,QAAQ,KAAK,gBAAe;MAC5B,MAAM;MACN,OAAO,KAAK,eAAc;MAC1B,KAAK;MACL,OAAO,KAAK,eAAc;MAC1B,GAAG;MACH,GAAG;MACH,QAAQ,MAAK;MAAE;;AAEnB,WAAO;EACX;;;;;EAMO,WAAW,OAAa;AAC3B,QAAI,UAAU,KAAK,UAAU;AACzB,WAAK,WAAW;AAChB,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kBAAkB;AACjF,WAAK,sBAAsB,0BAA0B,KAAK,wBAAwB,CAAC,QAAQ,KAAK;AAChG,WAAK,sBAAsB,sBAAqB;;EAExD;;;;;EAMO,aAAU;AACb,WAAO,KAAK;EAChB;;;;;EAMO,gBAAgB,OAAa;AAChC,QAAI,UAAU,KAAK,eAAe;AAC9B,WAAK,gBAAgB;AACrB,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,uBAAuB;AACtF,WAAK,sBAAsB,0BAA0B,KAAK,wBAAwB,CAAC,QAAQ,KAAK;AAChG,WAAK,sBAAsB,sBAAqB;;EAExD;;;;;EAMO,kBAAe;AAClB,WAAO,KAAK;EAChB;;;;;EAMO,eAAe,QAAe;AACjC,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,yBAAyB,SAAS,KAAK,oBAAoB,QAAQ,OAAO,iBAAiB;AACtH,SAAK,sBAAsB,sBAAqB;EACpD;;;;;EAMO,gBAAa;AAChB,WAAO,KAAK;EAChB;EAEO,mBAAgB;AACnB,YAAQ,KAAK,mBAAmB;MAC5B,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;MACX,KAAK,QAAQ,OAAO;AAChB,eAAO;;AAEf,WAAO;EACX;EAEO,iBAAiB,WAAiB;AACrC,QAAI,kBAAkB;AACtB,YAAQ,WAAW;MACf,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;MACJ,KAAK;AACD,0BAAkB,QAAQ,OAAO;AACjC;;AAGR,SAAK,oBAAoB;AACzB,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,yBAAyB,KAAK,iBAAiB;AAC1E,SAAK,sBAAsB,sBAAqB;EACpD;;;;;EAMO,cAAc,QAAe;AAChC,SAAK,cAAc;AACnB,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,qBAAqB;AACpF,SAAK,sBAAsB,yBAAyB,OAAO,MAAM,CAAC;AAClE,SAAK,sBAAsB,sBAAqB;EACpD;;;;;EAMO,cAAc,QAAe;AAChC,SAAK,cAAc;AACnB,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,qBAAqB;AACpF,SAAK,sBAAsB,yBAAyB,OAAO,MAAM,CAAC;AAClE,SAAK,sBAAsB,sBAAqB;EACpD;;;;;EAMO,gBAAa;AAChB,WAAO,KAAK;EAChB;EAEQ,eAAY;AAChB,SAAK,YACD,KAAK,cACL,uBAAuB,KAAK,qBAAqB,GACjD,0BAA0B,KAAK,mBAAmB,GAClD,0BAA0B,KAAK,0BAA0B,GACzD,qBAAqB,KAAK,YAAY,GACtC,KAAK,eAAe;EAE5B;EAEQ,YAAY,MAAc,eAAuB,aAAqB,aAAqB,MAAc,KAAW;AACxH,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kBAAkB;AACjF,SAAK,sBAAsB,yBAAyB,IAAI;AACxD,SAAK,sBAAsB,yBAAyB,aAAa;AACjE,SAAK,sBAAsB,yBAAyB,WAAW;AAC/D,SAAK,sBAAsB,yBAAyB,WAAW;AAC/D,SAAK,sBAAsB,yBAAyB,IAAI;AACxD,SAAK,sBAAsB,yBAAyB,GAAG;AACvD,SAAK,sBAAsB,sBAAqB;EACpD;;;;;EAMO,iBAAiB,QAAe;AACnC,SAAK,eAAe;AACpB,QAAI,QAAQ;AACR,WAAK,aAAY;WACd;AACH,WAAK,YACD,KACA,QAAQ,OAAO,wBACf,QAAQ,OAAO,wBACf,QAAQ,OAAO,wBACf,QAAQ,OAAO,qBACf,CAAC;;EAGb;;;;;EAMO,mBAAgB;AACnB,WAAO,KAAK;EAChB;;;;;EAMO,0BAAuB;AAC1B,WAAO,KAAK;EAChB;;;;;EAMO,wBAAwB,WAAiB;AAC5C,SAAK,6BAA6B;AAClC,SAAK,aAAY;EACrB;;;;;EAMO,eAAe,MAAY;AAC9B,SAAK,eAAe;AACpB,SAAK,aAAY;EACrB;;;;;EAMO,mBAAmB,aAAmB;AACzC,SAAK,eAAe;AACpB,SAAK,aAAY;EACrB;;;;;EAMO,4BAA4B,WAAiB;AAChD,SAAK,kBAAkB;AACvB,SAAK,aAAY;EACrB;;;;;EAMO,uBAAuB,MAAY;AACtC,SAAK,mBAAmB;EAC5B;;;;;EAMO,wBAAwB,WAAiB;AAC5C,SAAK,wBAAwB;AAC7B,SAAK,aAAY;EACrB;;;;;EAMO,6BAA6B,WAAiB;AACjD,SAAK,sBAAsB;AAC3B,SAAK,aAAY;EACrB;;;;;EAMO,iBAAc;AACjB,WAAO,KAAK;EAChB;;;;;EAMO,qBAAkB;AACrB,WAAO,KAAK;EAChB;;;;;EAMO,8BAA2B;AAC9B,WAAO,KAAK;EAChB;;;;;EAMO,yBAAsB;AACzB,WAAO,KAAK;EAChB;;;;;EAMO,0BAAuB;AAC1B,WAAO,KAAK;EAChB;;;;;EAMO,+BAA4B;AAC/B,WAAO,KAAK;EAChB;;;;;;;;EASO,kBAAkB,GAAW,GAAW,GAAW,GAAS;AAC/D,UAAM,IAAI,MAAM,yDAAyD;EAC7E;;;;;;;EAQO,aAAa,MAAc,qBAA8B,OAAK;AACjE,QAAI,KAAK,eAAe,MAAM;AAC1B;;AAGJ,UAAM,aAAa,mBAAmB,IAAI;AAE1C,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,yBAAyB,UAAU;AAC9D,SAAK,sBAAsB,sBAAqB;AAEhD,QAAI,CAAC,oBAAoB;AACrB,WAAK,cAAc,SAAS,CAAA;;AAGhC,SAAK,aAAa;EACtB;;;;;;EAOO,eAAY;AACf,WAAO,KAAK;EAChB;EAEO,OAAO,SAA+B,KAAW;AACpD,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,cAAc;AAC7E,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,wBAAwB,GAAG;AACtD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,YAAY,SAA+B,OAAiB;AAC/D,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,mBAAmB;AAClF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,yBAAyB,KAAK;AACzD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,aAAa,SAA+B,OAAiB;AAChE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,yBAAyB,KAAK;AACzD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,aAAa,SAA+B,OAAiB;AAChE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,yBAAyB,KAAK;AACzD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,aAAa,SAA+B,OAAiB;AAChE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,yBAAyB,KAAK;AACzD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,cAAc,SAA+B,OAAmB;AACnE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,qBAAqB;AACpF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,KAAK;AAC3D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,eAAe,SAA+B,OAAmB;AACpE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,sBAAsB;AACrF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,KAAK;AAC3D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,eAAe,SAA+B,OAAmB;AACpE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,sBAAsB;AACrF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,KAAK;AAC3D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,eAAe,SAA+B,OAAmB;AACpE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,sBAAsB;AACrF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,KAAK;AAC3D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,SAAS,SAA+B,OAAe;AAC1D,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,WAAO,KAAK,cAAc,SAAS,IAAI,aAAa,KAAK,CAAC;EAC9D;EAEO,UAAU,SAA+B,OAAe;AAC3D,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,WAAO,KAAK,eAAe,SAAS,IAAI,aAAa,KAAK,CAAC;EAC/D;EAEO,UAAU,SAA+B,OAAe;AAC3D,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,WAAO,KAAK,eAAe,SAAS,IAAI,aAAa,KAAK,CAAC;EAC/D;EAEO,UAAU,SAA+B,OAAe;AAC3D,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,WAAO,KAAK,eAAe,SAAS,IAAI,aAAa,KAAK,CAAC;EAC/D;EAEO,YAAY,SAA+B,UAAsB;AACpE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,mBAAmB;AAClF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,QAAQ;AAC9D,SAAK,sBAAsB,sBAAqB;AAEhD,WAAO;EACX;EAEO,aAAa,SAA+B,QAAoB;AACnE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,MAAM;AAC5D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,aAAa,SAA+B,QAAoB;AACnE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,oBAAoB;AACnF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,2BAA2B,MAAM;AAC5D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,SAAS,SAA+B,OAAa;AACxD,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,gBAAgB;AAC/E,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,0BAA0B,KAAK;AAC1D,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,UAAU,SAA+B,GAAW,GAAS;AAChE,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,iBAAiB;AAChF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,UAAU,SAA+B,GAAW,GAAW,GAAS;AAC3E,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,iBAAiB;AAChF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,UAAU,SAA+B,GAAW,GAAW,GAAW,GAAS;AACtF,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,iBAAiB;AAChF,SAAK,sBAAsB,6BAA6B,OAA4B;AACpF,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,0BAA0B,CAAC;AACtD,SAAK,sBAAsB,sBAAqB;AAChD,WAAO;EACX;EAEO,UAAU,SAA+B,QAAmB;AAC/D,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,UAAU,SAAS,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC;AACpD,WAAO;EACX;EAEO,UAAU,SAA+B,QAAqB,OAAa;AAC9E,QAAI,CAAC,SAAS;AACV,aAAO;;AAGX,SAAK,UAAU,SAAS,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,KAAK;AAC3D,WAAO;EACX;EAEO,WAAW,YAAoB;AAClC,QAAI,KAAK,+BAA+B;AACpC;;AAEJ,SAAK,kBAAiB;AACtB,SAAK,iBAAiB;AAEtB,QAAI,YAAY;AACZ,WAAK,kBAAkB;AAEvB,WAAK,sBAAsB,MAAK;AAChC,WAAK,mBAAmB,MAAK;AAC7B,WAAK,YAAY,MAAK;;AAG1B,SAAK,uBAAuB;AAC5B,SAAK,qBAAqB;AAC1B,SAAK,gCAAgC;EACzC;EAEU,iBAAc;AACpB,WAAO,KAAK,QAAQ,cAAa;EACrC;EAEU,eAAe,SAA+B;AACpD,QAAI,SAAS;AACT,WAAK,QAAQ,cAAc,OAAwB;;EAE3D;;;;;;;;;EAUO,qBAAqB,SAAoC,QAAa,SAAkB,cAAuB,OAAO,QAAe;AACxI,QAAI,gBAAgB,QAAQ;AACxB,oBAAc;;AAGlB,QAAI,CAAC,CAAC,WAAW,CAAC,CAAC,QAAQ,kBAAkB;AACzC,YAAM,SAAS,OAAO,iBAAgB;AACtC,YAAM,cAAc,QAAQ,iBAAiB;AAC7C,WAAK,QAAQ,YAAY,aAAa,MAAM;AAC5C,cAAQ,UAAU;;EAE1B;EAEO,qBAAqB,OAAe,QAAgB,iBAA0B,cAAoB;AAGrG,YAAQ,KAAK,IAAI,OAAO,CAAC;AACzB,aAAS,KAAK,IAAI,QAAQ,CAAC;AAC3B,WAAO,KAAK,iBAAiB,IAAI,WAAW,QAAQ,SAAS,CAAC,GAAG,OAAO,QAAQ,GAAA,OAAU,OAAA,YAAkB;EAChH;EAEO,mBAAmB,aAAkC;AAExD,QAAI,KAAK,SAAS;AACd,aAAO,KAAK,QAAQ,YAAY,WAAW;;AAE/C,WAAO;EACX;EAEO,mBAAmB,SAAoC,OAAyB,SAAgB;AACnG,QAAI,WAAW,QAAQ,oBAAoB,KAAK,SAAS;AACrD,YAAM,eAAe,QAAQ,iBAAiB;AAC9C,WAAK,QAAQ,mBAAmB,cAAc,OAAO,OAAO;;EAEpE;EAEO,iBACH,MACA,OACA,QACA,QACA,iBACA,SACA,cACA,cAAgC,MAChC,OAAe,GAAA,gBAAU,GAAA,gBACzB,OAAA;AAGA,UAAM,UAAU,IAAI,gBAAgB,MAAM,sBAAsB,GAAG;AAEnE,YAAQ,SAAS;AACjB,YAAQ,kBAAkB;AAC1B,YAAQ,eAAe;AACvB,YAAQ,UAAU;AAClB,YAAQ,YAAY;AACpB,YAAQ,aAAa;AACrB,YAAQ,QAAQ,QAAQ;AACxB,YAAQ,SAAS,QAAQ;AACzB,YAAQ,eAAe;AACvB,YAAQ,OAAO;AACf,YAAQ,iBAAiB,KAAK,kBAAkB,eAAe,CAAC,eAAe;AAE/E,SAAK,iBAAiB,SAAS,MAAM,QAAQ,SAAS,aAAa,MAAM,QAAQ,cAAc;AAE/F,QAAI,QAAQ,kBAAkB;AAC1B,YAAM,eAAe,QAAQ,iBAAiB;AAC9C,YAAM,SAAS,sBAAsB,YAAY;AACjD,WAAK,oBAAoB,cAAc,MAAM;;AAGjD,SAAK,uBAAuB,KAAK,OAAO;AACxC,WAAO;EACX;EAEO,wBACH,MACA,OACA,QACA,OACA,QACA,iBACA,SACA,cACA,cAAgC,MAChC,cAAc,GAAA;AAEd,UAAM,UAAU,IAAI,gBAAgB,MAAM,sBAAsB,UAAU;AAE1E,YAAQ,YAAY;AACpB,YAAQ,aAAa;AACrB,YAAQ,YAAY;AACpB,YAAQ,QAAQ;AAChB,YAAQ,SAAS;AACjB,YAAQ,QAAQ;AAChB,YAAQ,SAAS;AACjB,YAAQ,OAAO;AACf,YAAQ,kBAAkB;AAC1B,YAAQ,eAAe;AACvB,YAAQ,YAAY;AAEpB,QAAI,QAAQ,kBAAkB;AAC1B,YAAM,gBAAgB,QAAQ,iBAAiB;AAC/C,WAAK,QAAQ,sBAAsB,eAAe,MAAM,OAAO,QAAQ,OAAO,uBAAuB,QAAQ,WAAW,GAAG,iBAAiB,OAAO;AAEnJ,YAAM,SAAS,sBAAsB,YAAY;AACjD,WAAK,oBAAoB,eAAe,MAAM;;AAGlD,YAAQ,UAAU;AAElB,SAAK,uBAAuB,KAAK,OAAO;AACxC,WAAO;EACX;EAEO,iBACH,SACA,YACA,QACA,SACA,cAAgC,MAChC,OAAe,GAAA,gBAAU,OAAA;AAGzB,QAAI,CAAC,SAAS;AACV;;AAGJ,QAAI,cAAc,QAAQ,kBAAkB;AACxC,YAAM,qBAAqB,QAAQ,iBAAiB;AACpD,WAAK,QAAQ,eACT,oBACA,YACA,QAAQ,OACR,QAAQ,QACR,uBAAuB,QAAQ,IAAI,GACnC,QAAQ,iBACR,QAAQ,OAAO;;AAIvB,YAAQ,UAAU;EACtB;;;;;;;;;;;;;;;;;;;;;;;;;EA0BO,cACH,KACA,UACA,SACA,OACA,eAAuB,GAAA,SAAU,MAAA,UAAA,MAAA,SACjC,MAAA,WACA,MAAA,SACA,MAAA,kBACsC,MACtC,UAA2B,eAC3B,eACA,gBACA,OAAmB;AAInB,UAAM,OAAO;AACb,UAAM,WAAW,IAAI,OAAO,GAAG,CAAC,MAAM;AAEtC,UAAM,WAAW,YAAY,IAAI,QAAQ,UAAU,MAAM;AAEzD,UAAM,UAAU,WAAW,WAAW,IAAI,gBAAgB,MAAM,sBAAsB,GAAG;AAEzF,UAAM,cAAc;AACpB,QAAI,KAAK,wBAAwB,CAAC,YAAY,CAAC,YAAY,CAAC,QAAQ;AAChE,YAAM,KAAK,qBAAqB,GAAG;;AAIvC,UAAM,UAAU,IAAI,YAAY,GAAG;AACnC,UAAM,YAAY,kBAAkB,kBAAkB,UAAU,KAAK,IAAI,UAAU,OAAO,EAAE,YAAW,IAAK;AAE5G,QAAI,SAA2C;AAC/C,eAAW,mBAAmB,OAAO,iBAAiB;AAClD,UAAI,gBAAgB,QAAQ,SAAS,GAAG;AACpC,iBAAS;AACT;;;AAIR,QAAI,OAAO;AACP,YAAM,eAAe,OAAO;;AAEhC,YAAQ,MAAM;AACd,YAAQ,kBAAkB,CAAC;AAC3B,YAAQ,eAAe;AACvB,YAAQ,UAAU;AAClB,YAAQ,iBAAiB,KAAK,kBAAkB,eAAe,QAAQ;AAEvE,QAAI,CAAC,KAAK,wBAAwB;AAE9B,cAAQ,UAAU;;AAGtB,QAAI,iBAAsD;AAC1D,QAAI,UAAU,CAAC,UAAU;AACrB,uBAAiB,QAAQ,mBAAmB,IAAI,MAAM;;AAG1D,QAAI,CAAC,UAAU;AACX,WAAK,uBAAuB,KAAK,OAAO;;AAG5C,UAAM,kBAAkB,CAAC,SAAkB,cAAmB;AAC1D,UAAI,OAAO;AACP,cAAM,kBAAkB,OAAO;;AAGnC,UAAI,QAAQ,aAAa;AACrB,YAAI,gBAAgB;AAChB,kBAAQ,mBAAmB,OAAO,cAAc;;AAGpD,YAAI,YAAY,oBAAoB;AAChC,eAAK,cAAc,YAAY,iBAAiB,UAAU,QAAQ,SAAS,OAAO,cAAc,MAAM,SAAS,QAAQ,OAAO;;AAGlI,YAAI,SAAS;AACT,mBAAS,WAAW,oBAAoB,YAAY,qBAAqB,iCAAiC,KAAK,SAAS;;aAEzH;AAEH,eAAO,KAAK,kBAAkB,GAAG,qBAAqB,WAAW,EAAE;AACnE,aAAK,cAAc,aAAa,UAAU,QAAQ,SAAS,OAAO,cAAc,QAAQ,SAAS,QAAQ,SAAS,QAAQ,iBAAiB,UAAU,aAAa;;IAE1K;AAGA,QAAI,QAAQ;AACR,YAAM,IAAI,MAAM,mEAAmE;WAChF;AACH,YAAM,SAAS,CAAC,SAAyB;AACrC,YAAI,CAAC,QAAQ,kBAAkB;AAC3B,cAAI,OAAO;AACP,kBAAM,kBAAkB,OAAO;;AAGnC;;AAGJ,cAAM,qBAAqB,QAAQ,iBAAiB;AAEpD,aAAK,QAAQ,YACT,oBACA,MACA,CAAC,UACD,SACA,QAAQ,gBACR,MAAK;AACD,kBAAQ,YAAY,KAAK,QAAQ,gBAAgB,kBAAkB;AACnE,kBAAQ,aAAa,KAAK,QAAQ,iBAAiB,kBAAkB;AACrE,kBAAQ,QAAQ,QAAQ;AACxB,kBAAQ,SAAS,QAAQ;AACzB,kBAAQ,UAAU;AAElB,gBAAM,SAAS,sBAAsB,YAAY;AACjD,eAAK,oBAAoB,oBAAoB,MAAM;AAEnD,cAAI,OAAO;AACP,kBAAM,kBAAkB,OAAO;;AAGnC,kBAAQ,mBAAmB,gBAAgB,OAAO;AAClD,kBAAQ,mBAAmB,MAAK;QACpC,GACA,MAAK;AACD,gBAAM,IAAI,MAAM,kCAAkC;QACtD,CAAC;MAET;AAEA,UAAI,YAAY,QAAQ;AACpB,YAAI,kBAAkB,aAAa;AAC/B,iBAAO,IAAI,WAAW,MAAM,CAAC;mBACtB,YAAY,OAAO,MAAM,GAAG;AACnC,iBAAO,MAAM;mBACN,OAAO,WAAW,UAAU;AACnC,iBAAO,IAAI,WAAW,MAAM,aAAa,MAAM,CAAC,CAAC;eAC9C;AACH,gBAAM,IAAI,MAAM,yBAAyB;;aAE1C;AACH,YAAI,UAAU;AACV,iBAAO,IAAI,WAAW,MAAM,aAAa,GAAG,CAAC,CAAC;eAC3C;AACH,eAAK,UACD,KACA,CAAC,SAAS,OAAO,IAAI,WAAW,IAAmB,CAAC,GACpD,QACA,QACA,MACA,CAAC,SAAuB,cAAmB;AACvC,4BAAgB,qBAAqB,UAAU,QAAQ,cAAc,KAAK,UAAU;UACxF,CAAC;;;;AAMjB,WAAO;EACX;;;;;;;;EASO,kBAAkB,SAAwB,aAAsB,OAAO,eAAuB,GAAA;AACjG,UAAM,kBAAkB,IAAI,sBAAsB,SAAS,KAAK,OAAO;AACvE,UAAM,kBAAkB,IAAI,gBAAgB,MAAM,sBAAsB,SAAS,IAAI;AACrF,oBAAgB,mBAAmB;AACnC,oBAAgB,YAAY,KAAK,QAAQ,gBAAgB,OAAO;AAChE,oBAAgB,aAAa,KAAK,QAAQ,iBAAiB,OAAO;AAClE,oBAAgB,QAAQ,gBAAgB;AACxC,oBAAgB,SAAS,gBAAgB;AACzC,oBAAgB,UAAU;AAC1B,oBAAgB,aAAa;AAC7B,SAAK,0BAA0B,cAAc,eAAe;AAC5D,WAAO;EACX;;;;;;EAOO,mBAAgB;AACnB,UAAM,IAAI,MAAM,mEAAmE;EACvF;EAEO,2BAA2B,MAAmB,SAAsC,WAA8B;AAErH,UAAM,kBAAkB,QAAQ,mBAAmB;AACnD,UAAM,UAAU,QAAQ,WAAW;AAEnC,UAAM,kBAAkB;AACxB,UAAM,UAAU,IAAI,gBAAgB,MAAM,sBAAsB,YAAY;AAE5E,UAAM,QAA6D,KAAM,SAAiB;AAC1F,UAAM,SAA8D,KAAM,UAAkB;AAE5F,UAAM,cAAc,KAAK,QAAQ,kBAAkB,QAAQ,iBAAkB,oBAAoB,OAAO,QAAQ,iBAAiB,MAAM,OAAO;AAC9I,oBAAgB,2BAA2B;AAC3C,WAAO;EACX;;;;EAKO,2BAA2B,aAAwC;AACtE,QAAI,aAAa;AACb,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,yBAAyB;AACxF,WAAK,sBAAsB,6BAA6B,WAAyB;AACjF,WAAK,sBAAsB,sBAAqB;;EAExD;;;;;;;EAQO,6BAA6B,aAAqB,SAA4B;AACjF,UAAM,UAAU,IAAI,QAAqB,CAAC,SAAS,WAAU;AACzD,YAAM,QAAQ,KAAK,kBAAiB;AACpC,YAAM,SAAS,MAAK;AAChB,YAAI;AACA,gBAAM,cAAc,KAAK,QAAQ,kBAAkB,KAAK;AACxD,kBAAQ,WAAW;iBACd,OAAO;AACZ,iBAAO,uBAAuB,MAAM,GAAG,oBAAoB,KAAK,EAAE;;MAE1E;AACA,YAAM,UAAU,CAAC,UAAS;AACtB,eAAO,uBAAuB,MAAM,GAAG,oBAAoB,KAAK,EAAE;MACtE;AAEA,YAAM,MAAM;IAChB,CAAC;AAED,WAAO;EACX;;;;;;;EAQO,kBAAkB,OAA0B,SAA4B;AAC3E,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,UAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,cAAM,MAA8B;AACpC,YAAI,IAAI,QAAQ;AACZ,gBAAMC,SAAQ,KAAK,QAAQ,kBAAkB,IAAI,CAAC,CAAC;AACnD,cAAIA,QAAO;AACP,oBAAQA,MAAK;AACb;;;;AAIZ,aAAO,yCAAyC;IACpD,CAAC;EACL;;;;;;;;EASO,kBAAkB,OAAoB,aAAqB,cAAoB;AAClF,WAAO,KAAK,QAAQ,kBAAkB,OAAO,aAAa,YAAY;EAC1E;;;;;;;;;;;;;;;;;;;EAoBO,kBACH,SACA,OACA,OACA,UACA,SAAyC,MACzC,UAAiE,MACjE,QACA,kBAAuB,MACvB,oBAAoB,OACpB,WAAmB,GACnB,YAAoB,GACpB,WAAsC,MACtC,eACA,gBAAgB,OAAK;AAErB,UAAM,UAAU,WAAW,WAAW,IAAI,gBAAgB,MAAM,sBAAsB,IAAI;AAC1F,YAAQ,SAAS;AACjB,YAAQ,MAAM;AACd,YAAQ,kBAAkB,CAAC;AAC3B,YAAQ,sBAAsB;AAC9B,YAAQ,uBAAuB;AAC/B,YAAQ,iBAAiB,KAAK,kBAAkB,eAAe,CAAC,CAAC,QAAQ;AAEzE,QAAI,CAAC,KAAK,yBAAyB;AAC/B,cAAQ,aAAa;AACrB,cAAQ,SAAS;;AAGrB,UAAM,UAAU,QAAQ,YAAY,GAAG;AACvC,UAAM,YAAY,kBAAkB,kBAAkB,UAAU,KAAK,QAAQ,UAAU,OAAO,EAAE,YAAW,IAAK;AAGhH,QAAI,cAAc,QAAQ;AACtB,YAAM,aAAa,CAAC,SAAyB;AACzC,cAAM,OAAO,WAAW,IAAI;AAC5B,gBAAQ,QAAQ,KAAK;AACrB,gBAAQ,SAAS,KAAK;AAEtB,2BAAmB,SAAS,IAAI;AAEhC,cAAM,eAAe,KAAK;AAC1B,YAAI,CAAC,cAAc;AACf,gBAAM,IAAI,MAAM,4BAA4B;;AAGhD,gBAAQ,sBAAsB,aAAa;AAC3C,cAAM,YAAY,gCAAgC,MAAM,IAAI;AAE5D,gBAAQ,SAAS;AACjB,gBAAQ,OAAO;AACf,gBAAQ,kBAAkB;AAC1B,gBAAQ,UAAS,EAAG,0BAA0B,QAAQ,wBAAwB,OAAO;AACrF,gBAAQ,UAAU;AAClB,gBAAQ,UAAU;AAElB,aAAK,QAAQ,wBACT,QAAQ,iBAAkB,oBAC1B,WACA,OACA,QAAQ,gBACR,MAAK;AACD,kBAAQ,UAAU;AAClB,cAAI,QAAQ;AACR,mBAAM;;QAEd,GACA,MAAK;AACD,gBAAM,IAAI,MAAM,uCAAuC;QAC3D,CAAC;MAET;AAEA,UAAI,SAAS,MAAM,WAAW,GAAG;AAC7B,cAAM,IAAI,MAAM,8CAA8C;aAC3D;AACH,cAAM,kBAAkB,CAAC,SAAuB,cAAmB;AAC/D,cAAI,WAAW,SAAS;AACpB,oBAAQ,QAAQ,SAAS,MAAM,QAAQ,YAAY,SAAS;;QAEpE;AAEA,aAAK,UACD,SACA,CAAC,SAAQ;AACL,qBAAW,IAAI,WAAW,MAAqB,GAAI,KAAqB,UAAU,CAAC;QACvF,GACA,QACA,QACA,MACA,eAAe;;WAGpB;AACH,UAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAC9B,cAAM,IAAI,MAAM,sDAAsD;;AAI1E,YAAM,iBAAiB,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAClF,cAAQ,IAAI,eAAe,IAAI,CAAC,SAAS,KAAK,eAAe,MAAM,QAAW,IAAI,EAAE,KAAK,CAAC,SAAS,IAAI,WAAW,MAAM,GAAG,KAAK,UAAU,CAAC,CAAC,CAAC,EACxI,KAAK,CAAC,SAAQ;AACX,eAAO,IAAI,QAAc,CAAC,SAAS,WAAU;AACzC,eAAK,QAAQ,gBAAgB,QAAQ,iBAAkB,oBAAoB,MAAM,CAAC,UAAU,MAAM,QAAQ,gBAAgB,SAAS,MAAM;QAC7I,CAAC;MACL,CAAC,EACA,KACG,MAAK;AACD,gBAAQ,UAAU;AAClB,YAAI,QAAQ;AACR,iBAAM;;MAEd,GACA,CAAC,UAAS;AACN,YAAI,SAAS;AACT,kBAAQ,2BAA2B,MAAM,OAAO,IAAI,KAAK;;MAEjE,CAAC;;AAIb,SAAK,uBAAuB,KAAK,OAAO;AAExC,WAAO;EACX;;EAGO,yBAAsB;AACzB,WAAO,IAAI,sBAAsB,KAAK,eAAc,GAAqB,KAAK,OAAO;EACzF;;EAGO,mCAAmC,SAAkB,QAAiB,MAAiB;AAC1F,UAAM,YAAY,IAAI,0BAA0B,SAAS,QAAQ,MAAM,IAAI;AAC3E,SAAK,0BAA0B,KAAK,SAAS;AAC7C,WAAO;EACX;;EAGO,uBACH,MACA,SACA,2BAA2B,MAC3B,SAAS,sBAAsB,SAAO;AAEtC,QAAI,kBAAkB;AACtB,QAAI,OAAO;AACX,QAAI,eAAe;AACnB,QAAI,SAAS;AACb,QAAI,gBAAgB;AACpB,QAAI,UAAU;AACd,QAAI;AACJ,QAAI,YAAY,UAAa,OAAO,YAAY,UAAU;AACtD,wBAAkB,CAAC,CAAC,QAAQ;AAC5B,aAAO,QAAQ,SAAS,SAAY,IAAA,QAAU;AAC9C,qBAAe,QAAQ,iBAAiB,SAAY,IAAA,QAAU;AAC9D,eAAS,QAAQ,WAAW,SAAY,IAAA,QAAU;AAClD,sBAAgB,QAAQ,kBAAkB,SAAY,QAAQ,QAAQ;AACtE,gBAAU,QAAQ,WAAW;AAC7B,cAAQ,QAAQ;WACb;AACH,wBAAkB,CAAC,CAAC;;AAGxB,oBAAgB,KAAK,kBAAkB,eAAe,CAAC,eAAe;AAEtE,QAAI,SAAS,KAAA,CAAA,KAAU,MAAA,6BAAiC;AAEpD,qBAAe;eACR,SAAS,KAAA,CAAA,KAAU,MAAA,iCAAsC;AAEhE,qBAAe;;AAEnB,QAAI,SAAS,KAAA,CAAA,KAAU,MAAA,cAAqB;AACxC,aAAO;AACP,aAAO,KAAK,4EAA4E;;AAG5F,UAAM,UAAU,IAAI,gBAAgB,MAAM,MAAM;AAChD,UAAM,QAA6D,KAAM,SAAiB;AAC1F,UAAM,SAA8D,KAAM,UAAkB;AAE5F,UAAM,SAA8D,KAAM,UAAU;AACpF,QAAI,WAAW,GAAG;AACd,YAAM,IAAI,MAAM,oDAAoD;;AAGxE,UAAM,gBAAgB,QAAQ,iBAAkB;AAChD,UAAM,sBAAsB,uBAAuB,QAAQ,IAAI;AAE/D,SAAK,QAAQ,kBAAkB,eAAe,OAAO,QAAQ,iBAAiB,qBAAqB,MAAM,eAAe,OAAO;AAC/H,SAAK,oBAAoB,eAAe,sBAAsB,YAAY,CAAC;AAE3E,YAAQ,iBAAiB;AACzB,YAAQ,YAAY;AACpB,YAAQ,aAAa;AACrB,YAAQ,QAAQ;AAChB,YAAQ,SAAS;AACjB,YAAQ,QAAQ;AAChB,YAAQ,UAAU;AAClB,YAAQ,UAAU;AAClB,YAAQ,kBAAkB;AAC1B,YAAQ,eAAe;AACvB,YAAQ,OAAO;AACf,YAAQ,SAAS;AACjB,YAAQ,QAAQ;AAEhB,SAAK,uBAAuB,KAAK,OAAO;AAExC,WAAO;EACX;EAEO,0BAA0B,MAAkD,SAA8C;AAC7H,UAAM,YAAY,KAAK,mCAAmC,OAAO,OAAO,IAAI;AAE5E,QAAI,sBAAsB;AAC1B,QAAI,wBAAwB;AAC5B,QAAI,oBAAoB;AACxB,QAAI,kBAA+C;AACnD,QAAI,UAAU;AACd,QAAI,YAAY,UAAa,OAAO,YAAY,UAAU;AACtD,4BAAsB,QAAQ,uBAAuB;AACrD,8BAAwB,CAAC,CAAC,QAAQ;AAClC,0BAAoB,CAAC,CAAC,QAAQ;AAC9B,wBAAkB,QAAQ;AAC1B,gBAAU,QAAQ,WAAW;;AAGjC,UAAM,UAAU,oBAAoB,oBAAoB,OAAO,KAAK,uBAAuB,MAAM,SAAS,MAAM,sBAAsB,YAAY;AAClJ,UAAM,QAA6D,KAAM,SAAiB;AAC1F,UAAM,SAA8D,KAAM,UAAkB;AAE5F,UAAM,cAAc,KAAK,QAAQ,kBAC7B,UAAU,QAAQ,iBAAkB,qBAAqB,MACzD,OACA,QACA,uBACA,qBACA,OAAO;AAGX,cAAU,eAAe;AACzB,cAAU,uBAAuB;AACjC,cAAU,yBAAyB;AACnC,cAAU,WAAW;AAErB,cAAU,YAAY,OAAO;AAE7B,WAAO;EACX;EAEO,qCAAqC,WAAgC,SAAe;AACvF,WAAO,KAAK,gEAAgE;AAC5E,WAAO,UAAU;EACrB;EAEO,0BAA0B,cAAsB,SAAwB;AAC3E,QAAI,QAAQ,kBAAkB;AAC1B,YAAM,SAAS,sBAAsB,YAAY;AACjD,WAAK,oBAAoB,QAAQ,iBAAiB,oBAAoB,MAAM;;AAGhF,YAAQ,eAAe;EAC3B;EAEO,gBAAgB,SAA8B,WAAoB,eAAwB,gBAAyB,yBAAiC;AACvJ,UAAM,kBAAkB;AAExB,QAAI,KAAK,sBAAsB;AAC3B,WAAK,kBAAkB,KAAK,oBAAoB;;AAGpD,SAAK,uBAAuB;AAE5B,QAAI,WAAW;AACX,YAAM,IAAI,MAAM,6DAA6D;;AAGjF,QAAI,iBAAiB,gBAAgB;AACjC,YAAM,IAAI,MAAM,4EAA4E;;AAGhG,QAAI,yBAAyB;;AAI7B,QAAI,gBAAgB,0BAA0B;AAC1C,WAAK,wBAAwB,gBAAgB,wBAAwB;WAClE;AACH,WAAK,wBAAwB,gBAAgB,YAAY;;EAEjE;EAEO,kBAAkB,SAA8B,yBAAyB,OAAO,gBAA2B;AAG9G,SAAK,uBAAuB;AAE5B,QAAI,gBAAgB;AAChB,qBAAc;;AAGlB,SAAK,wBAAwB,IAAI;EACrC;EAEO,0BAA0B,MAAe;AAC5C,WAAO,KAAK,mBAAmB,MAAM,IAAI;EAC7C;EAEO,yBAAyB,aAAyB,SAAuB,SAAiB,GAAC;AAC9F,UAAM,SAAS;AACf,UAAM,OAAO,KAAK,oBAAoB,OAAO;AAC7C,WAAO,WAAW,KAAK,sBAAsB;AAC7C,SAAK,QAAQ,yBAAyB,OAAO,mBAAoB,KAAK,QAAQ,KAAK,YAAY,KAAK,YAAY,MAAM;EAC1H;EAEO,0BAA0B,cAA0B,WAAsB,YAAqB,YAAmB;AACrH,UAAM,SAAS;AACf,UAAM,OAAO,YAAY,OAAO,SAAS,IAAI,YAAY,IAAI,aAAa,SAAS;AACnF,SAAK,QAAQ,0BAA0B,OAAO,oBAAqB,KAAK,QAAQ,KAAK,cAAc,cAAc,IAAI,cAAc,KAAK,UAAU;EACtJ;;EAGU,YAAY,SAAiB,SAAgC,uBAAuB,OAAO,sBAAsB,OAAK;AAC5H,UAAM,UAAU,KAAK,eAAe,OAAO;AAC3C,QAAI,CAAC,SAAS;AACV,aAAO;;AAIX,QAAI,CAAC,SAAS;AACV,UAAI,KAAK,oBAAoB,OAAO,KAAK,MAAM;AAC3C,aAAK,iBAAiB;AACtB,aAAK,oBAAoB,OAAO,IAAI;;AAExC,aAAO;;AAIX,QAAmB,QAAS,OAAO;AAC/B,WAAK,iBAAiB;AACP,cAAS,OAAM;eACvB,QAAQ,mBAAmB,GAAA;AAElC,cAAQ,UAAS;AACjB,aAAO;;AAGX,QAAI;AACJ,QAAI,qBAAqB;AACrB,wBAAwC,QAAS;eAC1C,QAAQ,QAAO,GAAI;AAC1B,wBAAmC,QAAQ,mBAAkB;eACtD,QAAQ,QAAQ;AACvB,wBAAkB,KAAK;eAChB,QAAQ,MAAM;AACrB,wBAAkB,KAAK;eAChB,QAAQ,WAAW;AAC1B,wBAAkB,KAAK;WACpB;AACH,wBAAkB,KAAK;;AAG3B,SAAK,iBAAiB;AAEtB,QAAI,CAAC,mBAAmB,CAAC,gBAAgB,kBAAkB;AACvD,aAAO;;AAGX,SAAK,oBACD,gBAAgB,iBAAiB,oBACjC,qBAAqB,QAAQ,KAAK,GAClC,qBAAqB,QAAQ,KAAK,GAClC,qBAAqB,QAAQ,KAAK,CAAC;AAEvC,SAAK,wBAAwB,OAAO;AAEpC,SAAK,gBAAgB,SAAS,gBAAgB,iBAAiB,kBAAkB;AAEjF,WAAO;EACX;;EAGQ,oBAAoB,SAAwB,QAAc;AAC9D,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,0BAA0B;AACzF,SAAK,sBAAsB,6BAA6B,OAAqB;AAC7E,SAAK,sBAAsB,yBAAyB,MAAM;AAC1D,SAAK,sBAAsB,sBAAqB;EACpD;;EAGQ,oBAAoB,SAAwB,cAAsB,cAAsB,cAAoB;AAChH,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,0BAA0B;AACzF,SAAK,sBAAsB,6BAA6B,OAAqB;AAC7E,SAAK,sBAAsB,yBAAyB,YAAY;AAChE,SAAK,sBAAsB,yBAAyB,YAAY;AAChE,SAAK,sBAAsB,yBAAyB,YAAY;AAChE,SAAK,sBAAsB,sBAAqB;EACpD;EAEQ,gBAAgB,SAAwB,SAAsB;AAClE,SAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kBAAkB;AACjF,SAAK,sBAAsB,6BAA6B,OAAO;AAC/D,SAAK,sBAAsB,6BAA6B,OAAO;AAC/D,SAAK,sBAAsB,sBAAqB;EACpD;;;EAIQ,wBAAwB,SAAoB;AAChD,UAAM,kBAAkB,QAAQ,mBAAkB;AAClD,UAAM,QAAQ,QAAQ;AAEtB,QAAI,CAAC,mBAAmB,CAAC,gBAAgB,kBAAkB;AACvD;;AAGJ,QAAI,gBAAgB,qCAAqC,OAAO;AAC5D,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,kCAAkC;AACjG,WAAK,sBAAsB,6BAA6B,gBAAgB,iBAAiB,kBAAkB;AAC3G,WAAK,sBAAsB,yBAAyB,KAAK;AACzD,WAAK,sBAAsB,sBAAqB;AAChD,sBAAgB,mCAAmC;;EAE3D;;;;EAKO,aAAa,SAAiB,SAAwB;AACzD,UAAM,UAAU,KAAK,eAAe,OAAO;AAC3C,QAAI,CAAC,SAAS;AACV;;AAEJ,QAAI,WAAW,QAAQ,kBAAkB;AACrC,YAAM,qBAAqB,QAAQ,iBAAiB;AACpD,WAAK,gBAAgB,SAAS,kBAAkB;;EAExD;EAEU,cAAc,QAAwB;AAC5C,QAAI,OAAO,mBAAmB;AAC1B,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,yBAAyB;AACxF,WAAK,sBAAsB,6BAA6B,OAAO,iBAAiB;AAChF,WAAK,sBAAsB,sBAAqB;AAChD,aAAO,OAAO;;AAGlB,QAAI,OAAO,oBAAoB;AAC3B,WAAK,sBAAsB,qBAAqB,QAAQ,OAAO,0BAA0B;AACzF,WAAK,sBAAsB,6BAA6B,OAAO,kBAAkB;AACjF,WAAK,sBAAsB,sBAAqB;AAChD,aAAO,OAAO;;EAEtB;;;;;;;EAQO,aAAa,OAAe,QAAc;AAC7C,QAAI,CAAC,QAAQ,QAAQ;AACjB,YAAM,IAAI,MAAM,qCAAqC;;AAEzD,UAAM,SAAS,IAAI,QAAQ,OAAM;AACjC,WAAO,QAAQ;AACf,WAAO,SAAS;AAChB,WAAO;EACX;;;;;EAMO,oBAAiB;AACpB,QAAI,CAAC,QAAQ,QAAQ;AACjB,YAAM,IAAI,MAAM,qCAAqC;;AAEzD,UAAM,QAAQ,IAAI,QAAQ,MAAK;AAC/B,WAAO;EACX;;;;;;;;;;;;;EAcO,kBACH,SACA,WACA,SACA,SACA,OACA,QACA,YAAoB,GACpB,MAAc,GACd,kBAAkB,OAAK;AAEvB,UAAM,IAAI,MAAM,oCAAoC;EACxD;;;;EAKO,uCACH,SACA,gBACA,OACA,QACA,MACA,YAAoB,GACpB,MAAc,GAAC;AAEf,UAAM,IAAI,MAAM,yDAAyD;EAC7E;;;;EAKO,6BAA6B,SAA0B,WAA4B,YAAoB,GAAG,MAAc,GAAC;AAC5H,UAAM,IAAI,MAAM,+CAA+C;EACnE;;;;EAKO,gCAAgC,SAA0B,WAA4B,YAAoB,GAAG,MAAc,GAAC;AAC/H,UAAM,IAAI,MAAM,kDAAkD;EACtE;;;;EAKO,sBAAsB,SAA0B,OAAyB,YAAoB,GAAG,MAAc,GAAC;AAClH,UAAM,IAAI,MAAM,kDAAkD;EACtE;EAEO,cAAc,MAAY;AAE7B,UAAM,SAAS,EAAE,QAAQ,GAAG,QAAQ,GAAG,SAAS,EAAC;AACjD,WAAO;EACX;;;;EAKO,mBAAgB;EAAU;EAE1B,mBACH,SACA,OACA,QACA,WACA,OACA,QACA,gBACA,mBACA,GACA,GAAU;AAj/ElB;AAm/EQ,QAAI,cAAc,UAAa,cAAc,IAAI;AAC7C,YAAM,IAAI,MAAM,4DAA4D,SAAS,GAAG;;AAG5F,WAAO,KAAK,QACP,aACG,aAAQ,qBAAR,mBAA0B,oBAC1B,SAAS,GACT,KAAK,GACL,KAAK,GACL,OACA,SACA,iCAAQ,WAAU,OAClB,iCAAQ,eAAc,IACtB,iCAAQ,eAAc,CAAC,EAE1B,KAAK,CAAC,cAAa;AAChB,UAAI,CAAC,QAAQ;AACT,iBAAS,IAAI,WAAW,SAAS;;AAGrC,aAAO;IACX,CAAC;EACT;;AA50EwB,aAAA,mBAAmB;;;ACtLzC,IAAO,gBAAP,MAAoB;EAStB,IAAW,UAAO;AACd,WAAO,KAAK,YAAY;EAC5B;EAEA,YAAoB,aAA2B;AAA3B,SAAA,cAAA;AAZH,SAAA,eAAe,IAAI,iBAAgB;AACnC,SAAA,UAAkB;MAC/B,WAAW,KAAK;MAChB,kBAAkB;;AAGL,SAAA,oBAAoB,IAAI,aAAa,IAAI,CAAC;AA0B3C,SAAA,YAAY,KAAK,YAAY,UAAW,KAAK,KAAK,WAAW;AAE7D,SAAA,gBAAgB,KAAK,YAAY,cAAc,KAAK,KAAK,WAAW;AAEpE,SAAA,oBAAoB,KAAK,YAAY,kBAAkB,KAAK,KAAK,WAAW;AAE5E,SAAA,qCAAqC,MAAK;AACtD,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAMgB,SAAA,eAAe,KAAK,YAAY,aAAc,KAAK,KAAK,WAAW;AAUnE,SAAA,eAAe,KAAK,YAAY,aAAc,KAAK,KAAK,WAAW;AAEnE,SAAA,iBAAiB,KAAK,YAAY,eAAgB,KAAK,KAAK,WAAW;AAEvE,SAAA,mBAAmB,MAAK;AACpC,YAAM,IAAI,MAAM,mDAAmD;IACvE;AAMgB,SAAA,0BAA0B,MAA8B;AACpE,aAAO,KAAK,YAAY,yBAAyB,CAAA;IACrD;EA1DkD;EAE3C,QAAQ,OAAgB,WAA2B;AACtD,QAAI,CAAC,KAAK,YAAY,YAAY,OAAO,WAAW,KAAK,kBAAkB,QAAQ,KAAK,aAAa,OAAO,MAAM,GAAG;AACjH,aAAO;;AAEX,UAAM,WAAW,KAAK,aAAa;AACnC,aAAS,IAAI,KAAK,kBAAkB,CAAC;AACrC,aAAS,IAAI,KAAK,kBAAkB,CAAC;AACrC,aAAS,IAAI,KAAK,kBAAkB,CAAC;AACrC,aAAS,IAAI,KAAK,kBAAkB,CAAC;AAErC,UAAM,cAAc,KAAK,aAAa;AACtC,gBAAY,IAAI,KAAK,kBAAkB,CAAC;AACxC,gBAAY,IAAI,KAAK,kBAAkB,CAAC;AACxC,gBAAY,IAAI,KAAK,kBAAkB,CAAC;AACxC,gBAAY,IAAI,KAAK,kBAAkB,CAAC;AACxC,WAAO,KAAK;EAChB;EAYA,IAAW,iBAAc;AACrB,WAAO,KAAK,YAAY;EAC5B;EAIA,IAAW,mBAAgB;AACvB,WAAO,KAAK,YAAY;EAC5B;EAEA,IAAW,iBAAc;AACrB,WAAO,KAAK,YAAY;EAC5B;EAUA,IAAW,oBAAiB;AACxB,WAAO,KAAK,YAAY;EAC5B;EAMO,oBAAoB,MAAY;AACnC,UAAM,IAAI,MAAM,kDAAkD;EAEtE;;AAGJ,wBAAwB,iBAAiB,aAAa;",
  "names": ["_a", "_b", "ImageTrackingScoreStatus", "name", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "event", "babylonLayer", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "name", "name", "shader", "i", "name", "parameters", "name", "index", "image"]
}
