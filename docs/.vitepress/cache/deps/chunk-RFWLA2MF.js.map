{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.scalar.ts", "../../../dev/core/src/Maths/math.constants.ts", "../../../dev/core/src/Misc/arrayTools.ts"],
  "sourcesContent": ["/**\r\n * Scalar computation library\r\n */\r\nexport class Scalar {\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    public static TwoPi: number = Math.PI * 2;\r\n\r\n    /**\r\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     * @param a number\r\n     * @param b number\r\n     * @param epsilon (default = 1.401298E-45)\r\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     */\r\n    public static WithinEpsilon(a: number, b: number, epsilon: number = 1.401298e-45): boolean {\r\n        return Math.abs(a - b) <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Returns a string : the upper case translation of the number i to hexadecimal.\r\n     * @param i number\r\n     * @returns the upper case translation of the number i to hexadecimal.\r\n     */\r\n    public static ToHex(i: number): string {\r\n        const str = i.toString(16);\r\n\r\n        if (i <= 15) {\r\n            return (\"0\" + str).toUpperCase();\r\n        }\r\n\r\n        return str.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    public static Sign(value: number): number {\r\n        value = +value; // convert to a number\r\n\r\n        if (value === 0 || isNaN(value)) {\r\n            return value;\r\n        }\r\n\r\n        return value > 0 ? 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the value itself if it's between min and max.\r\n     * Returns min if the value is lower than min.\r\n     * Returns max if the value is greater than max.\r\n     * @param value the value to clmap\r\n     * @param min the min value to clamp to (default: 0)\r\n     * @param max the max value to clamp to (default: 1)\r\n     * @returns the clamped value\r\n     */\r\n    public static Clamp(value: number, min = 0, max = 1): number {\r\n        return Math.min(max, Math.max(min, value));\r\n    }\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static Log2(value: number): number {\r\n        return Math.log(value) * Math.LOG2E;\r\n    }\r\n\r\n    /**\r\n     * the floor part of a log2 value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static ILog2(value: number): number {\r\n        if (Math.log2) {\r\n            return Math.floor(Math.log2(value));\r\n        }\r\n\r\n        if (value < 0) {\r\n            return NaN;\r\n        } else if (value === 0) {\r\n            return -Infinity;\r\n        }\r\n\r\n        let n = 0;\r\n        if (value < 1) {\r\n            while (value < 1) {\r\n                n++;\r\n                value = value * 2;\r\n            }\r\n            n = -n;\r\n        } else if (value > 1) {\r\n            while (value > 1) {\r\n                n++;\r\n                value = Math.floor(value / 2);\r\n            }\r\n        }\r\n\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * Loops the value, so that it is never larger than length and never smaller than 0.\r\n     *\r\n     * This is similar to the modulo operator but it works with floating point numbers.\r\n     * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n     * With t = 5 and length = 2.5, the result would be 0.0.\r\n     * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n     * @param value the value\r\n     * @param length the length\r\n     * @returns the looped value\r\n     */\r\n    public static Repeat(value: number, length: number): number {\r\n        return value - Math.floor(value / length) * length;\r\n    }\r\n\r\n    /**\r\n     * Normalize the value between 0.0 and 1.0 using min and max values\r\n     * @param value value to normalize\r\n     * @param min max to normalize between\r\n     * @param max min to normalize between\r\n     * @returns the normalized value\r\n     */\r\n    public static Normalize(value: number, min: number, max: number): number {\r\n        return (value - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n     * Denormalize the value from 0.0 and 1.0 using min and max values\r\n     * @param normalized value to denormalize\r\n     * @param min max to denormalize between\r\n     * @param max min to denormalize between\r\n     * @returns the denormalized value\r\n     */\r\n    public static Denormalize(normalized: number, min: number, max: number): number {\r\n        return normalized * (max - min) + min;\r\n    }\r\n\r\n    /**\r\n     * Calculates the shortest difference between two given angles given in degrees.\r\n     * @param current current angle in degrees\r\n     * @param target target angle in degrees\r\n     * @returns the delta\r\n     */\r\n    public static DeltaAngle(current: number, target: number): number {\r\n        let num: number = Scalar.Repeat(target - current, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n     * @param tx value\r\n     * @param length length\r\n     * @returns The returned value will move back and forth between 0 and length\r\n     */\r\n    public static PingPong(tx: number, length: number): number {\r\n        const t: number = Scalar.Repeat(tx, length * 2.0);\r\n        return length - Math.abs(t - length);\r\n    }\r\n\r\n    /**\r\n     * Interpolates between min and max with smoothing at the limits.\r\n     *\r\n     * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n     * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tx value\r\n     * @returns the smooth stepped value\r\n     */\r\n    public static SmoothStep(from: number, to: number, tx: number): number {\r\n        let t: number = Scalar.Clamp(tx);\r\n        t = -2.0 * t * t * t + 3.0 * t * t;\r\n        return to * t + from * (1.0 - t);\r\n    }\r\n\r\n    /**\r\n     * Moves a value current towards target.\r\n     *\r\n     * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n     * Negative values of maxDelta pushes the value away from target.\r\n     * @param current current value\r\n     * @param target target value\r\n     * @param maxDelta max distance to move\r\n     * @returns resulting value\r\n     */\r\n    public static MoveTowards(current: number, target: number, maxDelta: number): number {\r\n        let result: number = 0;\r\n        if (Math.abs(target - current) <= maxDelta) {\r\n            result = target;\r\n        } else {\r\n            result = current + Scalar.Sign(target - current) * maxDelta;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n     *\r\n     * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n     *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n     * @param current current value\r\n     * @param target target value\r\n     * @param maxDelta max distance to move\r\n     * @returns resulting angle\r\n     */\r\n    public static MoveTowardsAngle(current: number, target: number, maxDelta: number): number {\r\n        const num: number = Scalar.DeltaAngle(current, target);\r\n        let result: number = 0;\r\n        if (-maxDelta < num && num < maxDelta) {\r\n            result = target;\r\n        } else {\r\n            target = current + num;\r\n            result = Scalar.MoveTowards(current, target, maxDelta);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static Lerp(start: number, end: number, amount: number): number {\r\n        return start + (end - start) * amount;\r\n    }\r\n\r\n    /**\r\n     * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n     * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static LerpAngle(start: number, end: number, amount: number): number {\r\n        let num: number = Scalar.Repeat(end - start, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return start + num * Scalar.Clamp(amount);\r\n    }\r\n\r\n    /**\r\n     * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n     * @param a start value\r\n     * @param b target value\r\n     * @param value value between a and b\r\n     * @returns the inverseLerp value\r\n     */\r\n    public static InverseLerp(a: number, b: number, value: number): number {\r\n        let result: number = 0;\r\n        if (a != b) {\r\n            result = Scalar.Clamp((value - a) / (b - a));\r\n        } else {\r\n            result = 0.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns hermite result\r\n     */\r\n    public static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(value1: number, tangent1: number, value2: number, tangent2: number, time: number): number {\r\n        const t2 = time * time;\r\n        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\r\n    }\r\n\r\n    /**\r\n     * Returns a random float number between and min and max values\r\n     * @param min min value of random\r\n     * @param max max value of random\r\n     * @returns random value\r\n     */\r\n    public static RandomRange(min: number, max: number): number {\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        return Math.random() * (max - min) + min;\r\n    }\r\n\r\n    /**\r\n     * This function returns percentage of a number in a given range.\r\n     *\r\n     * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n     * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n     * @param number to convert to percentage\r\n     * @param min min range\r\n     * @param max max range\r\n     * @returns the percentage\r\n     */\r\n    public static RangeToPercent(number: number, min: number, max: number): number {\r\n        return (number - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n     * This function returns number that corresponds to the percentage in a given range.\r\n     *\r\n     * PercentToRange(0.34,0,100) will return 34.\r\n     * @param percent to convert to number\r\n     * @param min min range\r\n     * @param max max range\r\n     * @returns the number\r\n     */\r\n    public static PercentToRange(percent: number, min: number, max: number): number {\r\n        return (max - min) * percent + min;\r\n    }\r\n\r\n    /**\r\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n     * @param angle The angle to normalize in radian.\r\n     * @returns The converted angle.\r\n     */\r\n    public static NormalizeRadians(angle: number): number {\r\n        // More precise but slower version kept for reference.\r\n        // angle = angle % Tools.TwoPi;\r\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n\r\n        //if (angle > Math.PI) {\r\n        //\tangle -= Tools.TwoPi;\r\n        //}\r\n\r\n        angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\r\n\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Returns the highest common factor of two integers.\r\n     * @param a first parameter\r\n     * @param b second parameter\r\n     * @returns HCF of a and b\r\n     */\r\n    public static HCF(a: number, b: number): number {\r\n        const r: number = a % b;\r\n        if (r === 0) {\r\n            return b;\r\n        }\r\n        return Scalar.HCF(b, r);\r\n    }\r\n}\r\n", "/**\r\n * Constant used to convert a value to gamma space\r\n * @ignorenaming\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const ToGammaSpace = 1 / 2.2;\r\n\r\n/**\r\n * Constant used to convert a value to linear space\r\n * @ignorenaming\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const ToLinearSpace = 2.2;\r\n\r\n/**\r\n * Constant Golden Ratio value in Babylon.js\r\n * @ignorenaming\r\n */\r\nexport const PHI = (1 + Math.sqrt(5)) / 2;\r\n\r\n/**\r\n * Constant used to define the minimal number value in Babylon.js\r\n * @ignorenaming\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst Epsilon = 0.001;\r\nexport { Epsilon };\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport type { Nullable } from \"../types\";\r\n\r\n/** @internal */\r\ninterface TupleTypes<T> {\r\n    2: [T, T];\r\n    3: [T, T, T];\r\n    4: [T, T, T, T];\r\n    5: [T, T, T, T, T];\r\n    6: [T, T, T, T, T, T];\r\n    7: [T, T, T, T, T, T, T];\r\n    8: [T, T, T, T, T, T, T, T];\r\n    9: [T, T, T, T, T, T, T, T, T];\r\n    10: [T, T, T, T, T, T, T, T, T, T];\r\n    11: [T, T, T, T, T, T, T, T, T, T, T];\r\n    12: [T, T, T, T, T, T, T, T, T, T, T, T];\r\n    13: [T, T, T, T, T, T, T, T, T, T, T, T, T];\r\n    14: [T, T, T, T, T, T, T, T, T, T, T, T, T, T];\r\n    15: [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T];\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for arrays.\r\n */\r\nexport class ArrayTools {\r\n    /**\r\n     * Returns an array of the given size filled with elements built from the given constructor and the parameters.\r\n     * @param size the number of element to construct and put in the array.\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\r\n     * @returns a new array filled with new objects.\r\n     */\r\n    public static BuildArray<T>(size: number, itemBuilder: () => T): Array<T> {\r\n        const a: T[] = [];\r\n        for (let i = 0; i < size; ++i) {\r\n            a.push(itemBuilder());\r\n        }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.\r\n     * @param size he number of element to construct and put in the tuple.\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.\r\n     * @returns a new tuple filled with new objects.\r\n     */\r\n    public static BuildTuple<T, N extends keyof TupleTypes<unknown>>(size: N, itemBuilder: () => T): TupleTypes<T>[N] {\r\n        return ArrayTools.BuildArray(size, itemBuilder) as any;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the callback type used when an observed array function is triggered.\r\n * @internal\r\n */\r\nexport type _ObserveCallback = (functionName: string, previousLength: number) => void;\r\n\r\n/**\r\n * Observes a function and calls the given callback when it is called.\r\n * @param object Defines the object the function to observe belongs to.\r\n * @param functionName Defines the name of the function to observe.\r\n * @param callback Defines the callback to call when the function is called.\r\n * @returns A function to call to stop observing\r\n */\r\nfunction _observeArrayfunction(object: { [key: string]: any }, functionName: string, callback: _ObserveCallback): Nullable<() => void> {\r\n    // Finds the function to observe\r\n    const oldFunction = object[functionName];\r\n    if (typeof oldFunction !== \"function\") {\r\n        return null;\r\n    }\r\n\r\n    // Creates a new function that calls the callback and the old function\r\n    const newFunction = function () {\r\n        const previousLength = object.length;\r\n        const returnValue = newFunction.previous.apply(object, arguments);\r\n        callback(functionName, previousLength);\r\n        return returnValue;\r\n    } as any;\r\n\r\n    // Doublishly links the new function and the old function\r\n    oldFunction.next = newFunction;\r\n    newFunction.previous = oldFunction;\r\n\r\n    // Replaces the old function with the new function\r\n    object[functionName] = newFunction;\r\n\r\n    // Returns a function to disable the hook\r\n    return () => {\r\n        // Only unhook if the function is still hooked\r\n        const previous = newFunction.previous;\r\n        if (!previous) {\r\n            return;\r\n        }\r\n\r\n        // Finds the ref to the next function in the chain\r\n        const next = newFunction.next;\r\n\r\n        // If in the middle of the chain, link the previous and next functions\r\n        if (next) {\r\n            previous.next = next;\r\n            next.previous = previous;\r\n        }\r\n        // If at the end of the chain, remove the reference to the previous function\r\n        // and restore the previous function\r\n        else {\r\n            previous.next = undefined;\r\n            object[functionName] = previous;\r\n        }\r\n\r\n        // Lose reference to the previous and next functions\r\n        newFunction.next = undefined;\r\n        newFunction.previous = undefined;\r\n    };\r\n}\r\n\r\n/**\r\n * Defines the list of functions to proxy when observing an array.\r\n * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.\r\n */\r\nconst observedArrayFunctions = [\"push\", \"splice\", \"pop\", \"shift\", \"unshift\"];\r\n\r\n/**\r\n * Observes an array and notifies the given observer when the array is modified.\r\n * @param array Defines the array to observe\r\n * @param callback Defines the function to call when the array is modified (in the limit of the observed array functions)\r\n * @returns A function to call to stop observing the array\r\n * @internal\r\n */\r\nexport function _ObserveArray<T>(array: T[], callback: _ObserveCallback) {\r\n    // Observes all the required array functions and stores the unhook functions\r\n    const unObserveFunctions = observedArrayFunctions.map((name) => {\r\n        return _observeArrayfunction(array, name, callback);\r\n    });\r\n\r\n    // Returns a function that unhook all the observed functions\r\n    return () => {\r\n        unObserveFunctions.forEach((unObserveFunction) => {\r\n            unObserveFunction?.();\r\n        });\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
